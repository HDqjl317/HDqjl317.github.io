<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://hdqjl317.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://hdqjl317.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://hdqjl317.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="编译"><link rel="canonical" href="https://hdqjl317.github.io/2023/06/30/computer-science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><title>编译原理 - 计算机科学 | Caleb = = 加楽的小站</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">编译原理</h1><div class="meta"><span class="item" title="创建时间：2023-06-30 16:50:54"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-06-30T16:50:54+08:00">2023-06-30</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>11k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>10 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Caleb</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/assets/byyl.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hdqjl317.github.io/2023/06/30/computer-science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Caleb"><meta itemprop="description" content="加楽的小站, 欢迎来到 Caleb 的个人博客!"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h2 id="什么是编译器"><a class="anchor" href="#什么是编译器">#</a> 什么是编译器</h2><p>所谓编译原理，也就是编译器的工作原理，因此先要明白什么是编译器。编译器的基本定义是：将一门语言转换为另一门语言，一般指将高级语言转换为机器语言，但仅仅是转换并不执行。编译器最基本的底线，就是保证源代码和目标代码的语义相同。</p><h3 id="在程序运行中的地位"><a class="anchor" href="#在程序运行中的地位">#</a> 在程序运行中的地位</h3><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165538192.png" alt=""></p><p>如上图。编译器就是将源代码转换（即翻译）为目标程序，然后再交给机器去执行，这个应该很好理解。之所以要转换，是因为计算机本质上只能识别机器代码，不能识别高级语言 。简单解释一下这张图的各个部分。</p><ul><li>“源代码” 是 C java 等高级语言，每种程序对应的编译器可能都不一样</li><li>“静态计算” 是指编译器只根据程序文本静态的分析（如做报错分析、优化分析），而不是真的拿 CPU 去执行</li><li>生成的 “目标程序” 可能是 x86 汇编（如对应 C 语言），也可能是 bytecode 字节码（如对应 java）</li><li>“计算机” 可能是一个 x86 的物理器（如对应 C 语言），也可能是 JVM java 虚拟机（如对应 java）。即不一定是一个真实的机器，可能是虚拟机，但这里都统称为 “计算机”</li></ul><p>另外再解释一下编译器和另外一个常见的叫做 “解释器” 的对比。两者有很多共同点，但是有以下区别：</p><ul><li>编译器：输入源代码，输出的一个可执行程序，但不去执行（存放在磁盘上等待被加载到内存中执行）</li><li>解释器：输入源代码，直接输出执行结果。其实 JVM 就是一个解释器，而不是一个单纯的编译器。输入 java 字节码 bytecode ，然后直接输出执行结果，而不是输出汇编代码。</li></ul><h3 id="内部结构"><a class="anchor" href="#内部结构">#</a> 内部结构</h3><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165616680.png" alt=""></p><p>如上图，就是一个编译器最简单的内部结构（没有考虑代码优化过程）。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165702453.png" alt=""></p><p>如上图，这是一个更加复杂的编译器，各个过程都比较完备。其实拆开来看，编译器是一个 “流水线”，由一个一个的小程序分流水线执行。因为编译器规模庞大复杂，拆分模块容易实现和维护。</p><p>编译器通常会被划分为两个部分（如下图）：</p><ul><li><p>前端：源代码生成中间代码，和源代码有关</p></li><li><p>后端：中间代码生成目标代码并优化，和目标代码有关</p></li><li><p>两者以抽象语法树 AST 作为连接数据</p><p></p></li></ul><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165702453.png" alt=""></p><h3 id="一个简单的例子"><a class="anchor" href="#一个简单的例子">#</a> 一个简单的例子</h3><p>背景一，现在我们设计一个叫做 Sum 的语言，特别简单，仅仅支持两种语法。第一是整形数字 <code>n</code> ，第二是加法表达式 <code>e1 + e2</code> 。举几个例子：</p><ul><li><code>3</code></li><li><code>5 + 6</code></li><li><code>7 + 8 + 9</code> （加法要满足左结合性，即先计算 <code>7 + 8</code> ）</li><li><code>7 + (8 + 9)</code></li><li>但不支持 <code>7 + 8 * 9</code> Sum 语言中没有乘法</li></ul><p>背景二，有一个栈试计算机 Stack （后面会再次讲到），其中有一个操作数栈，然后只支持两条指令 <code>push n</code> 和 <code>add</code> 。之所以选择栈式计算机，第一是因为简单，第二是因为 JVM 就是采用了这种形式。其指令的详情是：</p><ul><li><code>push 3</code> 将 3 压栈</li><li><code>push 4</code> 将 4 压栈</li><li><code>add</code> 将 3 和 4 出栈，然后做加法得到 7 ，再将 7 压栈。即将栈顶的两个元素都出栈，做加分，将结果再压栈</li></ul><p>有了上述两个背景之后，接下来的任务是：编译程序 <code>1 + 2 + 3</code> 到栈式计算机 Stack 。</p><p>第一个阶段进行词法分析，先不管其中的原理是什么，总之词法分析会将 <code>1 + 2 + 3</code> 拆分为 <code>1</code> <code>+</code> <code>2</code> <code>+</code> <code>3</code> 这 5 个部分。<br>第二阶段是语法分析，就是将词法分析拆分出来的内容，分析是否满足 Sum 语言的语法要求，即 <code>e1 + e2</code> 这种语法。<br>第三个阶段是语法树构造，经过某些计算之后，得到的抽象语法树如下图。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165829650.png" alt=""></p><p>第四个阶段，根据抽象语法树做代码生成。首先，要满足加法的左结合性，对树进行遍历的时候就要优先遍历左子树，即<strong>后序遍历</strong>。在遍历树节点的过程中，如果遇到整数 <code>n</code> 就生成一条 <code>push n</code> 指令，如果遇到 <code>+</code> 就生成一条 <code>add</code> 指令。接下来详细看一下这棵树的遍历过程：</p><ul><li>第一步要访问的节点是 <code>1</code> ，生成 <code>push 1</code> ，将 1 压栈</li><li>第二步要访问的节点是 <code>2</code> ，生成 <code>push 2</code> ，将 2 压栈</li><li>第三步要访问的节点是 <code>+</code> ，生成 <code>add</code> ，将 1 2 出栈，计算加法得到 3 ，将 3 压栈 （这里即体现了加法的左结合性）</li><li>第四步要访问的节点是 <code>3</code> ，生成 <code>push 3</code> ，将 3 压栈</li><li>第五步要访问的节点是 <code>+</code> ，生成 <code>add</code> ，将 3 3 出栈，计算加法得到 6 ，将 6 压栈，完成</li></ul><hr><h2 id="词法分析"><a class="anchor" href="#词法分析">#</a> 词法分析</h2><p>从编译器内部结构得知，执行编译的第一个阶段就是词法分析。<strong>输入是源程序代码，输出一个记号（即 token）流或者单词流</strong>。通俗来说，就是将源代码进行最细粒度的拆解，例如上面的例子将 <code>1 + 2 + 3</code> 拆分为 <code>1</code> <code>+</code> <code>2</code> <code>+</code> <code>3</code> 一样。</p><h3 id="一个例子"><a class="anchor" href="#一个例子">#</a> 一个例子</h3><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165938490.png" alt=""></p><p>如上图。从源代码到记号流（或单词流），记号就是 token 。词法分析器会将源程序根据关键字、标识符（变量）、括号、引号、运算符、值（整数、字符串）等这些要素，将其从左到右拆分为若干个记号（或者单词），其中会忽略空格和换行等。上图中：</p><ul><li><code>IF</code> 关键字</li><li><code>LPAREN</code> <code>RPAREN</code> 左右括号</li><li><code>INDENT(x)</code> 即标识符（变量），有一个属性 <code>x</code> ，表示变量名</li><li><code>GR</code> 即 <code>&gt;</code></li><li><code>INT(t)</code> 即 <code>int</code> 类型值，属性是 <code>5</code></li><li>其他同理……</li><li>最后红色的 <code>EOF</code> 是结束符</li></ul><p>根据上面的例子，可以总结出 token 其实有固定的形式，就可以定义其数据结构，如下图（本文中高级语言的示例，默认情况下都是 C 语言）</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170050889.png" alt=""></p><p>理解了例子，定义了数据，接下来就要去探寻词法分析的实现算法，第一，手工构造；第二，自动生成 。</p><h3 id="词法分析的手工构造法"><a class="anchor" href="#词法分析的手工构造法">#</a> 词法分析的手工构造法</h3><p>手工构造即手写一个词法分析器，例如 GCC LLVM ，优点是利于掌控和优化细节，缺点是工作量大、易出错。手工构造法主要用到 “转移图” 这种数据结构，下面举两个例子说明。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170106446.png" alt=""></p><p>上图的转移图模型，即可识别逻辑运算符，如 <code>&lt;=</code> <code>&lt;</code> <code>&lt;&gt;</code> <code>&gt;=</code> <code>&gt;</code> 。识别到第一个字符，就继续往下做分支判断，直到返回一个确定的运算符。图中的 <code>*</code> 即一次回溯，即将当前的这个字符再返回到词法分析器重新进行分析。例如 <code>&gt;1</code> ，读到了 <code>1</code> 这个字符时，此时已经确定了运算符是 <code>&gt;</code> ，而当前的 <code>1</code> 并不是运算符的一部分，因此将 <code>1</code> 再重新返回到词法分析器中重新进行分析。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170142816.png" alt=""></p><p>上图是标识符（变量）的转移图模型，以及伪代码。其中 <code>*</code> 即一次回溯，跟上面一样。</p><p>关键字（如 <code>class</code> <code>if</code> <code>for</code> 等）是一种特殊的标识符，也满足标识符的规则。要识别关键字，有两种解决方案：</p><ul><li>继续扩展转移图的分支，识别到关键字走不通的分支逻辑，最后识别出关键字。</li><li>先识别所有的合法标识符，然后从已经识别出来的标识符中查找关键字。此时需要为该语言所有的关键字维护一个哈希表，如果数据结构合理（完美哈希），查询可以在 <code>O(1)</code> 复杂度内完成。</li></ul><h3 id="词法分析的自动生成技术"><a class="anchor" href="#词法分析的自动生成技术">#</a> 词法分析的自动生成技术</h3><p>所谓自动生成技术，就是有这样现成的工具（如 lex flex jlex），输入一些声明式的规范，即可自动生成一个词法分析器。有点当然是简单快速，缺点就是无法控制细节。而这里的 “声明式规范”，就是我们常见的正则表达式。下文的内容，就是如何用程序去解析正则表达式，如果你之前看过关于 “正则表达式 原理” 这类的文章，可能早就有了解了。</p><p>先说一下自动生成技术的几个阶段，专业术语后面都有解释：</p><ul><li>正则表达式 -&gt; NFA</li><li>NFA -&gt; DFA</li><li>DFA -&gt; 词法分析代码，即完成自动生成</li></ul><h4 id="正则表达式"><a class="anchor" href="#正则表达式">#</a> 正则表达式</h4><p>不要以为用过正则表达式就觉得它很简单了，如果你是通过看 “30 分钟入门正则表达式” 这类文章开始接触的，还是建议你仔细阅读这里关于正则表达式的解释。笔者也是看了这门课才对正则表达式有了新的认识。</p><p>正则表达式是一种数学上的概念，首先它要有一个完整的字符集 <code>Σ = &#123;...&#125;</code> 要能涵盖程序所有的关键字、变量名、数字、运算符、括号、引号、特殊符号等</p><ul><li>如 C 语言的这个字符集就是 ASC 编码，即 256 个字符</li><li>如 java 的字符集就是 unicode 编码，可能几万甚至十几万个字符集（因为 java 的变量名称并不仅限于英文、中文也可以作为变量）</li></ul><p>然后只有以下几个基本的逻辑：</p><ul><li>空串是正则表达式</li><li>单个字符是正则表达式</li><li><code>a|b</code> 是正则表达式，两者取并集</li><li><code>ab</code> 是正则表达式，两者相连</li><li><code>a*</code> 成为 “闭包”（和程序的闭包不一样），即可以有 0 或者若干个 <code>a</code></li><li>以上随机组合，都是正则表达式，例如 <code>a|(bc*)</code></li></ul><p>这就是正则表达式的定义，而现代正则表达式这么多的语法，例如 <code>[a-b]</code> <code>?</code> <code>+</code> 等，都是后来扩展出的语法糖，即对基本规则的一种简写方式。</p><h4 id="有限状态自动机-fa"><a class="anchor" href="#有限状态自动机-fa">#</a> 有限状态自动机 FA</h4><p>也称 “有穷自动机”，是一种数学模型。简单理解，就是输入一个字符串，输出这个字符串是否满足某个规则（true /false）。例如有 <code>a + b</code> 这样一个规则，输入 <code>“1 + 2 ”</code> 就满足，输 <code>“abc”</code> 这就不满足。其实现原理，就是先设定几个状态，然后根据输入的字符做状态转移，看最后能否转移到最终的状态。如下图，输入 <code>abbaabb</code> ，初始状态是 <code>0</code> ，然后分别输入一个一个的字符，看最后能否将状态转移到 <code>3</code> 。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170207504.png" alt=""></p><p>有限状态自动机 FA 又分为两种：</p><ul><li>确定的有限状态自动机 DFA 。针对一个状态，输入一个字符，只能有一个出口。</li><li>非确定的有限状态自动机 NFA 。针对一个状态，输入一个字符，可能会有多个出口。如上图中的 <code>0</code> 状态，输入 <code>a</code> 时有两个出口，所以它是 NFA 。</li></ul><p>看过 “正则表达式 原理” 类似文章的应该知道，其实每一个正则表达式，都能对应一个 FA ，因此接下来看一下正则表达式如何生成 FA 。</p><h4 id="从正则表达式-re-到有限状态自动机-fa"><a class="anchor" href="#从正则表达式-re-到有限状态自动机-fa">#</a> 从正则表达式 RE 到有限状态自动机 FA</h4><p>先将正则表达式生成 NFA ，再将 NFA 生成 DFA 。这是因为：第一，RE 生成 NFA 比直接生成 DFA 更加简单；第二， NFA 做分析算法比较复杂，多个出口导致复杂度变高。因此，往往是将 NFA 转换为等价的 DFA ，然后再拿来做运算。</p><p>从 RE 生成 NFA 课程中讲解了 Thompson 算法（Ken Thompson，unix 和 C 语言之父，1984 年图领奖）。具体内容我大体看明白了，不过太细节的也没必要记录了。其基本的逻辑是：</p><ul><li>对基本的 RE（空串、单个字符） 直接构造</li><li>对复杂的 RE （或、连接、闭包）递归构造</li></ul><p>从 NFA 转换 DFA ，子集构造算法。所谓 “子集” 就是原来 NFA 的若干状态的集合，通过构造子集，来实现 DFA 。也就是说，此时构造出来的 DFA 就不单单是一个一个的状态节点了，而是一个一个的状态子集。</p><p>另外，转换到了 DFA 之后，还要对 DFA 进行最小化的优化，课程中讲了 Hopcroft 算法。基本逻辑是，将生成的 DFA 的子集再进行合并，减少节点数量。状态节点越少，占用的空间复杂度越少，提高运算效率。</p><h4 id="根据-dfa-生成词法分析代码"><a class="anchor" href="#根据-dfa-生成词法分析代码">#</a> 根据 DFA 生成词法分析代码</h4><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170236807.png" alt=""></p><p>DFA 实质上是带有边和节点的有向图，如上图。图中第一列是状态，第一行是字符，例如：</p><ul><li>在状态 <code>0</code> 时，输入字符 <code>a</code> ，行列交叉点是 <code>1</code> ，表示可以转向状态 <code>1</code></li><li>在状态 <code>1</code> 时，输入字符 <code>a</code> ，行列交叉点是 <code>2</code> ，表示可以转向状态 <code>2</code></li><li>在状态 <code>1</code> 时，输入字符 <code>b</code> ，行列交叉点是 <code>1</code> ，表示可以转向状态 <code>1</code></li></ul><p>有了以上所有的逻辑，就可以判断一个字符串是否符合一个 RE 的规定，即可将字符串拆分为一个一个的 token 。这个方法叫做 “转移表法”，课程中还讲了 “哈希表” 和 “跳转表”，没有详细记录。</p><hr><h2 id="语法分析"><a class="anchor" href="#语法分析">#</a> 语法分析</h2><p>词法分析之后，输出了记号流，然后传递给语法分析，这里主要有两部分工作：</p><ul><li>输入一个程序语法的表示，判断是否符合程序的语法</li><li>如果符合，就根据输入的符号集，生成抽象语法树 AST</li></ul><h3 id="上下文无关文法-cfg"><a class="anchor" href="#上下文无关文法-cfg">#</a> 上下文无关文法 CFG</h3><p>上文所说的 “程序语法的表示”，就是上下文无关文法 CFG ，是一个描述语言语法规则的标准的数学工具。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170303206.png" alt=""></p><p>上图的左侧就是一个 CFG 的简单示例，其中每一条叫做 “产生式”，图中的 <code>|</code> 即 “或” 的意思。简单解释一下这个 CFG 的意思：</p><ul><li><p>“S -&gt; N V N” 就是一个句子，其实 S 是开始符号</p></li><li><p>N 和 V 都是非终结符，即它可以继续再往下扩展拆分，就像 “S -&gt; N V N” 那样拆分</p></li><li><p>t g e 等这些都是终结符，即已经表述一个具体的事情了，没法再往下拆分了</p><p></p></li></ul><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170317523.png" alt=""></p><p>上图就用 CFG 描述了一个 <code>*</code> 和 <code>+</code> 表达式，其中 <code>num</code> 表示一个具体的数字， <code>id</code> 表示标识符（变量），这俩都是终结符， <code>E</code> 是非终结符。</p><p>从上面的例子来看，可以根据一个 CFG 推导出若干个句子，例如上图的 CFG 可以推导出 <code>id + num</code> 或者 <code>id * num</code> 或者 <code>(id + num) * num</code> 或者 ……</p><p><strong>语法分析就是：给定一个文法 G 和句子 s ，要确定：是否能在 G 的推导结果中，找到 s ？（即，是否存在对句子的推导）</strong> 如果能推导出来，说明句子 s 符合文法 G 的语法，否则不符合。如下图：</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170406338.png" alt=""></p><p>推导方式一般有两种：</p><ul><li>最左推导：每次推导过程当中总是选择最左侧的符号进行替换</li><li>最右推导：同理，选择最右侧</li></ul><h3 id="分析树和二义性"><a class="anchor" href="#分析树和二义性">#</a> 分析树和二义性</h3><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170430263.png" alt=""></p><p>如上图，在文法的推导过程中，可以用树的形式来表示，即分析树。其中， 内部节点都是非终结符，叶子节点都是终结符，<strong>中序遍历</strong>即可得到最终的句子。PS：到这里，貌似已经看到了最终输出的抽象语法树 AST 的雏形了，其本质就是来源于 CFG 的格式。</p><p>所谓 “二义性” 就是指文法的书写会产生一些歧义，例如上图中 <code>*</code> 和 <code>+</code> 表达式的文法，采用最左推导和最右推导得出的结果是不一样的，可能分别得出 <code>(3+4)*5</code> 和 <code>3+(4*5)</code> ，显然计算结果不同。为了避免文法的二义性，只能是重写文法，将文法表述的更加详细一些，此处不做详解。</p><h3 id="自顶向下分析算法"><a class="anchor" href="#自顶向下分析算法">#</a> 自顶向下分析算法</h3><p>上文已经明确了语法分析的定义，即看一个文法 G 是否存在对句子 s 的推导。自顶向下分析就是其中一个比较典型的算法，其基本逻辑是：</p><ul><li>即通过文法 G 随意推导出一个句子 t ，然后拿 t 和目标句子 s 进行对比</li><li>如果 t == s ，则成功</li><li>如果 t != s ，则回溯，从新计算一个 t1 ，再比较</li></ul><p>但是，上述过程比较笨重，因为一个 G 能推导出来的句子可能有非常多种，都拿来跟 s 做比较，会发生很多回溯，非常耗时。可以用以下方式进行优化：</p><ul><li>从左到右的推导顺序，可以最先得到句子 t 的左侧</li><li>拿 t 最先得到的左侧，和 s 左侧进行对比</li><li>对比成功，则继续从左到右推导（接下来的推导，也都是没推导出左侧就和 s 对应的左侧部分进行对比，看是否成功）</li><li>对比不成功，则回溯重来</li></ul><p>但是，上述优化后的算法，还是可能会有回溯发生，这远远达不到编译器的性能要求。编译器要处理的程序动辄几十万行，必须要求线性时间复杂度的算法，一旦有回溯就会严重影响性能。</p><h3 id="递归下降分析算法"><a class="anchor" href="#递归下降分析算法">#</a> 递归下降分析算法</h3><p>也称预测分析算法，其基本思路是：</p><ul><li><p>每个非终结符构造一个分析函数（即将整个文法匹配整个句子的方式，拆解开，用单个非终结符去匹配句子中的字符，即算法的分治思想），因为非终结符是可以层层定义的，因此是 “递归”，如下图。</p></li><li><p>用 “前看符号”（即不知道匹配哪一个，就去目标句子 s 中看一眼，给一个提示）指导当前产生式规则的选择。</p><p></p></li></ul><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170448660.png" alt=""></p><p>递归下降分析算法的特点是</p><ul><li>线性时间复杂度，运行高效</li><li>容易实现，适合手工编码。错误定位准确。使用者有 GCC LLVM</li></ul><h3 id="ll1-分析算法"><a class="anchor" href="#ll1-分析算法">#</a> LL (1) 分析算法</h3><p>递归下降分析算法适合于手工编码，而 LL (1) 分析算法适用于语法分析的自动生成。所谓 “LL (1)”，是指：从左（L）向右读入程序，最左（L）推导，采用 1 个前看符号。分析高效，也是线性时间复杂度。</p><p>其基本思想是 —— 表驱动的算法，如下图。第一列都是非终结符，第一行都是终结符，行列交叉点表示对应的产生式序号。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170520036.png" alt=""></p><p>回顾之前讲过的自顶向下分析算法，最大的问题就在于去盲目推导，盲目匹配出句子，然后再去和目标句子 s 做对比，对比出错就要回溯，时间复杂度非常高。因此，就需要在推导过程中就需要做分析预测，就可以从参考这个分析表。从分析表中，通过预测输入能得到产生式的序号，就知道接下来要匹配哪个产生式了，就不需要回溯了。</p><h3 id="lr-分析算法"><a class="anchor" href="#lr-分析算法">#</a> LR 分析算法</h3><p>上文主要将自顶向下的分析算法，而 LR 分析算法是自底向上的思路，但是输入、输出都是一样的。我没有看这部分，想详细了解的可以自己去看视频。</p><h3 id="抽象语法树-ast"><a class="anchor" href="#抽象语法树-ast">#</a> 抽象语法树 AST</h3><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170628092.png" alt=""></p><p>如上图，先看下抽象语法树 AST 和高级语言如何对应，根据代码对比一下，应该不难理解。其中，if 的最左侧节点是判断条件，中间节点是成功分支，右侧节点是 else 分支。</p><p>再来回顾一下上文讲的 CFG 的分析树（上文有示意图），它详细编码了句子的推导过程，并且包含了很多无关信息（非终结符），会占用很多存储空间，会增加算法的空间和时间复杂度。如果能把这些 “无关信息” 给去掉，只留下运算符，数字，标识符等和程序相关的信息，就构成了抽象语法树 AST ，如下图。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170648389.png" alt=""></p><p>既然是一棵树，那么就是一个标准的数据结构，各个类型的节点的数据结构，也就可以固定了。如下图</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170704479.png" alt=""></p><p>AST 是编译器中非常重要的数据结构，因为它是编译器前端和后端的接口形式。后续的过程仅仅依赖于 AST ，不会再依赖于前面的源码或者字符集。因此，一旦生成了 AST ，前面的源码就会被丢弃。因此，AST 中要有很详细的信息，不仅仅是本课程中讲的这个简单的树。例如，AST 要存储当前程序的文件、行、列，这样在语法报错时才能准确的给出具体的错误位置。</p><hr><h2 id="语义分析"><a class="anchor" href="#语义分析">#</a> 语义分析</h2><p>语法分析输出 AST ，然后对 AST 进行语义分析（有些教材也会叫做 “类型检查” 或者 “上下文相关分析” 等名字）。注意，程序如果能通过了语义分析这个阶段，那再往后就不应该出现任何语法错误，除非是编译器自己的 bug 。</p><h3 id="主要任务"><a class="anchor" href="#主要任务">#</a> 主要任务</h3><p>上文中的语法分析用到的是 CFG 即上下文无关的语法，即不依赖于上下文。例如 C 语言中 <code>printf(n);</code> 不符合语法，而 <code>print(&quot;%d&quot;, n);</code> 就符合语法，但是其中的 <code>n</code> 变量是否在上文已经定义了，语法分析是不知道的。</p><p>因此，语义分析是在 AST 基础上，结合上下文来分析：</p><ul><li>变量在使用前先进行声明</li><li>每个表达式都有合适的类型</li><li>函数调用和函数定义一致</li><li>等等 ……（每种语言的要求不一样）</li></ul><h3 id="语义规则和实现"><a class="anchor" href="#语义规则和实现">#</a> 语义规则和实现</h3><p>例如表达式的类型检查，定义一个类型检查函数，传入 AST 的某个表达式的节点，然后判断最后返回的类型。如果类型检查错误，就报错。如下图。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170727674.png" alt=""></p><h3 id="符号表"><a class="anchor" href="#符号表">#</a> 符号表</h3><p>上下文相关分析，就涉及到上下文信息的记录和读取，这些信息就被记录到符号表中，一个非常核心的数据结构。符号表用来存储程序中的变量相关信息（表的信息要足够丰富）：</p><ul><li>类型</li><li>作用域</li><li>访问控制信息（例如 <code>privte</code> <code>protected</code> 等）</li><li>……</li></ul><p>其数据结构最简单的可以使用一个 <code>key-val</code> 的字典来实现，例如 <code>&#123; key1: &#123;…&#125;, key2: &#123;…&#125;, key3: &#123;…&#125; &#125;</code> 。但是编译器要处理的程序规模可能非常庞大，因此这个数据结构必须要合理规划。在实际工程中，高效的查询方式可以有一下选择：</p><ul><li>选择一：为了高效，使用哈希表来实现符号表，查找是 <code>O(1)</code> 的时间复杂度</li><li>选择二：为了节约空间，可以使用红黑树等平衡树，查找是 <code>O(logN)</code> 的时间复杂度</li></ul><p>变量都有 “作用域” 的概念，不同作用域可以有相同的变量名。符号表处理作用域的方式：</p><ul><li><p>第一，进入作用域时插入元素，退出作用域时删除元素</p></li><li><p>第二，采用栈：进入作用域时插入新的符号表（push），退出作用域时删除栈顶符号表（pop），如下图。 （栈的实现方式很很多种，例如链表）</p><p></p></li></ul><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170745226.png" alt=""></p><hr><h2 id="代码生成"><a class="anchor" href="#代码生成">#</a> 代码生成</h2><p>经过语义分析的 AST ，即可用来做代码生成，即生成最终的机器（物理机或者虚拟机）代码。注意，这里直接从 AST 到目标代码，是一种最简单的编译器模型，暂时忽略了优化的部分。优化过程下文会详细解说。</p><h3 id="主要工作"><a class="anchor" href="#主要工作">#</a> 主要工作</h3><p>代码生成是把源程序翻译成 “目标机器”（可能是真实的机器，也可能是虚拟机）上的代码，而且要保证和源程序的 “等价性”（重要！！！）。主要的任务是：</p><ul><li>给源程序的数据（全局变量，局部变量等）分配计算资源（寄存器、数据区、代码区、栈区、堆区）</li><li>给源程序的代码（运算 语句 函数）选择指令（算数运算 逻辑运算 跳转 函数调用等）</li><li>（而且要考虑空间和时间的效率，在满足等价性的前提下）</li></ul><p>接下来通过两个示例来看代码生成的过程：</p><ul><li>栈计算机 Stack —— 代表了虚拟机，例如 JVM</li><li>寄存器计算机 Reg —— 代表了 RISC 精简指令集，如 ARM 芯片</li></ul><h3 id="stack-栈计算机代码生成技术"><a class="anchor" href="#stack-栈计算机代码生成技术">#</a> Stack 栈计算机代码生成技术</h3><p>70 年代有栈计算机的物理机，但是今天已经退出了历史舞台，因为执行效率太低。但是这里还要研究 Stack ，一来是因为在 Stack 上代码生成比较简单，二来是很多虚拟机是这样设计的，例如 JVM 。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170805003.png" alt=""></p><p>上图就是一个 Stack 的原型图，简单解释一下图中各个部分。</p><ul><li>内存，存放程序变量<ul><li>给变量 <code>x</code> 分配内存空间的伪指令： <code>.int x</code> （伪指令，不会被 ALU 执行）</li></ul></li><li>stack ，进行计算的空间（计算的输入、计算的中间结果和最终结果）</li><li>ALU ，计算单元 。指令集是：<ul><li><code>push NUM</code> ，把一个立即数压栈</li><li><code>load x</code> ，得到内存中的变量 <code>x</code> 的值，并压栈</li><li><code>store x</code> ，把栈顶元素弹出，并赋值给 <code>x</code></li><li><code>add</code> ，加法，pop 赋值给 <code>x</code> ，再 pop 赋值给 <code>y</code> ，然后 push <code>x+y</code></li><li><code>sub</code> ，减法，同上</li><li><code>times</code> ，乘法，同上</li><li><code>div</code> ，除法，同上</li></ul></li></ul><p>PS：以上这几条指令，就是 java 字节码的一个子集。真实的 java 字节码有 200+ 个。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170830490.png" alt=""></p><p>上图就是高级语言到最终的 Stack 计算机机器语言的对应，展示了最终的输入和输出。至于代码生成如何实现，在文章一开始的 “Sum 语言 + Stack” 的例子中这部分已经写的比较详细，就不再赘述了，翻看上文吧。</p><h3 id="reg-寄存器计算机的代码生成技术"><a class="anchor" href="#reg-寄存器计算机的代码生成技术">#</a> REG 寄存器计算机的代码生成技术</h3><p>这种机器类型是基于寄存器架构，所有操作都在寄存器完成，执行效率非常高（因为寄存器访问速度是内存访问速度的百倍），访存都通过 <code>load</code> 或 <code>store</code> 指令（RISC 指令集特点）。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170858118.png" alt=""></p><p>上图就是寄存器计算机的原型图，解释一下图中各个部分。</p><ul><li><p>内存：存放 “溢出” 的变量（寄存器中放不开的变量，如果假设寄存器有无限多个的话，就不用考虑 “溢出” 了）</p></li><li><p>寄存器：进行计算的空间，有 r1 r2 ... rn 无限个寄存器（假定无限个，实际上寄存器个数是有限的）</p><ul><li>给变量 <code>x</code> 分配寄存器的伪指令 <code>.int x</code> （伪指令不会被 ALU 执行）</li></ul></li><li><p>ALU 计算单元。指令集：</p><ul><li><code>movn n, r1</code> 把立即数 n 存入寄存器 r1</li><li><code>mov r1, r2</code> 把 r1 的值赋值给 r2</li><li><code>load [x], r1</code> 将 x 地址的值取出，放在 r1 。其中 x 是指针，[x] 即取出指针对应内存的值。</li><li><code>store r1, [x]</code> 将 r1 的值赋值给 x 内存地址</li><li><code>add r1, r2, r3</code> 加法，表示 r3 = r1 + r2</li><li><code>sub r1, r2, r3</code> 减法，同理</li><li><code>times r1, r2, r3</code> 乘法，同理</li><li><code>div r1, r2, r3</code> 除法，同理</li></ul><p></p></li></ul><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170928307.png" alt=""></p><p>上图就是高级语言和目标代码的对应关系。图中有对应的 AST ，对这棵树进行后续遍历（先左、再右、最后根），每遍历一个节点都会对应到右侧的一行指令。</p><ul><li>“1” 节点会对应第一行指令</li><li>“2” 节点会对应第二行指令</li><li>“+” 节点会对应第三行指令</li><li>“3” 节点会对应第四行指令</li><li>……</li></ul><p>最后，实际的物理机器上不可能有无限多的寄存器，因此要确定哪些变量被用于寄存器？哪些变量被 “溢出” 放在内存？—— 这个问题是另外一个编译器的重要部分：编译器分配。如何进行编译器分配，这个问题会在下文介绍。</p><hr><h2 id="中间表示"><a class="anchor" href="#中间表示">#</a> 中间表示</h2><p>中间表示是一个统称，有很多种表示形式，AST 就是其中之一。上文提到，从 AST 直接生成目标代码是比较原始的编译技术，现代编译器中往往会在编译器的 “后端” 进行各种各样的代码优化，不同的优化形式就需要不同的表示形式。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170944117.png" alt=""></p><p>常见的中间代码形式：</p><ul><li>树和有向无环图：高层表示，适用于程序源代码</li><li>三地址码：低层表示，靠近目标机器</li><li>控制流图：更精细的三地址码，程序的图状表示</li><li>静态单赋值形式 SSA ：更精细的控制流图</li><li>连续传递风格：更一般的 SSA （函数式语言中用的比较多）</li><li>还有很多。。。</li></ul><h3 id="三地址码"><a class="anchor" href="#三地址码">#</a> 三地址码</h3><p>所谓 “三地址码”，即一个指令有一个运算符，最多有三个操作数。这样就使得每一条指令都比较简单，易于和机器语言对应。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170958183.png" alt=""></p><p>上图就是一个高级语言和三地址码的对应关系（虽然三地址码是通过 AST 生成的，已经和源代码没有关系）。从图中可以看出三地址码的特点：</p><ul><li>给每个中间变量和计算结果命名，即没有符合表达式。例如将 <code>a = 3 + 4 * 5</code> 拆解成一个一个的中间变量</li><li>只有最基本的控制流，即没有各种控制结构，只有 <code>goto</code> 和 <code>call</code> 。例如将 <code>if else</code> 改为 <code>Cjmp</code> （条件跳转指令）</li></ul><h3 id="控制流图"><a class="anchor" href="#控制流图">#</a> 控制流图</h3><p>三地址码是一种线性的表示方式，这就没法通过它来分析和确定流程。例如上图中，哪些指令会跳转到 <code>L_1</code> 和 <code>L_2</code> ？并不好确定。控制流图是一种更加精细的三地址码（本质上还是三地址码），将程序中的各个控制流块都表示了出来，如下图。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171022430.png" alt=""></p><p>控制流图就是一个有向图 <code>G = (V, E)</code> ，其中节点 <code>V</code> 表示程序的基本块，边 <code>E</code> 表示基本块之间的跳转关系。生成控制流图的目的有很多，但都是为了做代码优化，例如：</p><ul><li>做控制流分析，例如程序中有没有循环？</li><li>做数据流分析，例如程序中某行的变量 <code>x</code> 可能的值是什么？</li></ul><h3 id="数据流分析"><a class="anchor" href="#数据流分析">#</a> 数据流分析</h3><p>所谓 “数据流分析”，就是通过静态的观察程序（并不执行）来判断其中的变量和数据的一些变化，例如某程序第五行的 x 变量的值会有几种可能？</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171035215.png" alt=""></p><p>如上图，通过控制流图，既可以判断一个变量 <code>y</code> 的赋值可能性。如果 <code>y</code> 能编译器识别为一个固定的值，直接 <code>a = 3</code> 并且把一开始的 <code>y = 3</code> 删掉。这就是一个优化过程。</p><p>但是这仅仅是静态的分析，程序并未执行，因此如果 <code>y</code> 在一个逻辑分支中出现，就不好预估其准确结果，但是至少能预估一个结果集（称为 “保守信息”）。如果能将这个结果集做到最小，和执行的结果越接近，就越好优化。这仍然是编译器现在的一个热门话题。</p><p>类似数据流分析的还有 “到达定义分析”，即分析一个变量是如何一步一步的被定义和使用的，原理和目的基本一致，这里不再赘述。</p><h3 id="活性分析"><a class="anchor" href="#活性分析">#</a> 活性分析</h3><p>上文中提到 REG 机器假设有无限个寄存器，但实际情况不是。因此需要寄存器分配 —— 即用到活性分析。所谓 “活性分析”，即分析变量的活跃区间（可以理解为声明周期）然后来做寄存器的分配。</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171049617.png" alt=""></p><p>如上图，三个变量，只有一个寄存器，该如何分配？答案是：计算出每个变量的活跃区间，即可共享寄存器。寄存器分配，就依赖于变量的活动区间数据。如下图：</p><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171101780.png" alt=""></p><hr><h2 id="代码优化"><a class="anchor" href="#代码优化">#</a> 代码优化</h2><p>现代生产环境下的编译器，代码优化是其重要工作之一，而且一直在不断的持续优化中。</p><h3 id="几点说明"><a class="anchor" href="#几点说明">#</a> 几点说明</h3><p>代码优化的目的是让目标程序更精简、更快速、更节省空间、更节能（所谓的多快好省），当然在不改变语义的前提下 —— 这些应该都比较好理解。但是还有几点关于优化的需要重点说明一下。</p><ul><li>没有完美的优化，即 “没有最好只有更好”。因为编译器本来就是一个庞大复杂的工程，优化过程复杂度很高，不确定性很大。</li><li>优化必须要在语义分析完成之后再进行，即确保源程序没有任何语法和语义的问题。因为优化可能会删改代码，如果优化之后再报错，错误信息就不准确了。</li><li>优化并不是一个单独的阶段（如词法分析、语法分析等），而是在各个阶段都可能进行。可以对 AST 进行优化，也可以对各种中间表示进行优化，还可以对目标代码再继续优化，每一步的优化针对想都不一样。</li><li>一般针对一个数据优化之后不会产生新的格式（但会产生新的数据，即函数式编程的思维），优化不是翻译过程。</li></ul><p></p><p><img data-src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171118467.png" alt=""></p><h3 id="前端优化"><a class="anchor" href="#前端优化">#</a> 前端优化</h3><p>即对 AST 进行优化，下面列举几个例子来说明。</p><p>第一，常量折叠。静态计算，可以在数字类型和 bool 类型进行优化，例如：</p><ul><li><code>a = 3 + 5</code> 变为 <code>a = 8</code> （少了一步 <code>+</code> 计算，就相当于帮 AST 节省了一个分支）</li><li><code>if (true &amp;&amp; false)</code> 变为 <code>if (false)</code> 。而且， <code>if (else)</code> 还可以进行 “不可达代码” 优化（见下文）</li></ul><p>第二，代数化简。利用代数的恒等式，进行优化，例如：</p><ul><li><code>a = 0 + b</code> 变为 <code>a = b</code> （少一个运算符，简化 AST）</li><li><code>a = 1 * b</code> 变为 <code>a = b</code> （少一个运算符，简化 AST）</li><li><code>2 * a</code> 变为 <code>a + a</code> （因为乘法运算复杂度高）</li><li><code>2 * a</code> 变为 <code>a &lt;&lt; 1</code> （位运算效率最高）</li></ul><p>第三，死代码（不可达）代码优化，例如</p><ul><li><code>if (false)</code> 不会被执行，测试环境的 debug 代码，到了线上环境就会是死代码</li><li>函数的 <code>return</code> 之后的语句，不会被执行</li></ul><h3 id="中间表示上的优化"><a class="anchor" href="#中间表示上的优化">#</a> 中间表示上的优化</h3><p>如常量传播、拷贝传播，在上文讲数据流分析的时候已经写过，不再赘述。</p><hr><h2 id="总结"><a class="anchor" href="#总结">#</a> 总结</h2><p>编译器真的是一个非常非常非常复杂的工具，其中涉及到的知识点包括数学理论、计算机组成原理、算法和数据结构。如果真的想要深入了解一门语言，那就到它的编译器中去看看吧。</p><div class="tags"><a href="/tags/%E7%BC%96%E8%AF%91/" rel="tag"><i class="ic i-tag"></i> 编译</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-06-30 20:01:16" itemprop="dateModified" datetime="2023-06-30T20:01:16+08:00">2023-06-30</time> </span><span id="2023/06/30/computer-science/编译原理/" class="item leancloud_visitors" data-flag-title="编译原理" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Caleb <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://hdqjl317.github.io/2023/06/30/computer-science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理">https://hdqjl317.github.io/2023/06/30/computer-science/编译原理/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="prev" data-background-image="&#x2F;assets&#x2F;yclj.jpg" title="vscode通过密钥连接远程服务器"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 工作技能</span><h3>vscode通过密钥连接远程服务器</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">什么是编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%9C%B0%E4%BD%8D"><span class="toc-number">1.1.</span> <span class="toc-text">在程序运行中的地位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">内部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.3.</span> <span class="toc-text">一个简单的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">2.1.</span> <span class="toc-text">一个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E6%89%8B%E5%B7%A5%E6%9E%84%E9%80%A0%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">词法分析的手工构造法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF"><span class="toc-number">2.3.</span> <span class="toc-text">词法分析的自动生成技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA-fa"><span class="toc-number">2.3.2.</span> <span class="toc-text">有限状态自动机 FA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-re-%E5%88%B0%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA-fa"><span class="toc-number">2.3.3.</span> <span class="toc-text">从正则表达式 RE 到有限状态自动机 FA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE-dfa-%E7%94%9F%E6%88%90%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E4%BB%A3%E7%A0%81"><span class="toc-number">2.3.4.</span> <span class="toc-text">根据 DFA 生成词法分析代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95-cfg"><span class="toc-number">3.1.</span> <span class="toc-text">上下文无关文法 CFG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%A0%91%E5%92%8C%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">3.2.</span> <span class="toc-text">分析树和二义性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">自顶向下分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">递归下降分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ll1-%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">LL (1) 分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lr-%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text">LR 分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91-ast"><span class="toc-number">3.7.</span> <span class="toc-text">抽象语法树 AST</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">语义分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.1.</span> <span class="toc-text">主要任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E8%A7%84%E5%88%99%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">语义规则和实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-number">4.3.</span> <span class="toc-text">符号表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">5.</span> <span class="toc-text">代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%B7%A5%E4%BD%9C"><span class="toc-number">5.1.</span> <span class="toc-text">主要工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack-%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF"><span class="toc-number">5.2.</span> <span class="toc-text">Stack 栈计算机代码生成技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reg-%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF"><span class="toc-number">5.3.</span> <span class="toc-text">REG 寄存器计算机的代码生成技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.</span> <span class="toc-text">中间表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%9C%B0%E5%9D%80%E7%A0%81"><span class="toc-number">6.1.</span> <span class="toc-text">三地址码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE"><span class="toc-number">6.2.</span> <span class="toc-text">控制流图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-number">6.3.</span> <span class="toc-text">数据流分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">6.4.</span> <span class="toc-text">活性分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">代码优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">7.1.</span> <span class="toc-text">几点说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">前端优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA%E4%B8%8A%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">7.3.</span> <span class="toc-text">中间表示上的优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2023/06/30/computer-science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="bookmark" title="编译原理">编译原理</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Caleb" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Caleb</p><div class="description" itemprop="description">欢迎来到 Caleb 的个人博客!</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">6</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">4</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">4</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hEcWpsMzE3" title="https:&#x2F;&#x2F;github.com&#x2F;HDqjl317"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmppYWxlX3F1YW5AdXN0Yy5lZHU=" title="mailto:jiale_quan@ustc.edu"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/other/" title="分类于 杂谈">杂谈</a></div><span><a href="/2022/07/01/other/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a></div><span><a href="/2023/06/30/computer-science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理">编译原理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/codelanguage/" title="分类于 编程语言">编程语言</a></div><span><a href="/2022/08/04/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%872/" title="cpp11新特性篇2">cpp11新特性篇2</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/codelanguage/" title="分类于 编程语言">编程语言</a></div><span><a href="/2022/08/10/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%873/" title="cpp11新特性篇3">cpp11新特性篇3</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/codelanguage/" title="分类于 编程语言">编程语言</a></div><span><a href="/2022/08/01/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%871/" title="cpp11新特性篇1">cpp11新特性篇1</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/worktech/" title="分类于 工作技能">工作技能</a></div><span><a href="/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="vscode通过密钥连接远程服务器">vscode通过密钥连接远程服务器</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Caleb @ Caleb</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">21k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">19 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/06/30/computer-science/编译原理/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>