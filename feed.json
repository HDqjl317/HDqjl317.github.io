{
    "version": "https://jsonfeed.org/version/1",
    "title": null,
    "subtitle": "加楽的小站",
    "icon": "https://hdqjl317.github.io/images/favicon.ico",
    "description": "欢迎来到 Caleb 的个人博客!",
    "home_page_url": "https://HDqjl317.github.io",
    "items": [
        {
            "id": "https://hdqjl317.github.io/2023/06/30/computer-science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/",
            "url": "https://hdqjl317.github.io/2023/06/30/computer-science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/",
            "title": "编译原理",
            "date_published": "2023-06-30T08:50:54.000Z",
            "content_html": "<h2 id=\"什么是编译器\"><a class=\"anchor\" href=\"#什么是编译器\">#</a> 什么是编译器</h2>\n<p>所谓编译原理，也就是编译器的工作原理，因此先要明白什么是编译器。编译器的基本定义是：将一门语言转换为另一门语言，一般指将高级语言转换为机器语言，但仅仅是转换并不执行。编译器最基本的底线，就是保证源代码和目标代码的语义相同。</p>\n<h3 id=\"在程序运行中的地位\"><a class=\"anchor\" href=\"#在程序运行中的地位\">#</a> 在程序运行中的地位</h3>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165538192.png\" alt=\"\" /></p>\n<p>如上图。编译器就是将源代码转换（即翻译）为目标程序，然后再交给机器去执行，这个应该很好理解。之所以要转换，是因为计算机本质上只能识别机器代码，不能识别高级语言 。简单解释一下这张图的各个部分。</p>\n<ul>\n<li>“源代码” 是 C java 等高级语言，每种程序对应的编译器可能都不一样</li>\n<li>“静态计算” 是指编译器只根据程序文本静态的分析（如做报错分析、优化分析），而不是真的拿 CPU 去执行</li>\n<li>生成的 “目标程序” 可能是 x86 汇编（如对应 C 语言），也可能是 bytecode 字节码（如对应 java）</li>\n<li>“计算机” 可能是一个 x86 的物理器（如对应 C 语言），也可能是 JVM java 虚拟机（如对应 java）。即不一定是一个真实的机器，可能是虚拟机，但这里都统称为 “计算机”</li>\n</ul>\n<p>另外再解释一下编译器和另外一个常见的叫做 “解释器” 的对比。两者有很多共同点，但是有以下区别：</p>\n<ul>\n<li>编译器：输入源代码，输出的一个可执行程序，但不去执行（存放在磁盘上等待被加载到内存中执行）</li>\n<li>解释器：输入源代码，直接输出执行结果。其实 JVM 就是一个解释器，而不是一个单纯的编译器。输入 java 字节码 bytecode ，然后直接输出执行结果，而不是输出汇编代码。</li>\n</ul>\n<h3 id=\"内部结构\"><a class=\"anchor\" href=\"#内部结构\">#</a> 内部结构</h3>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165616680.png\" alt=\"\" /></p>\n<p>如上图，就是一个编译器最简单的内部结构（没有考虑代码优化过程）。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165702453.png\" alt=\"\" /></p>\n<p>如上图，这是一个更加复杂的编译器，各个过程都比较完备。其实拆开来看，编译器是一个 “流水线”，由一个一个的小程序分流水线执行。因为编译器规模庞大复杂，拆分模块容易实现和维护。</p>\n<p>编译器通常会被划分为两个部分（如下图）：</p>\n<ul>\n<li>\n<p>前端：源代码生成中间代码，和源代码有关</p>\n</li>\n<li>\n<p>后端：中间代码生成目标代码并优化，和目标代码有关</p>\n</li>\n<li>\n<p>两者以抽象语法树 AST 作为连接数据</p>\n<p></p>\n</li>\n</ul>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165702453.png\" alt=\"\" /></p>\n<h3 id=\"一个简单的例子\"><a class=\"anchor\" href=\"#一个简单的例子\">#</a> 一个简单的例子</h3>\n<p>背景一，现在我们设计一个叫做 Sum 的语言，特别简单，仅仅支持两种语法。第一是整形数字  <code>n</code>  ，第二是加法表达式  <code>e1 + e2</code>  。举几个例子：</p>\n<ul>\n<li><code>3</code></li>\n<li><code>5 + 6</code></li>\n<li><code>7 + 8 + 9</code>  （加法要满足左结合性，即先计算  <code>7 + 8</code> ）</li>\n<li><code>7 + (8 + 9)</code></li>\n<li>但不支持  <code>7 + 8 * 9</code>  Sum 语言中没有乘法</li>\n</ul>\n<p>背景二，有一个栈试计算机 Stack （后面会再次讲到），其中有一个操作数栈，然后只支持两条指令  <code>push n</code>  和  <code>add</code>  。之所以选择栈式计算机，第一是因为简单，第二是因为 JVM 就是采用了这种形式。其指令的详情是：</p>\n<ul>\n<li><code>push 3</code>  将 3 压栈</li>\n<li><code>push 4</code>  将 4 压栈</li>\n<li><code>add</code>  将 3 和 4 出栈，然后做加法得到 7 ，再将 7 压栈。即将栈顶的两个元素都出栈，做加分，将结果再压栈</li>\n</ul>\n<p>有了上述两个背景之后，接下来的任务是：编译程序  <code>1 + 2 + 3</code>  到栈式计算机 Stack 。</p>\n<p>第一个阶段进行词法分析，先不管其中的原理是什么，总之词法分析会将  <code>1 + 2 + 3</code>  拆分为  <code>1</code>   <code>+</code>   <code>2</code>   <code>+</code>   <code>3</code>  这 5 个部分。<br />\n第二阶段是语法分析，就是将词法分析拆分出来的内容，分析是否满足 Sum 语言的语法要求，即  <code>e1 + e2</code>  这种语法。<br />\n第三个阶段是语法树构造，经过某些计算之后，得到的抽象语法树如下图。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165829650.png\" alt=\"\" /></p>\n<p>第四个阶段，根据抽象语法树做代码生成。首先，要满足加法的左结合性，对树进行遍历的时候就要优先遍历左子树，即<strong>后序遍历</strong>。在遍历树节点的过程中，如果遇到整数  <code>n</code>  就生成一条  <code>push n</code>  指令，如果遇到  <code>+</code>  就生成一条  <code>add</code>  指令。接下来详细看一下这棵树的遍历过程：</p>\n<ul>\n<li>第一步要访问的节点是  <code>1</code>  ，生成  <code>push 1</code>  ，将 1 压栈</li>\n<li>第二步要访问的节点是  <code>2</code>  ，生成  <code>push 2</code>  ，将 2 压栈</li>\n<li>第三步要访问的节点是  <code>+</code>  ，生成  <code>add</code>  ，将 1 2 出栈，计算加法得到 3 ，将 3 压栈 （这里即体现了加法的左结合性）</li>\n<li>第四步要访问的节点是  <code>3</code>  ，生成  <code>push 3</code>  ，将 3 压栈</li>\n<li>第五步要访问的节点是  <code>+</code>  ，生成  <code>add</code>  ，将 3 3 出栈，计算加法得到 6 ，将 6 压栈，完成</li>\n</ul>\n<hr />\n<h2 id=\"词法分析\"><a class=\"anchor\" href=\"#词法分析\">#</a> 词法分析</h2>\n<p>从编译器内部结构得知，执行编译的第一个阶段就是词法分析。<strong>输入是源程序代码，输出一个记号（即 token）流或者单词流</strong>。通俗来说，就是将源代码进行最细粒度的拆解，例如上面的例子将  <code>1 + 2 + 3</code>  拆分为  <code>1</code>   <code>+</code>   <code>2</code>   <code>+</code>   <code>3</code>  一样。</p>\n<h3 id=\"一个例子\"><a class=\"anchor\" href=\"#一个例子\">#</a> 一个例子</h3>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165938490.png\" alt=\"\" /></p>\n<p>如上图。从源代码到记号流（或单词流），记号就是 token 。词法分析器会将源程序根据关键字、标识符（变量）、括号、引号、运算符、值（整数、字符串）等这些要素，将其从左到右拆分为若干个记号（或者单词），其中会忽略空格和换行等。上图中：</p>\n<ul>\n<li><code>IF</code>  关键字</li>\n<li><code>LPAREN</code>   <code>RPAREN</code>  左右括号</li>\n<li><code>INDENT(x)</code>  即标识符（变量），有一个属性  <code>x</code>  ，表示变量名</li>\n<li><code>GR</code>  即  <code>&gt;</code></li>\n<li><code>INT(t)</code>  即  <code>int</code>  类型值，属性是  <code>5</code></li>\n<li>其他同理……</li>\n<li>最后红色的  <code>EOF</code>  是结束符</li>\n</ul>\n<p>根据上面的例子，可以总结出 token 其实有固定的形式，就可以定义其数据结构，如下图（本文中高级语言的示例，默认情况下都是 C 语言）</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170050889.png\" alt=\"\" /></p>\n<p>理解了例子，定义了数据，接下来就要去探寻词法分析的实现算法，第一，手工构造；第二，自动生成 。</p>\n<h3 id=\"词法分析的手工构造法\"><a class=\"anchor\" href=\"#词法分析的手工构造法\">#</a> 词法分析的手工构造法</h3>\n<p>手工构造即手写一个词法分析器，例如 GCC LLVM ，优点是利于掌控和优化细节，缺点是工作量大、易出错。手工构造法主要用到 “转移图” 这种数据结构，下面举两个例子说明。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170106446.png\" alt=\"\" /></p>\n<p>上图的转移图模型，即可识别逻辑运算符，如  <code>&lt;=</code>   <code>&lt;</code>   <code>&lt;&gt;</code>   <code>&gt;=</code>   <code>&gt;</code>  。识别到第一个字符，就继续往下做分支判断，直到返回一个确定的运算符。图中的  <code>*</code>  即一次回溯，即将当前的这个字符再返回到词法分析器重新进行分析。例如  <code>&gt;1</code>  ，读到了  <code>1</code>  这个字符时，此时已经确定了运算符是  <code>&gt;</code>  ，而当前的  <code>1</code>  并不是运算符的一部分，因此将  <code>1</code>  再重新返回到词法分析器中重新进行分析。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170142816.png\" alt=\"\" /></p>\n<p>上图是标识符（变量）的转移图模型，以及伪代码。其中  <code>*</code>  即一次回溯，跟上面一样。</p>\n<p>关键字（如  <code>class</code>   <code>if</code>   <code>for</code>  等）是一种特殊的标识符，也满足标识符的规则。要识别关键字，有两种解决方案：</p>\n<ul>\n<li>继续扩展转移图的分支，识别到关键字走不通的分支逻辑，最后识别出关键字。</li>\n<li>先识别所有的合法标识符，然后从已经识别出来的标识符中查找关键字。此时需要为该语言所有的关键字维护一个哈希表，如果数据结构合理（完美哈希），查询可以在  <code>O(1)</code>  复杂度内完成。</li>\n</ul>\n<h3 id=\"词法分析的自动生成技术\"><a class=\"anchor\" href=\"#词法分析的自动生成技术\">#</a> 词法分析的自动生成技术</h3>\n<p>所谓自动生成技术，就是有这样现成的工具（如 lex flex jlex），输入一些声明式的规范，即可自动生成一个词法分析器。有点当然是简单快速，缺点就是无法控制细节。而这里的 “声明式规范”，就是我们常见的正则表达式。下文的内容，就是如何用程序去解析正则表达式，如果你之前看过关于 “正则表达式 原理” 这类的文章，可能早就有了解了。</p>\n<p>先说一下自动生成技术的几个阶段，专业术语后面都有解释：</p>\n<ul>\n<li>正则表达式 -&gt; NFA</li>\n<li>NFA -&gt; DFA</li>\n<li>DFA -&gt; 词法分析代码，即完成自动生成</li>\n</ul>\n<h4 id=\"正则表达式\"><a class=\"anchor\" href=\"#正则表达式\">#</a> 正则表达式</h4>\n<p>不要以为用过正则表达式就觉得它很简单了，如果你是通过看 “30 分钟入门正则表达式” 这类文章开始接触的，还是建议你仔细阅读这里关于正则表达式的解释。笔者也是看了这门课才对正则表达式有了新的认识。</p>\n<p>正则表达式是一种数学上的概念，首先它要有一个完整的字符集  <code>Σ = &#123;...&#125;</code>  要能涵盖程序所有的关键字、变量名、数字、运算符、括号、引号、特殊符号等</p>\n<ul>\n<li>如 C 语言的这个字符集就是 ASC 编码，即 256 个字符</li>\n<li>如 java 的字符集就是 unicode 编码，可能几万甚至十几万个字符集（因为 java 的变量名称并不仅限于英文、中文也可以作为变量）</li>\n</ul>\n<p>然后只有以下几个基本的逻辑：</p>\n<ul>\n<li>空串是正则表达式</li>\n<li>单个字符是正则表达式</li>\n<li><code>a|b</code>  是正则表达式，两者取并集</li>\n<li><code>ab</code>  是正则表达式，两者相连</li>\n<li><code>a*</code>  成为 “闭包”（和程序的闭包不一样），即可以有 0 或者若干个  <code>a</code></li>\n<li>以上随机组合，都是正则表达式，例如  <code>a|(bc*)</code></li>\n</ul>\n<p>这就是正则表达式的定义，而现代正则表达式这么多的语法，例如  <code>[a-b]</code>   <code>?</code>   <code>+</code>  等，都是后来扩展出的语法糖，即对基本规则的一种简写方式。</p>\n<h4 id=\"有限状态自动机-fa\"><a class=\"anchor\" href=\"#有限状态自动机-fa\">#</a> 有限状态自动机 FA</h4>\n<p>也称 “有穷自动机”，是一种数学模型。简单理解，就是输入一个字符串，输出这个字符串是否满足某个规则（true /false）。例如有  <code>a + b</code>  这样一个规则，输入 <code>“1 + 2 ”</code>  就满足，输  <code>“abc”</code>  这就不满足。其实现原理，就是先设定几个状态，然后根据输入的字符做状态转移，看最后能否转移到最终的状态。如下图，输入  <code>abbaabb</code>  ，初始状态是  <code>0</code>  ，然后分别输入一个一个的字符，看最后能否将状态转移到  <code>3</code>  。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170207504.png\" alt=\"\" /></p>\n<p>有限状态自动机 FA 又分为两种：</p>\n<ul>\n<li>确定的有限状态自动机 DFA 。针对一个状态，输入一个字符，只能有一个出口。</li>\n<li>非确定的有限状态自动机 NFA 。针对一个状态，输入一个字符，可能会有多个出口。如上图中的  <code>0</code>  状态，输入  <code>a</code>  时有两个出口，所以它是 NFA 。</li>\n</ul>\n<p>看过 “正则表达式 原理” 类似文章的应该知道，其实每一个正则表达式，都能对应一个 FA ，因此接下来看一下正则表达式如何生成 FA 。</p>\n<h4 id=\"从正则表达式-re-到有限状态自动机-fa\"><a class=\"anchor\" href=\"#从正则表达式-re-到有限状态自动机-fa\">#</a> 从正则表达式 RE 到有限状态自动机 FA</h4>\n<p>先将正则表达式生成 NFA ，再将 NFA 生成 DFA 。这是因为：第一，RE 生成 NFA 比直接生成 DFA 更加简单；第二， NFA 做分析算法比较复杂，多个出口导致复杂度变高。因此，往往是将 NFA 转换为等价的 DFA ，然后再拿来做运算。</p>\n<p>从 RE 生成 NFA 课程中讲解了 Thompson 算法（Ken Thompson，unix 和 C 语言之父，1984 年图领奖）。具体内容我大体看明白了，不过太细节的也没必要记录了。其基本的逻辑是：</p>\n<ul>\n<li>对基本的 RE（空串、单个字符） 直接构造</li>\n<li>对复杂的 RE （或、连接、闭包）递归构造</li>\n</ul>\n<p>从 NFA 转换 DFA ，子集构造算法。所谓 “子集” 就是原来 NFA 的若干状态的集合，通过构造子集，来实现 DFA 。也就是说，此时构造出来的 DFA 就不单单是一个一个的状态节点了，而是一个一个的状态子集。</p>\n<p>另外，转换到了 DFA 之后，还要对 DFA 进行最小化的优化，课程中讲了 Hopcroft 算法。基本逻辑是，将生成的 DFA 的子集再进行合并，减少节点数量。状态节点越少，占用的空间复杂度越少，提高运算效率。</p>\n<h4 id=\"根据-dfa-生成词法分析代码\"><a class=\"anchor\" href=\"#根据-dfa-生成词法分析代码\">#</a> 根据 DFA 生成词法分析代码</h4>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170236807.png\" alt=\"\" /></p>\n<p>DFA 实质上是带有边和节点的有向图，如上图。图中第一列是状态，第一行是字符，例如：</p>\n<ul>\n<li>在状态  <code>0</code>  时，输入字符  <code>a</code>  ，行列交叉点是  <code>1</code>  ，表示可以转向状态  <code>1</code></li>\n<li>在状态  <code>1</code>  时，输入字符  <code>a</code>  ，行列交叉点是  <code>2</code>  ，表示可以转向状态  <code>2</code></li>\n<li>在状态  <code>1</code>  时，输入字符  <code>b</code>  ，行列交叉点是  <code>1</code>  ，表示可以转向状态  <code>1</code></li>\n</ul>\n<p>有了以上所有的逻辑，就可以判断一个字符串是否符合一个 RE 的规定，即可将字符串拆分为一个一个的 token 。这个方法叫做 “转移表法”，课程中还讲了 “哈希表” 和 “跳转表”，没有详细记录。</p>\n<hr />\n<h2 id=\"语法分析\"><a class=\"anchor\" href=\"#语法分析\">#</a> 语法分析</h2>\n<p>词法分析之后，输出了记号流，然后传递给语法分析，这里主要有两部分工作：</p>\n<ul>\n<li>输入一个程序语法的表示，判断是否符合程序的语法</li>\n<li>如果符合，就根据输入的符号集，生成抽象语法树 AST</li>\n</ul>\n<h3 id=\"上下文无关文法-cfg\"><a class=\"anchor\" href=\"#上下文无关文法-cfg\">#</a> 上下文无关文法 CFG</h3>\n<p>上文所说的 “程序语法的表示”，就是上下文无关文法 CFG ，是一个描述语言语法规则的标准的数学工具。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170303206.png\" alt=\"\" /></p>\n<p>上图的左侧就是一个 CFG 的简单示例，其中每一条叫做 “产生式”，图中的  <code>|</code>  即 “或” 的意思。简单解释一下这个 CFG 的意思：</p>\n<ul>\n<li>\n<p>“S -&gt; N V N” 就是一个句子，其实 S 是开始符号</p>\n</li>\n<li>\n<p>N 和 V 都是非终结符，即它可以继续再往下扩展拆分，就像 “S -&gt; N V N” 那样拆分</p>\n</li>\n<li>\n<p>t g e 等这些都是终结符，即已经表述一个具体的事情了，没法再往下拆分了</p>\n<p></p>\n</li>\n</ul>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170317523.png\" alt=\"\" /></p>\n<p>上图就用 CFG 描述了一个  <code>*</code>  和  <code>+</code>  表达式，\b其中  <code>num</code>  表示一个具体的数字，  <code>id</code>  表示标识符（变量），这俩都是终结符，\b <code>E</code>  是非终结符。</p>\n<p>从上面的例子来看，可以根据一个 CFG 推导出若干个句子，例如上图的 CFG 可以推导出  <code>id + num</code>  或者  <code>id * num</code>  或者  <code>(id + num) * num</code>  或者 ……</p>\n<p><strong>语法分析就是：给定一个文法 G 和句子 s ，要确定：是否能在 G 的推导结果中，找到 s ？（即，是否存在对句子的推导）</strong> 如果能推导出来，说明\b句子 s 符合文法 G 的语法，否则不符合。如下图：</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170406338.png\" alt=\"\" /></p>\n<p>推导方式一般有两种：</p>\n<ul>\n<li>最左推导：每次推导过程当中总是选择最左侧的符号进行替换</li>\n<li>最右推导：同理，选择最右侧</li>\n</ul>\n<h3 id=\"分析树和二义性\"><a class=\"anchor\" href=\"#分析树和二义性\">#</a> 分析树和二义性</h3>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170430263.png\" alt=\"\" /></p>\n<p>如上图，在文法的推导过程中，可以用树的形式来表示，即分析树。\b其中， 内部节点都是非终结符，叶子节点都是终结符，<strong>中序遍历</strong>即可得到最终的句子。PS：到这里，貌似已经看到了\b最终输出的抽象语法树 AST 的雏形了，其本质就是来源于 CFG 的格式。</p>\n<p>所谓 “二义性” 就是指文法的书写会产生一些歧义，例如上图中  <code>*</code>  和  <code>+</code>  表达式的文法，\b采用最左推导和最右推导得出的结果是不一样的，可能分别得出  <code>(3+4)*5</code>  和  <code>3+(4*5)</code>  ，显然计算结果不同。为了避免\b文法的二义性，只能是重写文法，将文法表述的更加详细一些，此处不做详解。</p>\n<h3 id=\"自顶向下分析算法\"><a class=\"anchor\" href=\"#自顶向下分析算法\">#</a> 自顶向下分析算法</h3>\n<p>上文已经明确了语法分析的\b定义，即看一个文法 G 是否存在对句子 s 的推导。自顶向下分析就是其中一个比较典型的算法，其基本逻辑是：</p>\n<ul>\n<li>即通过文法 G 随意推导出一个句子 t ，然后拿 t 和目标句子 s 进行对比</li>\n<li>如果 t == s ，则成功</li>\n<li>如果 t != s ，则回溯，从新计算一个 t1 ，再比较</li>\n</ul>\n<p>但是，上述过程比较笨重，因为一个 G 能推导出来的句子可能有非常多种，都拿来跟 s 做比较，会发生很多回溯，非常耗时。可以用以下方式进行优化：</p>\n<ul>\n<li>从左到右的推导顺序，可以最先得到句子 t 的左侧</li>\n<li>拿 t 最先得到的左侧，和 s 左侧进行对比</li>\n<li>对比成功，则继续从左到右推导（接下来的推导，也都是没推导出左侧就和 s 对应的左侧部分进行对比，看是否成功）</li>\n<li>对比不成功，则回溯重来</li>\n</ul>\n<p>但是，上述优化后的算法，还是可能会有回溯发生，这\b远远达不到编译器的性能要求。编译器要处理的程序动辄\b\b几十万行，必须要求线性时间复杂度的算法，一旦有回溯\b就会严重\b影响性能。</p>\n<h3 id=\"递归下降分析算法\"><a class=\"anchor\" href=\"#递归下降分析算法\">#</a> 递归下降分析算法</h3>\n<p>也称预测分析算法，其基本思路是：</p>\n<ul>\n<li>\n<p>每个非终结符构造一个分析函数（即将整个文法匹配整个句子的方式，拆解开，用单个非终结符去匹配句子中的字符，即算法的分治思想），因为非终结符是可以层层定义的，因此是 “递归”，如下图。</p>\n</li>\n<li>\n<p>用 “前看符号”（即不知道匹配哪一个，就去目标句子 s 中看一眼，给一个提示）指导当前产生式规则的选择。</p>\n<p></p>\n</li>\n</ul>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170448660.png\" alt=\"\" /></p>\n<p>递归下降分析算法的特点是</p>\n<ul>\n<li>线性时间复杂度，运行高效</li>\n<li>容易实现，适合手工编码。错误定位准确。使用者有 GCC LLVM</li>\n</ul>\n<h3 id=\"ll1-分析算法\"><a class=\"anchor\" href=\"#ll1-分析算法\">#</a> LL (1) 分析算法</h3>\n<p>递归下降分析算法适合于手工编码，而 LL (1) 分析算法适用于语法分析的自动生成。所谓 “LL (1)”，是指：从左（L）向右读入程序，最左（L）推导，采用 1 个前看符号。分析高效，也是线性时间复杂度。</p>\n<p>其基本思想是 —— 表驱动的算法，如下图。第一列都是非终结符，第一行都是终结符，行列交叉点表示对应的产生式序号。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170520036.png\" alt=\"\" /></p>\n<p>回顾之前讲过的自顶向下分析算法，最大的问题就在于去盲目推导，盲目匹配出句子，然后再去和目标句子 s 做对比，对比出错就要回溯，时间复杂度非常高。因此，就需要在推导过程中就需要做分析预测，就可以从参考这个分析表。从分析表中，通过预测输入能得到产生式的序号，就知道接下来要匹配哪个产生式了，就不需要回溯了。</p>\n<h3 id=\"lr-分析算法\"><a class=\"anchor\" href=\"#lr-分析算法\">#</a> LR 分析算法</h3>\n<p>上文主要将自顶向下的分析算法，而 LR 分析算法是自底向上的思路，但是输入、输出都是一样的。我没有看这部分，想详细了解的可以自己去看视频。</p>\n<h3 id=\"抽象语法树-ast\"><a class=\"anchor\" href=\"#抽象语法树-ast\">#</a> 抽象语法树 AST</h3>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170628092.png\" alt=\"\" /></p>\n<p>如上图，先看下抽象语法树 AST 和高级语言如何对应，根据代码对比一下，应该不难理解。其中，if 的最左侧节点是判断条件，中间节点是成功分支，右侧节点是 else 分支。</p>\n<p>再来回顾一下上文讲的 CFG 的分析树（上文有示意图），它详细编码了句子的推导过程，并且包含了很多无关信息（非终结符），会占用很多存储空间，会增加算法的空间和时间复杂度。如果能把这些 “无关信息” 给去掉，只留下运算符，数字，标识符等和程序相关的信息，就构成了抽象语法树 AST ，如下图。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170648389.png\" alt=\"\" /></p>\n<p>既然是一棵树，那么就是一个标准的数据结构，各个类型的节点的数据结构，也就可以固定了。如下图</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170704479.png\" alt=\"\" /></p>\n<p>AST 是编译器中非常重要的数据结构，因为它是编译器前端和后端的接口形式。后续的过程仅仅依赖于 AST ，不会再依赖于前面的源码或者字符集。因此，一旦生成了 AST ，前面的源码就会被丢弃。因此，AST 中要有很详细的信息，不仅仅是本课程中讲的这个简单的树。例如，AST 要存储当前程序的文件、行、列，这样在语法报错时才能准确的给出具体的错误位置。</p>\n<hr />\n<h2 id=\"语义分析\"><a class=\"anchor\" href=\"#语义分析\">#</a> 语义分析</h2>\n<p>语法分析输出 AST ，然后对 AST 进行语义分析（有些教材也会叫做 “类型检查” 或者 “上下文相关分析” 等名字）。注意，程序如果能通过了语义分析这个阶段，那再往后就不应该出现任何语法错误，除非是编译器自己的 bug 。</p>\n<h3 id=\"主要任务\"><a class=\"anchor\" href=\"#主要任务\">#</a> 主要任务</h3>\n<p>上文中的语法分析用到的是 CFG 即上下文无关的语法，即不依赖于上下文。例如 C 语言中  <code>printf(n);</code>  不符合语法，而  <code>print(&quot;%d&quot;, n);</code>  就符合语法，但是其中的  <code>n</code>  变量是否在上文已经定义了，语法分析是不知道的。</p>\n<p>因此，语义分析是在 AST 基础上，结合上下文来分析：</p>\n<ul>\n<li>变量在使用前先进行声明</li>\n<li>每个表达式都有合适的类型</li>\n<li>函数调用和函数定义一致</li>\n<li>等等 ……（每种语言的要求不一样）</li>\n</ul>\n<h3 id=\"语义规则和实现\"><a class=\"anchor\" href=\"#语义规则和实现\">#</a> 语义规则和实现</h3>\n<p>例如表达式的类型检查，定义一个类型检查函数，传入 AST 的某个表达式的节点，然后判断最后返回的类型。如果类型检查错误，就报错。如下图。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170727674.png\" alt=\"\" /></p>\n<h3 id=\"符号表\"><a class=\"anchor\" href=\"#符号表\">#</a> 符号表</h3>\n<p>上下文相关分析，就涉及到上下文信息的记录和读取，这些信息就被记录到符号表中，一个非常核心的数据结构。符号表用来存储程序中的变量相关信息（表的信息要足够丰富）：</p>\n<ul>\n<li>类型</li>\n<li>作用域</li>\n<li>访问控制信息（例如  <code>privte</code>   <code>protected</code>  等）</li>\n<li>……</li>\n</ul>\n<p>其数据结构最简单的可以使用一个  <code>key-val</code>  的字典来实现，例如  <code>&#123; key1: &#123;…&#125;, key2: &#123;…&#125;, key3: &#123;…&#125; &#125;</code>  。但是编译器要处理的程序规模可能非常庞大，因此这个数据结构必须要合理规划。在实际工程中，高效的查询方式可以有一下选择：</p>\n<ul>\n<li>选择一：为了高效，使用哈希表来实现符号表，查找是  <code>O(1)</code>  的时间复杂度</li>\n<li>选择二：为了节约空间，可以使用红黑树等平衡树，查找是  <code>O(logN)</code>  的时间复杂度</li>\n</ul>\n<p>变量都有 “作用域” 的概念，不同作用域可以有相同的变量名。符号表处理作用域的方式：</p>\n<ul>\n<li>\n<p>第一，进入作用域时插入元素，退出作用域时删除元素</p>\n</li>\n<li>\n<p>第二，采用栈：进入作用域时插入新的符号表（push），退出作用域时删除栈顶符号表（pop），如下图。 （栈的实现方式很很多种，例如链表）</p>\n<p></p>\n</li>\n</ul>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170745226.png\" alt=\"\" /></p>\n<hr />\n<h2 id=\"代码生成\"><a class=\"anchor\" href=\"#代码生成\">#</a> 代码生成</h2>\n<p>经过语义分析的 AST ，即可用来做代码生成，即生成最终的机器（物理机或者虚拟机）代码。注意，这里直接从 AST 到目标代码，是一种最简单的编译器模型，暂时忽略了优化的部分。优化过程下文会详细解说。</p>\n<h3 id=\"主要工作\"><a class=\"anchor\" href=\"#主要工作\">#</a> 主要工作</h3>\n<p>代码生成是把源程序翻译成 “目标机器”（可能是真实的机器，也可能是虚拟机）上的代码，而且要保证和源程序的 “等价性”（重要！！！）。主要的任务是：</p>\n<ul>\n<li>给源程序的数据（全局变量，局部变量等）分配计算资源（寄存器、数据区、代码区、栈区、堆区）</li>\n<li>给源程序的代码（运算 语句 函数）选择指令（算数运算 逻辑运算 跳转 函数调用等）</li>\n<li>（而且要考虑空间和时间的效率，在满足等价性的前提下）</li>\n</ul>\n<p>接下来通过两个示例来看代码生成的过程：</p>\n<ul>\n<li>栈计算机 Stack —— 代表了虚拟机，例如 JVM</li>\n<li>寄存器计算机 Reg —— 代表了 RISC 精简指令集，如 ARM 芯片</li>\n</ul>\n<h3 id=\"stack-栈计算机代码生成技术\"><a class=\"anchor\" href=\"#stack-栈计算机代码生成技术\">#</a> Stack 栈计算机代码生成技术</h3>\n<p>70 年代有栈计算机的物理机，但是今天已经退出了历史舞台，因为执行效率太低。但是这里还要研究 Stack ，一来是因为在 Stack 上代码生成比较简单，二来是很多虚拟机是这样设计的，例如 JVM 。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170805003.png\" alt=\"\" /></p>\n<p>上图就是一个 Stack 的原型图，简单解释一下图中各个部分。</p>\n<ul>\n<li>内存，存放程序变量\n<ul>\n<li>给变量  <code>x</code>  分配内存空间的伪指令： <code>.int x</code>  （伪指令，不会被 ALU 执行）</li>\n</ul>\n</li>\n<li>stack ，进行计算的空间（计算的输入、计算的中间结果和最终结果）</li>\n<li>ALU ，计算单元 。指令集是：\n<ul>\n<li><code>push NUM</code>  ，把一个立即数压栈</li>\n<li><code>load x</code>  ，得到内存中的变量  <code>x</code>  的值，并压栈</li>\n<li><code>store x</code>  ，把栈顶元素弹出，并赋值给  <code>x</code></li>\n<li><code>add</code>  ，加法，pop 赋值给  <code>x</code>  ，再 pop 赋值给  <code>y</code>  ，然后 push  <code>x+y</code></li>\n<li><code>sub</code>  ，减法，同上</li>\n<li><code>times</code>  ，乘法，同上</li>\n<li><code>div</code>  ，除法，同上</li>\n</ul>\n</li>\n</ul>\n<p>PS：以上这几条指令，就是 java 字节码的一个子集。真实的 java 字节码有 200+ 个。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170830490.png\" alt=\"\" /></p>\n<p>上图就是高级语言到最终的 Stack 计算机机器语言的对应，展示了最终的输入和输出。至于代码生成如何实现，在文章一开始的 “Sum 语言 + Stack” 的例子中这部分已经写的比较详细，就不再赘述了，翻看上文吧。</p>\n<h3 id=\"reg-寄存器计算机的代码生成技术\"><a class=\"anchor\" href=\"#reg-寄存器计算机的代码生成技术\">#</a> REG 寄存器计算机的代码生成技术</h3>\n<p>这种机器类型是基于寄存器架构，所有操作都在寄存器完成，执行效率非常高（因为寄存器访问速度是内存访问速度的百倍），访存都通过  <code>load</code>  或  <code>store</code>  指令（RISC 指令集特点）。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170858118.png\" alt=\"\" /></p>\n<p>上图就是寄存器计算机的原型图，解释一下图中各个部分。</p>\n<ul>\n<li>\n<p>内存：存放 “溢出” 的变量（寄存器中放不开的变量，如果假设寄存器有无限多个的话，就不用考虑 “溢出” 了）</p>\n</li>\n<li>\n<p>寄存器：进行计算的空间，有 r1 r2 ... rn 无限个寄存器（假定无限个，实际上寄存器个数是有限的）</p>\n<ul>\n<li>给变量  <code>x</code>  分配寄存器的伪指令  <code>.int x</code>  （伪指令不会被 ALU 执行）</li>\n</ul>\n</li>\n<li>\n<p>ALU 计算单元。指令集：</p>\n<ul>\n<li><code>movn n, r1</code>  把立即数 n 存入寄存器 r1</li>\n<li><code>mov r1, r2</code>  把 r1 的值赋值给 r2</li>\n<li><code>load [x], r1</code>  将 x 地址的值取出，放在 r1 。其中 x 是指针，[x] 即取出指针对应内存的值。</li>\n<li><code>store r1, [x]</code>  将 r1 的值赋值给 x 内存地址</li>\n<li><code>add r1, r2, r3</code>  加法，表示 r3 = r1 + r2</li>\n<li><code>sub r1, r2, r3</code>  减法，同理</li>\n<li><code>times r1, r2, r3</code>  乘法，同理</li>\n<li><code>div r1, r2, r3</code>  除法，同理</li>\n</ul>\n<p></p>\n</li>\n</ul>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170928307.png\" alt=\"\" /></p>\n<p>上图就是高级语言和目标代码的对应关系。图中有对应的 AST ，对这棵树进行后续遍历（先左、再右、最后根），每遍历一个节点都会对应到右侧的一行指令。</p>\n<ul>\n<li>“1” 节点会对应第一行指令</li>\n<li>“2” 节点会对应第二行指令</li>\n<li>“+” 节点会对应第三行指令</li>\n<li>“3” 节点会对应第四行指令</li>\n<li>……</li>\n</ul>\n<p>最后，实际的物理机器上不可能有无限多的寄存器，因此要确定哪些变量被用于寄存器？哪些变量被 “溢出” 放在内存？—— 这个问题是另外一个编译器的重要部分：编译器分配。如何进行编译器分配，这个问题会在下文介绍。</p>\n<hr />\n<h2 id=\"中间表示\"><a class=\"anchor\" href=\"#中间表示\">#</a> 中间表示</h2>\n<p>中间表示是一个统称，有很多种表示形式，AST 就是其中之一。上文提到，从 AST 直接生成目标代码是比较原始的编译技术，现代编译器中往往会在编译器的 “后端” 进行各种各样的代码优化，不同的优化形式就需要不同的表示形式。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170944117.png\" alt=\"\" /></p>\n<p>常见的中间代码形式：</p>\n<ul>\n<li>树和有向无环图：高层表示，适用于程序源代码</li>\n<li>三地址码：低层表示，靠近目标机器</li>\n<li>控制流图：更精细的三地址码，程序的图状表示</li>\n<li>静态单赋值形式 SSA ：更精细的控制流图</li>\n<li>连续传递风格：更一般的 SSA （函数式语言中用的比较多）</li>\n<li>还有很多。。。</li>\n</ul>\n<h3 id=\"三地址码\"><a class=\"anchor\" href=\"#三地址码\">#</a> 三地址码</h3>\n<p>所谓 “三地址码”，即一个指令有一个运算符，最多有三个操作数。这样就使得每一条指令都比较简单，易于和机器语言对应。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170958183.png\" alt=\"\" /></p>\n<p>上图就是一个高级语言和三地址码的对应关系（虽然三地址码是通过 AST 生成的，已经和源代码没有关系）。从图中可以看出三地址码的特点：</p>\n<ul>\n<li>给每个中间变量和计算结果命名，即没有符合表达式。例如将  <code>a = 3 + 4 * 5</code>  拆解成一个一个的中间变量</li>\n<li>只有最基本的控制流，即没有各种控制结构，只有  <code>goto</code>  和  <code>call</code>  。例如将  <code>if else</code>  改为  <code>Cjmp</code> （条件跳转指令）</li>\n</ul>\n<h3 id=\"控制流图\"><a class=\"anchor\" href=\"#控制流图\">#</a> 控制流图</h3>\n<p>三地址码是一种线性的表示方式，这就没法通过它来分析和确定流程。例如上图中，哪些指令会跳转到  <code>L_1</code>  和  <code>L_2</code>  ？并不好确定。控制流图是一种更加精细的三地址码（本质上还是三地址码），将程序中的各个控制流块都表示了出来，如下图。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171022430.png\" alt=\"\" /></p>\n<p>控制流图就是一个有向图  <code>G = (V, E)</code>  ，其中节点  <code>V</code>  表示程序的基本块，边  <code>E</code>  表示基本块之间的跳转关系。生成控制流图的目的有很多，但都是为了做代码优化，例如：</p>\n<ul>\n<li>做控制流分析，例如程序中有没有循环？</li>\n<li>做数据流分析，例如程序中某行的变量  <code>x</code>  可能的值是什么？</li>\n</ul>\n<h3 id=\"数据流分析\"><a class=\"anchor\" href=\"#数据流分析\">#</a> 数据流分析</h3>\n<p>所谓 “数据流分析”，就是通过静态的观察程序（并不执行）来判断其中的变量和数据的一些变化，例如某程序第五行的 x 变量的值会有几种可能？</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171035215.png\" alt=\"\" /></p>\n<p>如上图，通过控制流图，既可以判断一个变量  <code>y</code>  的赋值可能性。如果  <code>y</code>  能编译器识别为一个固定的值，直接  <code>a = 3</code>  并且把一开始的  <code>y = 3</code>  删掉。这就是一个优化过程。</p>\n<p>但是这仅仅是静态的分析，程序并未执行，因此如果  <code>y</code>  在一个逻辑分支中出现，就不好预估其准确结果，但是至少能预估一个结果集（称为 “保守信息”）。如果能将这个结果集做到最小，和执行的结果越接近，就越好优化。这仍然是编译器现在的一个热门话题。</p>\n<p>类似数据流分析的还有 “到达定义分析”，即分析一个变量是如何一步一步的被定义和使用的，原理和目的基本一致，这里不再赘述。</p>\n<h3 id=\"活性分析\"><a class=\"anchor\" href=\"#活性分析\">#</a> 活性分析</h3>\n<p>上文中提到 REG 机器假设有无限个寄存器，但实际情况不是。因此需要寄存器分配 —— 即用到活性分析。所谓 “活性分析”，即分析变量的活跃区间（可以理解为声明周期）然后来做寄存器的分配。</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171049617.png\" alt=\"\" /></p>\n<p>如上图，三个变量，只有一个寄存器，该如何分配？答案是：计算出每个变量的活跃区间，即可共享寄存器。寄存器分配，就依赖于变量的活动区间数据。如下图：</p>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171101780.png\" alt=\"\" /></p>\n<hr />\n<h2 id=\"代码优化\"><a class=\"anchor\" href=\"#代码优化\">#</a> 代码优化</h2>\n<p>现代生产环境下的编译器，代码优化是其重要工作之一，而且一直在不断的持续优化中。</p>\n<h3 id=\"几点说明\"><a class=\"anchor\" href=\"#几点说明\">#</a> 几点说明</h3>\n<p>代码优化的目的是让目标程序更精简、更快速、更节省空间、更节能（所谓的多快好省），当然在不改变语义的前提下 —— 这些应该都比较好理解。但是还有几点关于优化的需要重点说明一下。</p>\n<ul>\n<li>没有完美的优化，即 “没有最好只有更好”。因为编译器本来就是一个庞大复杂的工程，优化过程复杂度很高，不确定性很大。</li>\n<li>优化必须要在语义分析完成之后再进行，即确保源程序没有任何语法和语义的问题。因为优化可能会删改代码，如果优化之后再报错，错误信息就不准确了。</li>\n<li>优化并不是一个单独的阶段（如词法分析、语法分析等），而是在各个阶段都可能进行。可以对 AST 进行优化，也可以对各种中间表示进行优化，还可以对目标代码再继续优化，每一步的优化针对想都不一样。</li>\n<li>一般针对一个数据优化之后不会产生新的格式（但会产生新的数据，即函数式编程的思维），优化不是翻译过程。</li>\n</ul>\n<p></p>\n<p><img data-src=\"%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171118467.png\" alt=\"\" /></p>\n<h3 id=\"前端优化\"><a class=\"anchor\" href=\"#前端优化\">#</a> 前端优化</h3>\n<p>即对 AST 进行优化，下面列举几个例子来说明。</p>\n<p>第一，常量折叠。静态计算，可以在数字类型和 bool 类型进行优化，例如：</p>\n<ul>\n<li><code>a = 3 + 5</code>  变为  <code>a = 8</code>  （少了一步  <code>+</code>  计算，就相当于帮 AST 节省了一个分支）</li>\n<li><code>if (true &amp;&amp; false)</code>  变为  <code>if (false)</code>  。而且， <code>if (else)</code>  还可以进行 “不可达代码” 优化（见下文）</li>\n</ul>\n<p>第二，代数化简。利用代数的恒等式，进行优化，例如：</p>\n<ul>\n<li><code>a = 0 + b</code>  变为  <code>a = b</code>  （少一个运算符，简化 AST）</li>\n<li><code>a = 1 * b</code>  变为  <code>a = b</code>  （少一个运算符，简化 AST）</li>\n<li><code>2 * a</code>  变为  <code>a + a</code>  （因为乘法运算复杂度高）</li>\n<li><code>2 * a</code>  变为  <code>a &lt;&lt; 1</code>  （位运算效率最高）</li>\n</ul>\n<p>第三，死代码（不可达）代码优化，例如</p>\n<ul>\n<li><code>if (false)</code>  不会被执行，测试环境的 debug 代码，到了线上环境就会是死代码</li>\n<li>函数的  <code>return</code>  之后的语句，不会被执行</li>\n</ul>\n<h3 id=\"中间表示上的优化\"><a class=\"anchor\" href=\"#中间表示上的优化\">#</a> 中间表示上的优化</h3>\n<p>如常量传播、拷贝传播，在上文讲数据流分析的时候已经写过，不再赘述。</p>\n<hr />\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>编译器真的是一个非常非常非常复杂的工具，其中涉及到的知识点包括数学理论、计算机组成原理、算法和数据结构。如果真的想要深入了解一门语言，那就到它的编译器中去看看吧。</p>\n",
            "tags": []
        },
        {
            "id": "https://hdqjl317.github.io/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/",
            "url": "https://hdqjl317.github.io/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/",
            "title": "vscode通过密钥连接远程服务器",
            "date_published": "2022-08-20T08:28:27.000Z",
            "content_html": "<p><strong>一，生成密钥，或者在购买服务器时选择 ssh 密匙登录</strong></p>\n<p>第一种：通过指令 ssh-keygen 生成，具体的我就不说了</p>\n<p>第二种：通过服务商生成，阿里云，腾讯云，华为云的网站有创建密钥的，比如腾讯云</p>\n<p><img data-src=\"/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204153756653.png\" class=\"\" title=\"这是一张图片\"></p>\n<p><img data-src=\"vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204153756653.png\" alt=\"\" /></p>\n<p><strong>二，将密钥绑定到服务器，也可以在网站直接操作，修改密码为密钥就好了</strong></p>\n<p><strong>三，在 vscode 上安装 Remote Development 插件，然后将几个扩展包也安装一下</strong></p>\n<p><strong>四，点击远程资源管理器</strong></p>\n<p><img data-src=\"/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204153918156.png\" class=\"\" title=\"这是一张图片\"></p>\n<p><img data-src=\"vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204153918156.png\" alt=\"\" /><br />\n<strong>五，点击 + 号在输入框输入 ssh 登录名 @IP 地址</strong></p>\n<p><img data-src=\"/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204153949670.png\" class=\"\" title=\"这是一张图片\"></p>\n<p><img data-src=\"vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204153949670.png\" alt=\"\" /></p>\n<p><strong>六，输入完成后按回车会出现选择选择，选择 C:User\\XXX.ssh\\config</strong></p>\n<p><img data-src=\"/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204154137681.png\" class=\"\" title=\"这是一张图片\"></p>\n<p><img data-src=\"vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204154137681.png\" alt=\"\" /></p>\n<p>上面三条是自动生成的，Host 那条是本地名称，可以修改用来区分服务器，最后一条写的是私钥的地址，地址加上 “”。然后点击下图这个符号就可以连接远程服务器了。</p>\n<p><img data-src=\"/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204154455497.png\" class=\"\" title=\"这是一张图片\"></p>\n<p><img data-src=\"vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204154455497.png\" alt=\"\" /></p>\n",
            "tags": [
                "工作技能",
                "vscode"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/08/10/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%873/",
            "url": "https://hdqjl317.github.io/2022/08/10/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%873/",
            "title": "cpp11新特性篇3",
            "date_published": "2022-08-10T08:24:51.000Z",
            "content_html": "<h2 id=\"autodecltype\"><a class=\"anchor\" href=\"#autodecltype\">#</a> auto&amp;&amp;decltype</h2>\n<p>静态类型：类型检查在编译阶段</p>\n<p>动态类型：类型检查在运行阶段</p>\n<p>auto 声明变量的类型必须由编译器在编译时期推导而得，其优势是在拥有初始化表达式的复杂类型变量声明时简化代码。</p>\n<p>decltype 以一个普通的表达式为参数，返回该表达式的类型。</p>\n<p>用 decltype (e) 来获取类型时，编译器将依序判断以下四规则：</p>\n<ul>\n<li>如果 e 是一个没有带括号的标记符表达式或者类成员访问表达式，那么 decltype (e) 就是 e 所命名的实体的类型。如果 e 是一个被重载的函数，则会导致编译时错误。</li>\n<li>否则，假设 e 的类型是 T，如果 e 是一个将亡值 (xvalue)，那么 decltype (e) 为 T&amp;&amp;。</li>\n<li>否则，假设 e 的类型是 T，如果 e 是一个左值，则 decltype (e) 为 T&amp;。</li>\n<li>否则，假设 e 的类型是 T，则 decltype (e) 为 T。</li>\n</ul>\n<h2 id=\"追踪返回类型\"><a class=\"anchor\" href=\"#追踪返回类型\">#</a> 追踪返回类型</h2>\n<p>对返回类型进行类型推导：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>`<span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span>\t\t\t<span class=\"token comment\">// 直观的方案</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">+</span> t2<span class=\"token punctuation\">)</span> <span class=\"token function\">Sum</span><span class=\"token punctuation\">(</span>T1 <span class=\"token operator\">&amp;</span> t1<span class=\"token punctuation\">,</span> T2 <span class=\"token operator\">&amp;</span> t2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> t1 <span class=\"token operator\">+</span> t2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span>\t\t\t<span class=\"token comment\">// 追踪返回类型的方案</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">auto</span> <span class=\"token function\">Sum</span><span class=\"token punctuation\">(</span>T1 <span class=\"token operator\">&amp;</span> t1<span class=\"token punctuation\">,</span> T2 <span class=\"token operator\">&amp;</span> t2<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">+</span> t2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">return</span> t1 <span class=\"token operator\">+</span> t2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">auto</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">int</span> <span class=\"token punctuation\">;</span>`</pre></td></tr></table></figure><p>把原本的函数返回值移到参数声明之后，而原本的返回值的位置由 auto 关键字占据。auto 占位符和 return_type 是构成追踪返回类型函数的两个基本元素。</p>\n<p>追踪返回类型另一个优势是简化函数的定义，提高代码可读性。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>`#include<span class=\"token operator\">&lt;</span>type_traits<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token function\">pf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">//auto (*)() -> int (*) () 一个返回函数指针的函数（假设为 a 函数）</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">//auto pf1 () -> auto (*)() -> int (*)() 一个返回 a 函数的指针的函数</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">auto</span> <span class=\"token function\">pf1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">auto</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\t<span class=\"token comment\">// 和上面等价</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> is_same<span class=\"token operator\">&lt;</span><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>pf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>pf1<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>value <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>追踪返回类</code> 型也常用于转发函数中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>`#include <span class=\"token operator\">&lt;</span>iostream<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">double</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span>a <span class=\"token operator\">+</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">auto</span> <span class=\"token function\">Forward</span><span class=\"token punctuation\">(</span>T t<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">Forward</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//2.1</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">Forward</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//0</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span>`</pre></td></tr></table></figure>",
            "tags": [
                "编程语言",
                "cpp"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/08/04/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%872/",
            "url": "https://hdqjl317.github.io/2022/08/04/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%872/",
            "title": "cpp11新特性篇2",
            "date_published": "2022-08-04T05:01:42.000Z",
            "content_html": "<h3 id=\"继承构造函数\"><a class=\"anchor\" href=\"#继承构造函数\">#</a> 继承构造函数</h3>\n<p>如果基类有多个构造函数，使用继承构造函数可以让派生类免于重写各个基类的构造函数。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> d<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> f<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">B</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token class-name\">A</span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">using</span> A <span class=\"token operator\">:</span> A<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 继承构造函数</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>c++11 标准继承构造函数和默认构造函数、析构函数、拷贝构造一样，都是隐式声明的。不过继承构造函数只会初始化基类中的成员变量，对于派生类的成员变量无法初始化，这时候要结合初始化表达式为派生类的成员变量设定默认值。但是，<strong>继承构造函数不会继承基类的成员变量的默认值</strong>。</p>\n<p>当派生类的继承基类时，派生类的继承构造函数可能不只有一个结果：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token function\">A</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> <span class=\"token number\">2.4</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">B</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token class-name\">A</span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token keyword\">using</span> A<span class=\"token double-colon punctuation\">::</span>A<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>可能生成的继承构造函数如下：</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span><span class=\"token operator\">=</span><span class=\"token number\">2.4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> A<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>对应的B的构造函数将有：</pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span><span class=\"token operator\">=</span><span class=\"token number\">2.4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> B<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>其他的规则：</p>\n<ul>\n<li>如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，则不能在派生类中声明继承构造函数。</li>\n<li>如果派生类一旦使用了继承构造函数，编译器则不会为派生类构造自己的默认构造函数。</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">&#123;</span><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">B</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token class-name\">A</span></span> <span class=\"token punctuation\">&#123;</span><span class=\"token keyword\">using</span> A<span class=\"token double-colon punctuation\">::</span>A<span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>B b<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//B 没有默认构造函数，不能通过编译</span></pre></td></tr></table></figure><h3 id=\"委派构造函数\"><a class=\"anchor\" href=\"#委派构造函数\">#</a> 委派构造函数</h3>\n<p>所谓委托构造就是让类中的某个构造函数去委托另一个构造函数执行构造操作的机制。一个委托构造函数使用<strong>它所属类的其他构造函数</strong>执行自己的初始化过程。调用者叫委派构造函数，被调用者叫目标构造函数。</p>\n<h3 id=\"右值引用移动语义和完美转发\"><a class=\"anchor\" href=\"#右值引用移动语义和完美转发\">#</a> 右值引用：移动语义和完美转发</h3>\n<p>(1) 移动构造函数：移交所有权，析构自身。</p>\n<ul>\n<li>\n<p>左值：可以取地址的，有名字的。</p>\n</li>\n<li>\n<p>右值：不能取地址，无名字的。又可细分为纯右值和将亡值。</p>\n<ul>\n<li>纯右值：辨识临时变量和一些不跟对象关联的值</li>\n<li>将亡值：C++11 新增的跟右值引用相关的表达式，如右值引用 T &amp;&amp; 的函数返回值、std::move 的返回值、或者转换为 T &amp;&amp; 的类型转换函数的返回值</li>\n</ul>\n</li>\n</ul>\n<p>为区别 C++98 的引用类型，之前的引用叫做左值引用，左值引用和右值引用都是引用类型，声明时都必须立即进行初始化。右值引用只能绑定右值，不能绑定任何左值。左值引用可以接受非常量左值、常量左值、右值对其进行初始化。</p>\n<p><code>T &amp;&amp; a = ReturnRvalue(); \t\t// √ 绑定右值</code></p>\n<p><code>int c;</code> <br />\n <code>int &amp;&amp; d = c;\t\t\t\t\t// X 绑定左值</code></p>\n<p>使用移动语义的前提下需要给类添加一个以右值引用为参数的移动构造函数。</p>\n<p>而通常情况下，在为类声明了一个移动构造函数后，可以声明一个常量左值为参数的拷贝构造函数，以保证在移动构造不成时，还可以进行拷贝构造（偶尔也有特殊用途的反例）。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">引用类型 \\ 可以引用的值类型</th>\n<th style=\"text-align:center\">非常量左值</th>\n<th style=\"text-align:center\">常量左值</th>\n<th style=\"text-align:center\">非常量右值</th>\n<th style=\"text-align:center\">常量右值</th>\n<th style=\"text-align:center\">注记</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">非常量左值引用</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">常量左值引用</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">全能类型、可用于拷贝语义</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">非常量右值引用</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">用于移动语义、完美转发</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">常量右值引用</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">暂无用途</td>\n</tr>\n</tbody>\n</table>\n<p>如果不知道一个类型是否属于引用类型，可以用标准库 &lt;type_traits&gt; 头文件中的 3 个模板类进行判断：is_rvalue_reference、is_lvalue_reference、is_reference。如判断 string &amp;&amp; 的类型：</p>\n<p><code>cout &lt;&lt; is_rvalue_reference&lt;string &amp;&amp;&gt;::value;</code></p>\n<p>(2) std::move: 强制转化为右值</p>\n<p>std::move 基本等同于一个类型转换：</p>\n<p><code>static_cast&lt;T&amp;&amp;&gt;(lvalue);</code></p>\n<p><strong>但注意：被 std::move 转化的左值，其生命期并没有随着左右值的转化而改变。</strong></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Moveable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token function\">Moveable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">i</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token operator\">~</span><span class=\"token function\">Moveable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">delete</span> i<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">Moveable</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Moveable <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">i</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>m<span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">Moveable</span><span class=\"token punctuation\">(</span>Moveable <span class=\"token operator\">&amp;&amp;</span> m<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">i</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        m<span class=\"token punctuation\">.</span>i <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    Moveable a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    Moveable <span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 会调用移动构造函数</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">.</span>i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 运行时错误</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>move (a) 后，a.i 就被移动构造函数设置为指针空值，所以后来使用会报错</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>*/</span></pre></td></tr></table></figure><p>如上例，在大多数时候，我们需要将其转化为右值引用的还是一个确实生命期即将结束的对象。</p>\n<p>声明了移动构造函数、移动赋值函数、拷贝赋值函数和析构函数中的一个或多个，编译器不会再为程序员生成默认的拷贝构造函数。所以拷贝构造 / 赋值和移动构造 / 赋值函数必须同时提供，或者同时不提供，这才能保证类同时具备拷贝语义和移动语义。</p>\n<p>可以通过可以用标准库 &lt;type_traits&gt; 头文件中的 is_move_constructible、is_trivially_move_constructible、is_nothrow_move_constructible 判断一个类型是否可以移动：</p>\n<p><code>cout &lt;&lt; is_move_constructible&lt;UnknownType&gt;::value;</code></p>\n<p>(3) 完美转发（perfect forwarding）</p>\n<p>完美转发，是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。</p>\n<p><code>template &lt;typename T&gt;</code> <br />\n <code>void IamForwording(T t) &#123; IrunCodeActually(t); &#125;</code></p>\n<p>对于目标函数 IrunCodeActually 而言，它总是希望转发函数将参数按照传入 lamForwarding 时的类型传递 (即传入 lamForwording 的是左值对象，IrunCodeActually 就能获得左值对象，传入 lamForwording 的是右值对象，lrunCodeActually 就能获得右值对象)，而不产生额外的开销，就好像转发者不存在一样。</p>\n<p>C++11 通过使用 “引用折叠”（reference collapsing），结合新的模板推导规则实现完美转发。</p>\n<p>引用折叠：即将复杂的未知表达式折叠为已知的简单表达式。</p>\n<p><code>typedef const int T;</code> <br />\n <code>typedef T&amp; TR;</code> <br />\n <code>TR&amp; v = 1;\t\t//该声明在C++98中会导致编译报错,而在c++11中会导致引用折叠</code></p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<strong>表  c++11 中的引用折叠</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">TR 的类型定义</th>\n<th style=\"text-align:center\">声明 v 的类型</th>\n<th style=\"text-align:center\">v 的实际类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">T&amp;</td>\n<td style=\"text-align:center\">TR</td>\n<td style=\"text-align:center\">A&amp;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">T&amp;</td>\n<td style=\"text-align:center\">TR&amp;</td>\n<td style=\"text-align:center\">A&amp;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">T&amp;</td>\n<td style=\"text-align:center\">TR&amp;&amp;</td>\n<td style=\"text-align:center\">A&amp;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">T&amp;&amp;</td>\n<td style=\"text-align:center\">TR</td>\n<td style=\"text-align:center\">A&amp;&amp;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">T&amp;&amp;</td>\n<td style=\"text-align:center\">TR&amp;</td>\n<td style=\"text-align:center\">A&amp;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">T&amp;&amp;</td>\n<td style=\"text-align:center\">TR&amp;&amp;</td>\n<td style=\"text-align:center\">A&amp;&amp;</td>\n</tr>\n</tbody>\n</table>\n<p>将之前的例子改写：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 改写为完美转发</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">IamForwording</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;&amp;</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">IrunCodeActually</span><span class=\"token punctuation\">(</span><span class=\"token generic-function\"><span class=\"token function\">static_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>T <span class=\"token operator\">&amp;&amp;</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在 c++11 中用于完美转发的函数是 forward，它和 move 的实际实现上差别不大，move 也可以实现完美转发，但并不推荐。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">IamForwording</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;&amp;</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">IrunCodeActually</span><span class=\"token punctuation\">(</span><span class=\"token function\">forward</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"显示转换操作符\"><a class=\"anchor\" href=\"#显示转换操作符\">#</a> 显示转换操作符</h3>\n<p>explicit 作用：在 C++ 中，explicit 关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。</p>\n<p>explicit 使用注意事项:</p>\n<ul>\n<li>explicit 关键字只能用于类内部的构造函数声明上。</li>\n<li>explicit 关键字作用于单个参数的构造函数。</li>\n<li>explicit 关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换</li>\n</ul>\n<h3 id=\"列表初始化\"><a class=\"anchor\" href=\"#列表初始化\">#</a> 列表初始化</h3>\n<p>不仅能用于内置类型、标准库中的容器，只要 #include 了 &lt;initializer_list&gt; 头文件，并且声明一个以   initialize_list&lt; T &gt; 模板类为参数的构造函数，同样可以使得自定义的类使用列表初始化。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">enum</span> <span class=\"token class-name\">Gender</span> <span class=\"token punctuation\">&#123;</span>boy<span class=\"token punctuation\">,</span> girl<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">People</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">People</span><span class=\"token punctuation\">(</span>initializer_list<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> Gender<span class=\"token operator\">></span> <span class=\"token operator\">></span> l<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">auto</span> i <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">!=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            data<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    vector<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> Gender<span class=\"token operator\">></span> <span class=\"token operator\">></span> data<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>函数的参数列表也可以使用初始化列表。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;initializer_list></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Fun</span><span class=\"token punctuation\">(</span>initializer_list<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> iv<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">Func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">Func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 空列表</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span>`</pre></td></tr></table></figure><p>同理，类和结构体的成员函数也可以使用初始化参数列表，包括一些操作符的重载函数。</p>\n<p>此外，初始化列表还可以用于函数返回的情况，返回一个初始化列表，通常会导致构造一个临时变量，比如：</p>\n<p><code>vector&lt;int&gt; Func &#123; return &#123;1,3&#125;; &#125;</code></p>\n<p>使用列表初始化的优势是可以防止类型收窄（narrowing）。</p>\n<p>类型收窄一般是指一些可以使得数据变化或者精度丢失的隐式类型转换。</p>\n<p><code>const int x = 1024;</code> <br />\n <code>const int y = 10;</code></p>\n<p><code>char a = x;\t\t\t\t\t// 收窄，但可以通过编译</code> <br />\n <code>char *b = new char(1024);\t// 收窄，但可以通过编译</code></p>\n<p><code>char c = &#123;x&#125;;\t\t\t\t// 收窄，无法通过编译</code> <br />\n <code>char d = &#123;y&#125;;\t\t\t\t// 可以通过编译，char的取值范围在-128~127</code> <br />\n <code>unsigned char e &#123;-1&#125;;\t\t// 收窄，无法通过编译</code></p>\n<p><code>float f &#123;7&#125;;\t\t\t\t// 可以通过编译，这个可以转换会原类型，没有发生精度丢失，所以可以通过</code> <br />\n <code>int g &#123; 2.0 f&#125;;\t\t\t\t// 收窄，无法通过编译，2.0f是一个有精度的浮点数值，转换成整数会丢失精度</code> <br />\n <code>float *h = new float&#123;1e48&#125;; // 收窄，无法通过编译</code> <br />\n <code>float i = 1.21;\t\t\t\t// 可以通过编译</code></p>\n",
            "tags": [
                "编程语言",
                "cpp"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/08/01/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%871/",
            "url": "https://hdqjl317.github.io/2022/08/01/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%871/",
            "title": "cpp11新特性篇1",
            "date_published": "2022-08-01T05:01:42.000Z",
            "content_html": "<h3 id=\"查验机器环境\"><a class=\"anchor\" href=\"#查验机器环境\">#</a> 查验机器环境</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Standard Clib: \"</span> <span class=\"token operator\">&lt;&lt;</span> __STDC_HOSTED__ <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Standard C: \"</span> <span class=\"token operator\">&lt;&lt;</span> __STDC__ <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// cout &lt;&lt; \"C Standard version: \" &lt;&lt; __STDC_VERSION__ &lt;&lt; endl;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"ISO/IEC \"</span> <span class=\"token operator\">&lt;&lt;</span> __STDC_ISO_10646__ <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>Standard Clib<span class=\"token operator\">:</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>Standard C<span class=\"token operator\">:</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>ISO<span class=\"token operator\">/</span>IEC <span class=\"token number\">201706</span></pre></td></tr></table></figure><h3 id=\"返回函数的名字\"><a class=\"anchor\" href=\"#返回函数的名字\">#</a> 返回函数的名字</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 返回函数的名字，预定义标识符 __func__</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> <span class=\"token constant\">__func__</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">world</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> <span class=\"token constant\">__func__</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">TestStruct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">TestStruct</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token constant\">__func__</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>   <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\", \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">world</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    TestStruct ts<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> ts<span class=\"token punctuation\">.</span>name <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"20\"></td><td><pre>   <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>hello<span class=\"token punctuation\">,</span> world</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>TestStruct</pre></td></tr></table></figure><h3 id=\"变长参数宏定义\"><a class=\"anchor\" href=\"#变长参数宏定义\">#</a> 变长参数宏定义</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 变长参数宏定义 __VA_ARGS__</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">LOG</span><span class=\"token expression\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>  </span><span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token expression\"><span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> </span><span class=\"token string\">\"%s: Line %d:\\t\"</span><span class=\"token expression\"><span class=\"token punctuation\">,</span> <span class=\"token constant\">__FILE__</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">__LINE__</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </span><span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token expression\"><span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> __VA_ARGS__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </span><span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token expression\"><span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> </span><span class=\"token string\">\"\\n\"</span><span class=\"token expression\"><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </span><span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token expression\"><span class=\"token punctuation\">&#125;</span></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">LOG</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"x = %d\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>va_args<span class=\"token punctuation\">.</span>cpp<span class=\"token operator\">:</span> Line <span class=\"token number\">13</span><span class=\"token operator\">:</span>   x <span class=\"token operator\">=</span> <span class=\"token number\">3</span></pre></td></tr></table></figure><h3 id=\"静态断言与static_assert\"><a class=\"anchor\" href=\"#静态断言与static_assert\">#</a> 静态断言与 static_assert</h3>\n<ul>\n<li>断言宏 assert 只用于程序运行时</li>\n<li>#error 只在编译器预处理时有效</li>\n<li>static_assert 用于程序编译时进行断言</li>\n</ul>\n<p>static_assert 接收两个参数，一个 bool 值，一个字符串警告信息。</p>\n<p>static_assert 的断言表达式的结果必须时在编译时期就可以计算的表达式，及必须是常量表达式。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;cstring></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">U</span><span class=\"token operator\">></span> <span class=\"token keyword\">int</span> <span class=\"token function\">bit_copy</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> U <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">static_assert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"the parameters of bit_copy must have same width.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0x2468</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">double</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">bit_copy</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"noexcept修饰符与noexcept操作符\"><a class=\"anchor\" href=\"#noexcept修饰符与noexcept操作符\">#</a> noexcept 修饰符与 noexcept 操作符</h3>\n<ul>\n<li>noexcept 不会抛出异常，通过调用 std::terminate () 来终止程序的运行，则这样可以减少异常机制带来的开销（比如，不用进行栈帧的一级一级的展开），有效的阻止了异常的传播与扩散。</li>\n<li>但也可能存在一些问题，比如 noexcepet 后无法保证对象的析构函数的正常调用，无法保证栈的自动释放等等。</li>\n<li>C++11 默认将 delete 函数设置为 noexcept，即 nocept (true)，可以提高程序的安全性。</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>`<span class=\"token keyword\">void</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t<span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 可以抛出异常</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t<span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 可以抛出异常</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">except_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 用于函数，默认 noexcept (true)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">except_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">(</span>常量表达式<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 用于函数</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token function\">T</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">//noexcept () 用于模板 `</span></pre></td></tr></table></figure><h3 id=\"快速初始化成员变量\"><a class=\"anchor\" href=\"#快速初始化成员变量\">#</a> 快速初始化成员变量</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">C</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">C</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">c</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Init</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\t\t\t\t<span class=\"token comment\">// 可以通过编译，以前的 C++98 不能通过编译</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    string <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// 无法通过编译</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    C <span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t\t\t\t<span class=\"token comment\">// 无法通过编译</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    Init temp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span>`</pre></td></tr></table></figure><h3 id=\"override和final\"><a class=\"anchor\" href=\"#override和final\">#</a> override 和 final</h3>\n<ul>\n<li>override：保证在派生类中声明的重载函数，与基类的虚函数有相同的签名（函数名，参数，const 属性）；</li>\n<li>final：阻止类的进一步派生 和 虚函数的进一步重写。</li>\n</ul>\n<p>加了 override，明确表示派生类的这个虚函数是要重写基类的，如果派生类与基类虚函数的签名不一致，编译器就会报错。一个虚函数被声明为 final，则派生类不能再重写它。</p>\n<h3 id=\"模板函数的默认模板参数\"><a class=\"anchor\" href=\"#模板函数的默认模板参数\">#</a> 模板函数的默认模板参数</h3>\n<p>c<ins>98 不支持函数模板的默认模板参数，c</ins>11 支持。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Deparm</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>   <span class=\"token comment\">//c++98 编译通过， c++11 编译通过</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">class</span> <span class=\"token class-name\">DefClass</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">//c++98 编译通过， c++11 编译通过</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">void</span> <span class=\"token function\">DefTempParm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>   <span class=\"token comment\">//c++98 编译不通过， c++11 编译通过 `</span></pre></td></tr></table></figure><p>对于类模板，如果定义模板类的默认模板参数，必须按照从左到右定义。而对于函数模板没有此要求。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DefClass1</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//c++11 可以通过编译</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DefClass2</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//c++11 不能通过编译</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token operator\">></span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DefClass1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//c++11 可以通过编译</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DefClass1</span><span class=\"token punctuation\">;</span>\t  <span class=\"token comment\">//c++11 不能通过编译</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">DefFunc1</span><span class=\"token punctuation\">(</span>T1 a<span class=\"token punctuation\">,</span> T2 b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//c++11 可以通过编译</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">DefFunc2</span><span class=\"token punctuation\">(</span>T a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t\t\t\t<span class=\"token comment\">//c++11 可以通过编译 `</span></pre></td></tr></table></figure>",
            "tags": [
                "编程语言",
                "cpp"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/07/01/other/hello-world/",
            "url": "https://hdqjl317.github.io/2022/07/01/other/hello-world/",
            "title": "Hello World",
            "date_published": "2022-07-01T03:01:42.000Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": [
                "杂谈",
                "其他"
            ]
        }
    ]
}