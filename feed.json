{
    "version": "https://jsonfeed.org/version/1",
    "title": null,
    "subtitle": "加楽的小站",
    "icon": "https://hdqjl317.github.io/images/favicon.ico",
    "description": "欢迎来到 Caleb 的个人博客!",
    "home_page_url": "https://HDqjl317.github.io",
    "items": [
        {
            "id": "https://hdqjl317.github.io/2023/06/30/computer-science/C%E5%AE%8F%E5%88%B0Rust%E5%AE%8F%E8%BD%AC%E5%8C%96%E8%A7%84%E5%88%99%E8%AE%BE%E8%AE%A1/",
            "url": "https://hdqjl317.github.io/2023/06/30/computer-science/C%E5%AE%8F%E5%88%B0Rust%E5%AE%8F%E8%BD%AC%E5%8C%96%E8%A7%84%E5%88%99%E8%AE%BE%E8%AE%A1/",
            "title": "C宏到Rust宏转化规则设计",
            "date_published": "2023-06-30T12:18:31.000Z",
            "content_html": "<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>C2Rust是一个将符合C99标准的代码迁移到Rust的转换器，本项目需要基于C2Rust将C预处理阶段的宏转换为Rust编译阶段的宏。因此，需要对C宏进行分析，并利用Rust宏的性质来寻找它们之间可能的映射关系和转换方案。</p>\n<h3 id=\"研究对象\"><a href=\"#研究对象\" class=\"headerlink\" title=\"研究对象\"></a>研究对象</h3><p>根据C99标准，C宏大体上可以分为替换文本宏（Replacing Text Macros）和条件包含（Conditional Inclusion）两种，而我们要根据这两类宏设计与之对应的Rust宏的转换规则。</p>\n<p>替换文本宏的句法如下：</p>\n<pre><code class=\"c\">#define identifier replacement-list(optional)       // Object-like Macros\n#define identifier( parameters ) replacement-list     // Function-like Macros\n#define identifier** **( parameters, ... ) replacement-list // Function-like Macros\n#define identifier** **( ... ) replacement-list       // Function-like Macros\n#undef identifier                    // #undef directive\n</code></pre>\n<p>条件包含的句法如下：</p>\n<pre><code class=\"c\">#if expression\n#ifdef identifier\n#ifndef identifier\n#elif expression\n#else\n#endif\n</code></pre>\n<h3 id=\"具体转换方案\"><a href=\"#具体转换方案\" class=\"headerlink\" title=\"具体转换方案\"></a>具体转换方案</h3><h4 id=\"define宏指令的转换\"><a href=\"#define宏指令的转换\" class=\"headerlink\" title=\"define宏指令的转换\"></a>define宏指令的转换</h4><p>C中define指令定义标识符为宏，即它们指示编译器将所有标识符的后继出现替换为替换列表，可以可选地附加地处理。我们此阶段define指令宏的转换规则主要适用于以下这两种常用的语法形式：</p>\n<pre><code class=\"c\">#define identifier replacement-list(optional)    \t\t（1）\n#define identifier( parameters ) replacement-list\t\t（2）\n#define identifier( parameters, ... ) replacement-list\t（3）\n#define identifier( ... ) replacement-list\t\t\t\t（4）\n</code></pre>\n<p>这里将第一类define宏指令归为常量宏，第二、三、四类define宏指令归为语句宏或函数宏，下面针对这两种形式的define语法给出具体的转化规则。</p>\n<p>考虑到为了在rust中能够设计一个通用的声明宏来对应C中define定义的不同变量类型的宏指令，这里将上诉C种的常量宏具体使用形式大致归为以下四种：</p>\n<pre><code class=\"c\">#define MAX_SIZE 1024\n#define MY_STR &quot;root/api/&quot;\n#define MYTY int\n#define MYNIL\n</code></pre>\n<p>针对这四种形式的常量宏，设计如下rust对应的声明宏：</p>\n<pre><code class=\"rust\">my_def!(MAX_SIZE: i32, 1024);\nmy_def!(MY_STR: &amp;&#39;static str, &quot;root/api/&quot;);\nmy_def!(MYTY, i32);\nmy_def!(MYNIL: bool, true);\n</code></pre>\n<p>上述四种形式的define指令的常量宏包含了基础类型的定义、String非基础类型的定义、取类型别名和无替换文本的情况。据此，设计如下声明宏my_def：</p>\n<pre><code class=\"rust\">macro_rules! my_def &#123;\n\n     ($name: ident : $ty: ty, $value: expr) =&gt; &#123;\n\n        #[allow(non_upper_case_globals)]\n\n        pub const $name: $ty = $value;\n\n      &#125;;\n\n  ($name: ident, $ty: ty) =&gt; &#123;\n\n        #[allow(non_camel_case_types)]\n\n        pub type $name = *mut $ty;\n\n      &#125;;\n&#125;\n</code></pre>\n<p>匹配规则中的ty标识为类型，expr标识为表达式，通过定义一个公开的const类型变量名为传入的name、值为传入的value来实现C中的常量宏的定义。使用方式如下：</p>\n<pre><code class=\"rust\">my_def!(MAX_SIZE: i32, 1024);\nmy_def!(MY_STR: &amp;&#39;static str, &quot;root/api/&quot;);\nmy_def!(MYTY, i32);\nmy_def!(MYNIL: bool, true)\n</code></pre>\n<p>功能与上述C中的define的四条宏指令功能一致。</p>\n<p>对于语句宏或函数宏，类似于C中的函数调用，替换文本replacement-list一般也是函数调用或者函数的函数体语句块。针对此种用法，设计如下与之功能对应的rust声明宏：</p>\n<pre><code class=\"rust\">macro_rules! function_macro &#123;\n      (\n        $(#[$attr:meta])\n        $vis:vis fn $name:ident ( $( $arg:ident : $t:ty ),* ) -&gt; $ret:ty &#123;\n          $($body:tt)\n        &#125;\n      ) =&gt; &#123;\n        $(#[$attr])\n        $vis fn $name ( $( $arg : $t ),* ) -&gt; $ret &#123;\n          $($body)\n        &#125;\n      &#125;;\n&#125;\n</code></pre>\n<p>标识vis标明函数的可见性，**$( $arg:ident : $t:ty ),*<strong>和</strong>$( $arg : $t ),*** 重复零次或者多次，因此参数的个数可以不受限制，而函数体的标识符为tt标识，是Token 树，可以被匹配的定界符 <code>(</code>、<code>[]</code> 或 <code>&#123;&#125;</code> 中的单个或多个 token，因此该声明宏也能完成声明宏的嵌套，而对于函数体body部分可以借用c2rust进行代码转换。</p>\n<p>C中define语句：</p>\n<pre><code class=\"c\">#define add(a, b) ((a) + (b))\n#define myprint(a, b) \n&#123; \n    printf(&quot;%d\\n&quot;, (a) * (b)); \n    (a) * (b); \n&#125;\n\n#define mytotal(a, b) \n(&#123; \n    int sum = 0; \n    for (int i = (a); i &lt;= (b); i++) &#123; \n        sum += i;\n    &#125; \n    sum; \n&#125;)\n\n#define factorial(n) \n(&#123; \n    unsigned long long result; \n    if ((n) &lt;= 1) &#123; \n        result = 1; \n    &#125; else &#123; \n        result = (n) * factorial((n) - 1); \n    &#125; \n    result; \n&#125;)\n</code></pre>\n<p>使用设计的声明宏模板，则对应rust以下形式：</p>\n<pre><code class=\"rust\">function_macro!(\n    pub fn add(a: i32, b: i32) -&gt; i32 &#123;\n        a + b\n    &#125;\n);\n\nfunction_macro!(\n    pub fn myprint(a: i32, b: i32) -&gt; i32 &#123;\n        println!(&quot;&#123;&#125;&quot;, a*b);\n        a*b\n    &#125;\n);\n\nfunction_macro!(\n    pub fn mytotal(a: i32, b: i32) -&gt; i32 &#123;\n        let mut sum = 0;\n        for i in a..=b &#123;\n               sum += i;\n        &#125;\n        sum\n    &#125;\n);\n\nfunction_macro! &#123;\n    pub fn factorial(n: u64) -&gt; u64 &#123;\n        if n &lt;= 1 &#123;\n            1\n        &#125; else &#123;\n            n * factorial(n - 1)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"条件编译宏指令\"><a href=\"#条件编译宏指令\" class=\"headerlink\" title=\"条件编译宏指令\"></a><strong>条件编译宏指令</strong></h4><p>C中的条件编译相关的宏指令常用于各类C相关项目中，本课题也需考虑此类宏指令的对应规则。C中条件编译指令可分为以下几类:</p>\n<ul>\n<li>#ifdef 和 #ifndef 用于检查某个宏标识是否被定义，但只处理其后的第一个标识符，如#ifdef ABCD &amp;&amp; ABCD &#x3D;&#x3D; 1，只要#define了ABCD，其后ABCD &#x3D;&#x3D; 1无论为true或者false都将被丢弃，C中编译器只会对此写法提示warning，不会阻止编译。</li>\n<li>#if 、#elif 和 #else 用于条件编译判断</li>\n<li>#if defined() 和#if !defined()功能上等价于#ifdef 和 #ifndef，但其后的 &amp;&amp; 或者 || 接的标识符仍旧有效。</li>\n<li>#if 条件表达式，用于更为复杂的条件编译判断</li>\n</ul>\n<p>为了便于统一处理，当处理#ifdef 和#ifndef时统一转换成#if defined() 和#if !defined()，并且抛弃#ifdef 和#ifndef后面的 &amp;&amp; 或者 || 的内容。进一步处理类似#if defined(ABCD) 和#if !defined(DCBA)时可以等价转化于#if (F_ABCD &#x3D;&#x3D; true) 和 #if !(F_DCBA &#x3D;&#x3D; true)给ABCD或DCBA加上前缀F_进行判断。考虑到在实际C编程中用#if 进行条件编译判断时可能出现未#define AAA的标识出现，所以在进行rust代码条件编译整个过程之前，需进行如下操作：</p>\n<ol>\n<li>利用我们的shell文件提取C中所有用于条件编译的符号，加上前缀F_保存到用户指定目标文件symbols.txt中，指令如下：.&#x2F;extract_symbols.sh -c scan_condition.c -o symbols.txt   </li>\n<li>然后提取C文件中所有#define 的符号，保存到用户的指定目标文件defsyb.txt中，指令如下：.&#x2F;extract_def.sh -c scan_condition.c -o defsyb.txt </li>\n<li>再通过将define过的符号设置true，未定义的符号设置为false，将这些符号作为bool变量保存起来，用于后续条件编译的判断，指令如下：. &#x2F;codename symbols.txt defsyb.txt</li>\n</ol>\n<p>至此，C中条件编译皆可转化为#if #elif #else此类形式的指令了，对于此种形式指令我们设计了如下rust声明宏进行替换：</p>\n<pre><code class=\"rust\">macro_rules! c_conditional &#123;\n    (if $condition:expr =&gt; &#123; $($if_block:tt)* &#125; $(else if $elif_condition:expr =&gt; &#123; \t\t\t$($elif_block:tt)* &#125;) $(else =&gt; &#123; $($else_block:tt)* &#125;)?)\n    =&gt; &#123;\n        if $condition &#123;\n            $($if_block)\n        &#125;\n        $(else if $elif_condition &#123;\n            $($elif_block)\n        &#125;)\n        $(else &#123;\n            $($else_block)\n        &#125;)?\n    &#125;;\n&#125;\n</code></pre>\n<p> 调用方法如下：</p>\n<pre><code class=\"rust\">c_conditional!(\n    if !(F_ABCD == true) =&gt; &#123; // some code\n        println!(&quot;F_ABCD is false&quot;);\n    &#125;\n    else if F_ABCD == true &amp;&amp; ABCD == 3 =&gt; &#123; // some code\n        println!(&quot;F_ABCD is true and ABCD is 3&quot;);\n    &#125;\n    else =&gt; &#123; // some code\n        println!(&quot;F_ABCD is true and ABCD is not 3&quot;);\n    &#125;\n);\n</code></pre>\n<p>同时支持条件编译的嵌套：</p>\n<pre><code class=\"rust\">c_conditional!(\n    if !(F_ABCD == true) =&gt; &#123; // some code\n        c_conditional!(\n            if !(F_ABCD == true) =&gt; &#123; // some code\n                println!(&quot;F_ABCD is false&quot;);\n            &#125;\n            else if F_ABCD == true &amp;&amp; ABCD == 3 =&gt; &#123; // some code\n                println!(&quot;F_ABCD is true and ABCD is 3&quot;);\n            &#125;\n            else =&gt; &#123; // some code\n                println!(&quot;F_ABCD is true and ABCD is not 3&quot;);\n            &#125;\n        );\n    &#125;\n    else if F_ABCD == true &amp;&amp; ABCD == 3 =&gt; &#123; // some code\n        println!(&quot;F_ABCD is true and ABCD is 3&quot;);\n    &#125;\n    else =&gt; &#123; // some code\n        println!(&quot;111&quot;);\n        c_conditional!(\n            if !(F_ABCD == true) =&gt; &#123; // some code\n                println!(&quot;F_ABCD is false&quot;);\n            &#125;\n            else if F_ABCD == true &amp;&amp; ABCD == 3 =&gt; &#123; // some code\n                println!(&quot;F_ABCD is true and ABCD is 3&quot;);\n            &#125;\n            else =&gt; &#123; // some code\n                println!(&quot;000000  F_ABCD is true and ABCD is not 3&quot;);\n            &#125;\n        );\n    &#125;\n);\n</code></pre>\n<p>关于C中的条件编译，常常使用一些操作系统或者其他一些环境相关的预定义宏作为条件编译判断的部分，如以下形式：</p>\n<pre><code class=\"c\">#ifdef __LINUX__\n    #include &quot;a.h&quot;\n      // some code\n#elif __WINDOWS__\n    #include &quot;b.h&quot;\n    // some code\n#else\n    // some code\n</code></pre>\n<p>关于此类情景，通过收集当前系统执行环境的环境变量，在进行整个C宏转化为Rust宏之前，就用define中的常量宏进行定义设置为true，后续再正常进行相关宏的替换操作。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在本文中我们提出了一种C语言自动转换为Rust语言的对应规则。该规则设计的关键点在于采用Rust声明宏完成C的替换文本宏和条件编译宏的对应，当编译器在编译代码时遇到使用声明宏的地方，它会根据声明宏的规则进行模式匹配，并将匹配的代码进行相应的替换，也即是声明宏的替换是在编译时进行的，而不是在运行时。通过对设计的相关声明宏模板进行单元测试，测试结果证明我们设计的对应规则是有效可行的。</p>\n",
            "tags": [
                "计算机科学",
                "C2Rust"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/04/25/computer-science/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/",
            "url": "https://hdqjl317.github.io/2023/04/25/computer-science/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/",
            "title": "Linux操作系统深入理解进程切换",
            "date_published": "2023-04-25T12:35:51.000Z",
            "content_html": "<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>当一个进程正在运行时触发系统调用或被中断，将进行中断上下文的切换，之后执行ISR中断服务，在中断处理结束后，使用_schedule()函数进行进程切换。</p>\n<p>schedule()函数首先从CPU任务队列中取出当前进程的标识符记为prev进程。然后通过进程调度算法确定下一个要被换上的进程，记为next进程。之后，检查next如果和prev进程不一样，调用context_switch()函数进行上下文切换，next进程进入CPU运行。</p>\n<p>在context_switch()中调用switch_to()进行寄存器和堆栈的切换，switch_to()会调用switch_to_asm()函数，在switch_to_asm()的中进行了从prev内核堆栈到next内核堆栈的切换，在最后不使用ret指令，而是通过jmp指令跳转到switch_to()函数，在switch_to()函数的结尾调用return返回，因为在switch_to_asm()中进行了堆栈的切换，因此_switch_to()返回后，回到的是next进程的内核堆栈，而不是prev进程的内核堆栈。</p>\n<h3 id=\"具体过程分析\"><a href=\"#具体过程分析\" class=\"headerlink\" title=\"具体过程分析\"></a>具体过程分析</h3><p>schedule()函数调用context_switch()函数进行上下文切换，在kernel&#x2F;sched&#x2F;core.c中查看函数的定义：</p>\n<pre><code class=\"c\">context_switch(struct rq *rq, struct task_struct *prev,\n           struct task_struct *next, struct rq_flags *rf)\n&#123;\n    prepare_task_switch(rq, prev, next);\n\n    arch_start_context_switch(prev);\n\n    if (!next-&gt;mm) &#123;                                // to kernel\n        enter_lazy_tlb(prev-&gt;active_mm, next);\n\n        next-&gt;active_mm = prev-&gt;active_mm;\n        if (prev-&gt;mm)                           // from user\n            mmgrab(prev-&gt;active_mm);\n        else\n            prev-&gt;active_mm = NULL;\n    &#125; else &#123;                                        // to user\n        membarrier_switch_mm(rq, prev-&gt;active_mm, next-&gt;mm);\n        switch_mm_irqs_off(prev-&gt;active_mm, next-&gt;mm, next);\n\n        if (!prev-&gt;mm) &#123;                        // from kernel\n            /* will mmdrop() in finish_task_switch(). */\n            rq-&gt;prev_mm = prev-&gt;active_mm;\n            prev-&gt;active_mm = NULL;\n        &#125;\n    &#125;\n\n    rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\n    prepare_lock_switch(rq, next, rf);\n\n    switch_to(prev, next, prev);\n    barrier();\n\n    return finish_task_switch(prev);\n&#125;\n</code></pre>\n<p>content_switch 函数有三个参数：rq、prev、next，其中 rq 指向本次进程切换发生的 running queue(进程就绪队列)；prev 和 next 分别指向切换前后进程的进程描述符。实现的功能如下：</p>\n<ul>\n<li>在进程切换之前调用prepare_task_switch()，然后内核会执行与体系结构相关的一些调测指令，该函数和 finish_task_switch()成对出现，表示完成上下文的切换。</li>\n<li>arch_start_context_switch()给各个体系结构专有的开始上下文切换的工作提供入口</li>\n<li>完成进程地址空间的切换。这里通过判断一个 task_struct 的 mm 成员是否为空来判断它是一个用户进程还是内核级线程，为内核级线程则调用enter_lazy_tlb()。</li>\n<li>调用switch_to()切换寄存器状态和栈，swtich_to 函数会进一步调用 __switch_to_asm()</li>\n</ul>\n<p>__switch_to_asm()实现是与体系结构相关的，这里我们先以X86_64为例进行分析：</p>\n<pre><code class=\"assembly\">ENTRY(__switch_to_asm)\n  UNWIND_HINT_FUNC\n  /*\n   * Save callee-saved registers\n   * This must match the order in inactive_task_frame\n   */\n  pushq  %rbp\n  pushq  %rbx\n  pushq  %r12\n  pushq  %r13\n  pushq  %r14\n  pushq  %r15\n\n  /* switch stack */\n  movq  %rsp, TASK_threadsp(%rdi) // 保存旧进程的栈顶\n  movq  TASK_threadsp(%rsi), %rsp // 恢复新进程的栈顶\n\n  /* restore callee-saved registers */\n  popq  %r15\n  popq  %r14\n  popq  %r13\n  popq  %r12\n  popq  %rbx\n  popq  %rbp\n\n  jmp  __switch_to\nEND(__switch_to_asm)\n</code></pre>\n<p>两条 movq 语句就是新旧进程的分界线，随着内核栈顶的切换，内核栈空间也就切换到了新进程，之后只需要弹出栈中保存的各个寄存器的值即可恢复寄存器状态。将__switch_to_asm和switch_to结合起来，发现是call指令和ret指令的配对出现。call指令压栈RIP寄存器到进程切换前的prev进程内核堆栈，而ret指令出栈存入RIP寄存器的是进程切换之后的next进程的内核堆栈栈顶数据，所以 ret 恢复的就是 next 进程内核堆栈中的 rip 值，即实现了 rip 值的保存与修改。</p>\n<p>再看一下arm64架构下__switch_to_asm()的实现 ，其过程就是保存和恢复cpu_context 结构体，在arm中其函数和宏调用过程：switch_to -&gt; switch_to -&gt; cpu_switch_to，具体的切换发生在cpu_switch_to中其代码如下：</p>\n<pre><code class=\"assembly\">ENTRY(cpu_switch_to) \t\t\t\n    mov\tx10, #THREAD_CPU_CONTEXT \t// 寄存器x10存放thread.cpu_context偏移\n    add\tx8, x0, x10 \t\t\t\t// x0与偏移量相加后存入x8，获取旧进程cpu_context的地址\n    mov\tx9, sp \t\t\t\t\t\t// 将栈顶指针sp保存在x9寄存器\n    stp\tx19, x20, [x8], #16\t\t\t// 将寄存器x19～x29保存，保存现场\n    stp\tx21, x22, [x8], #16\n    stp\tx23, x24, [x8], #16\n    stp\tx25, x26, [x8], #16\n    stp\tx27, x28, [x8], #16\n    stp\tx29, x9, [x8], #16 //x29是frame pointer，x9是stack pointer，lr是pc值\n    str\tlr, [x8]\n    \n    add\tx8, x1, x10 \t\t\t\t// 获取访问next进程的cpu_context的指针\n    ldp\tx19, x20, [x8], #16\t\t\t// 恢复next进程的现场\n    ldp\tx21, x22, [x8], #16\n    ldp\tx23, x24, [x8], #16\n    ldp\tx25, x26, [x8], #16\n    ldp\tx27, x28, [x8], #16\n    ldp\tx29, x9, [x8], #16\n    ldr\tlr, [x8]\n    mov\tsp, x9\t\n    msr\tsp_el0, x1\n    \n    ret\t\t\t \t\t\t\t\t// 此时ret将next进程的lr寄存器的值加载到PC，进程切换完毕\nENDPROC(cpu_switch_to)\nNOKPROBE(cpu_switch_to)\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "Linux"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/04/25/computer-science/c2rust%E5%AE%8F%E6%8C%87%E4%BB%A4%E8%BD%AC%E5%8C%96%E8%A7%84%E5%88%992/",
            "url": "https://hdqjl317.github.io/2023/04/25/computer-science/c2rust%E5%AE%8F%E6%8C%87%E4%BB%A4%E8%BD%AC%E5%8C%96%E8%A7%84%E5%88%992/",
            "title": "c2rust宏指令转化规则2",
            "date_published": "2023-04-25T12:28:21.000Z",
            "content_html": "<p>c2rust条件编译转化对应的实际例子：</p>\n<pre><code class=\"c\">// C\n#ifdef ABCD\n    printf(&quot;1: yes\\n&quot;);\n#else\n    printf(&quot;1: no\\n&quot;);\n#endif\n\n#ifndef ABCD\n    printf(&quot;2: no1\\n&quot;);\n#elif ABCD == 2\n    printf(&quot;2: yes\\n&quot;);\n#else\n    printf(&quot;2: no2\\n&quot;);\n#endif\n\n\n// Rust example\nmy_def!(F_ABCD: bool, true);\nmy_def!(ABCD: i32, 1);\nmy_def!(F_DCBA: bool, true);\nmy_def!(DCBA: i32, 2);       \n/*\n#ifdef ABCD    \n    &#123;&#125;\n#else\n    &#123;&#125;\n*/\ncfg_if::cfg_if! &#123;\n    if F_ABCD == true &#123;\n        // specific code\n    &#125; else &#123;\n        // generic code\n    &#125;\n&#125;\n/*\n#ifdef ABCD \n    &#123;&#125;\n#elif ABCD == 3\n    &#123;&#125;\n#else\n    &#123;&#125;\n*/     \ncfg_if::cfg_if! &#123;\n    if F_ABCD == true  &#123;\n        // some code\n    &#125; else if F_ABCD == true &amp;&amp; ABCD == 3 &#123;\n        // some code\n    &#125; else &#123;\n        // some code\n    &#125;\n&#125;\n/*     \n#if  define(ABCD) &amp;&amp; ABCD == 1 || DCBA == 2\n    &#123;&#125;\n#else\n    &#123;&#125;\n*/ \ncfg_if::cfg_if! &#123;\n    if F_ABCD == true &amp;&amp; ABCD == 1 || F_DCBA == true &amp;&amp; DCBA == 2 &#123;\n        // some code\n    &#125; else &#123;\n        // some code\n    &#125;\n&#125;\n/*     \n#if  !define(DDD) &amp;&amp; ABCD == 1 || DCBA == 2\n    &#123;&#125;\n#elif DCBA == 3 \n    &#123;&#125;\n#else\n    &#123;&#125;\n*/ \ncfg_if::cfg_if! &#123;\n    if !(F_DDD == true) &amp;&amp; F_ABCD == true &amp;&amp; ABCD == 1 || F_DCBA == true &amp;&amp; DCBA == 2 &#123;\n        // some code\n    &#125; else if F_DCBA == true &amp;&amp; DCBA == 3 &#123;\n        // some code\n    &#125; else &#123;\n        // some code\n    &#125;\n&#125;\n                \n/*\n#ifndef ABCD\n    &#123;&#125;\n#else\n    &#123;&#125;\n*/\ncfg_if::cfg_if! &#123;\n    if !(F_ABCD == true) &#123;\n        // some code\n    &#125; else &#123;\n        // some code\n    &#125;\n&#125;\n/*\n#ifndef ABCD \n    &#123;&#125;\n#elif ABCD == 3\n    &#123;&#125;\n#else\n    &#123;&#125;\n*/ \ncfg_if::cfg_if! &#123;\n    if !(F_ABCD == true) &#123;\n        // some code\n    &#125; else if F_ABCD == true &amp;&amp; ABCD == 3 &#123;\n        // some code\n    &#125; else &#123;\n        // some code\n    &#125;\n&#125;\n// “#ifdef 标识符”与“#if defined 标识符”实质上等价。\n// “#ifndef 标识符”与“#if !defined 标识符”实质上等价。\n</code></pre>\n<p>声明宏c_conditional用于rust条件编译的选择，结合rust常量宏的定义方法进行条件编译：</p>\n<pre><code class=\"rust\">// Rust\nmy_def!(MAX_SIZE: i32, 1024);\nmy_def!(MY_STR: &amp;&#39;static str, &quot;root/api/&quot;);\nmy_def!(MYTY, i32);\nmy_def!(MYNIL: bool, true);\n</code></pre>\n<p>声明宏c_conditional具体的定义及使用示例：</p>\n<pre><code class=\"rust\">#[macro_export]\nmacro_rules! c_conditional &#123;\n    (if $condition:expr =&gt; &#123; $($if_block:tt)* &#125; $(else if $elif_condition:expr =&gt; &#123; $($elif_block:tt)* &#125;)* $(else =&gt; &#123; $($else_block:tt)* &#125;)?) =&gt; &#123;\n        if $condition &#123;\n            $($if_block)*\n        &#125; \n        $(else if $elif_condition &#123;\n            $($elif_block)*\n        &#125;)*\n        $(else &#123;\n            $($else_block)*\n        &#125;)?\n    &#125;;\n&#125;\n\n// 定义一些变量\nconst F_ABCD: bool = true;\nconst ABCD: i32 = 1;\nconst F_DCBA: bool = true;\nconst DCBA: i32 = 2;\nconst F_DDD: bool = false;\n\n// 定义一个测试函数，用于测试声明宏\nfn test_macro() &#123;\n    c_conditional!(\n        if F_ABCD == true =&gt; &#123; // specific code\n            println!(&quot;F_ABCD is true&quot;);\n        &#125;\n        else =&gt; &#123; // generic code\n            println!(&quot;F_ABCD is false&quot;);\n        &#125;\n    );\n    \n    c_conditional!(\n        if !(F_DCBA == true) =&gt; &#123; // some code\n            println!(&quot;F_DCBA is false&quot;);\n        &#125;\n        else if F_ABCD == true &amp;&amp; ABCD == 3 =&gt; &#123; // some code\n            println!(&quot;F_ABCD is true and ABCD is 3&quot;);\n        &#125;\n        else =&gt; &#123; // some code\n            println!(&quot;F_ABCD is true but ABCD is not 3&quot;);\n        &#125;\n    );\n    \n    c_conditional!(\n        if F_ABCD == true &amp;&amp; ABCD == 1 || F_DCBA == true &amp;&amp; DCBA == 2 =&gt; &#123; // some code\n            println!(&quot;F_ABCD is true and ABCD is 1 or F_DCBA is true and DCBA is 2&quot;);\n        &#125;\n        else =&gt; &#123; // some code\n            println!(&quot;F_ABCD is false or ABCD is not 1 and F_DCBA is false or DCBA is not 2&quot;);\n        &#125;\n    );\n    \n    c_conditional!(\n        if !(F_DDD == true) &amp;&amp; F_ABCD == true &amp;&amp; ABCD == 1 || F_DCBA == true &amp;&amp; DCBA == 2 =&gt; &#123; // some code\n            println!(&quot;F_DDD is false and F_ABCD is true and ABCD is 1 or F_DCBA is true and DCBA is 2&quot;);\n        &#125;\n        else if F_DCBA == true &amp;&amp; DCBA == 3 =&gt; &#123; // some code\n            println!(&quot;F_DDD is false and F_DCBA is true and DCBA is 3&quot;);\n        &#125;\n        else =&gt; &#123; // some code\n            println!(&quot;F_DDD is true or F_ABCD is false or ABCD is not 1 and F_DCBA is false or DCBA is not 2 or 3&quot;);\n        &#125;\n    );\n    \n    c_conditional!(\n        if !(F_ABCD == true) =&gt; &#123; // some code\n            println!(&quot;F_ABCD is false&quot;);\n        &#125;\n        else if F_ABCD == true &amp;&amp; ABCD == 3 =&gt; &#123; // some code\n            println!(&quot;F_ABCD is true and ABCD is 3&quot;);\n        &#125;\n        else =&gt; &#123; // some code\n            println!(&quot;F_ABCD is true and ABCD is not 3&quot;);\n        &#125;\n    );\n\n    c_conditional!(\n        if !(F_ABCD == true) =&gt; &#123; // some code\n            c_conditional!(\n                if !(F_ABCD == true) =&gt; &#123; // some code\n                    println!(&quot;F_ABCD is false&quot;);\n                &#125;\n                else if F_ABCD == true &amp;&amp; ABCD == 3 =&gt; &#123; // some code\n                    println!(&quot;F_ABCD is true and ABCD is 3&quot;);\n                &#125;\n                else =&gt; &#123; // some code\n                    println!(&quot;F_ABCD is true and ABCD is not 3&quot;);\n                &#125;\n            );\n        &#125;\n        else if F_ABCD == true &amp;&amp; ABCD == 3 =&gt; &#123; // some code\n            println!(&quot;F_ABCD is true and ABCD is 3&quot;);\n        &#125;\n        else =&gt; &#123; // some code\n            println!(&quot;111&quot;);\n            c_conditional!(\n                if !(F_ABCD == true) =&gt; &#123; // some code\n                    println!(&quot;F_ABCD is false&quot;);\n                &#125;\n                else if F_ABCD == true &amp;&amp; ABCD == 3 =&gt; &#123; // some code\n                    println!(&quot;F_ABCD is true and ABCD is 3&quot;);\n                &#125;\n                else =&gt; &#123; // some code\n                    println!(&quot;000000   F_ABCD is true and ABCD is not 3&quot;);\n                &#125;\n            );\n        &#125;\n    );\n&#125;\n\n// main 函数\nfn main() &#123;\n    test_macro();\n&#125;\n\n/*输出\nF_ABCD is true\nF_ABCD is true but ABCD is not 3\nF_ABCD is true and ABCD is 1 or F_DCBA is true and DCBA is 2\nF_DDD is false and F_ABCD is true and ABCD is 1 or F_DCBA is true and DCBA is 2\nF_ABCD is true and ABCD is not 3\n111\n000000   F_ABCD is true and ABCD is not 3\n*/\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "C2Rust"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/04/25/computer-science/c2rust%E5%AE%8F%E6%8C%87%E4%BB%A4%E8%BD%AC%E5%8C%96%E8%A7%84%E5%88%991/",
            "url": "https://hdqjl317.github.io/2023/04/25/computer-science/c2rust%E5%AE%8F%E6%8C%87%E4%BB%A4%E8%BD%AC%E5%8C%96%E8%A7%84%E5%88%991/",
            "title": "c2rust宏指令转化规则1",
            "date_published": "2023-04-25T12:24:23.000Z",
            "content_html": "<h3 id=\"常量宏\"><a href=\"#常量宏\" class=\"headerlink\" title=\"常量宏\"></a>常量宏</h3><p>C中常量宏的四种使用方式：</p>\n<pre><code>#define MAX_SIZE 1024\n#define MY_STR &quot;root/api/&quot;\n#define MYTY int\n#define MYNIL\n</code></pre>\n<p>以下是对应的Rust版本的处理方案：</p>\n<pre><code class=\"rust\">macro_rules! my_def &#123;\n    ($name: ident : $ty: ty, $value: expr) =&gt; &#123;\n        #[allow(non_upper_case_globals)]\n        pub const $name: $ty = $value;\n    &#125;;\n    ($name: ident, $ty: ty) =&gt; &#123;\n        #[allow(non_camel_case_types)]\n        pub type $name = *mut $ty;\n    &#125;;\n&#125;\n\nmy_def!(MAX_SIZE: i32, 1024);\nmy_def!(MY_STR: &amp;&#39;static str, &quot;root/api/&quot;);\nmy_def!(MYTY, i32);\nmy_def!(MYNIL: bool, true);\n\nfn main() &#123;\n    let num = MAX_SIZE;\n    println!(&quot;MAX_SIZE = &#123;&#125;&quot;, num);\n\n    let mystr = MY_STR;\n    let user = MY_STR.to_owned() + &quot;jiale/&quot;;\n    println!(&quot;MY_STR = &#123;&#125;, user = &#123;&#125;&quot;, mystr, user);\n\n    let jude = MYNIL;\n    if jude == true &#123;\n        println!(&quot;This is MYNIL.&quot;);\n    &#125;\n\n    let mut x: i32 = 42;\n    let p: MYTY = &amp;mut x;\n    unsafe &#123;\n        *p = 123;\n        println!(&quot;x = &#123;&#125;&quot;, x); // 输出 x = 123\n    &#125;\n&#125;\n\n/*\n输出：\nMAX_SIZE = 1024\nMY_STR = root/api/, user = root/api/jiale/\nThis is MYNIL.\nx = 123\n*/\n</code></pre>\n<h3 id=\"语句宏和函数宏\"><a href=\"#语句宏和函数宏\" class=\"headerlink\" title=\"语句宏和函数宏\"></a>语句宏和函数宏</h3><pre><code class=\"rust\">macro_rules! function_macro &#123;\n    (\n        $(#[$attr:meta])*\n        $vis:vis fn $name:ident ( $( $arg:ident : $t:ty ),* ) -&gt; $ret:ty &#123;\n            $($body:tt)*\n        &#125;\n    ) =&gt; &#123;\n        $(#[$attr])*\n        $vis fn $name ( $( $arg : $t ),* ) -&gt; $ret &#123;\n            $($body)*\n        &#125;\n    &#125;;\n&#125;\nfunction_macro!(\n    pub fn add(a: i32, b: i32) -&gt; i32 &#123;\n        a + b\n    &#125;\n);\nfunction_macro!(\n    pub fn myprint(a: i32, b: i32) -&gt; i32 &#123;\n        println!(&quot;&#123;&#125;&quot;, a*b);\n        a*b\n    &#125;\n);\nfunction_macro!(\n    pub fn mymax(a: i32, b: i32) -&gt; i32 &#123;\n        if a &gt; b &#123;\n            a\n        &#125; else &#123;\n            b\n        &#125;\n    &#125;\n);\nfunction_macro!(\n    pub fn mytotal(a: i32, b: i32) -&gt; i32 &#123;\n        let mut sum = 0;\n        for i in a..=b &#123;\n            sum += i;\n        &#125;\n        sum\n    &#125;\n);\nfunction_macro! &#123;\n    pub fn factorial(n: u64) -&gt; u64 &#123;\n        if n &lt;= 1 &#123;\n            1\n        &#125; else &#123;\n            n * factorial(n - 1)\n        &#125;\n    &#125;\n&#125;\n\nfn main() &#123;\n    let a = 1;\n    let b = 2;\n    let c = add(a, b);\n    println!(&quot;&#123;&#125;&quot;, c);\n\n    let d = myprint(a,b);\n    println!(&quot;a * b = &#123;&#125;&quot;, d);\n\n    let maxnum = mymax(1,2);\n    println!(&quot;maxnum = &#123;&#125;&quot;, maxnum);\n\n    let total = mytotal(1,10);\n    println!(&quot;total = &#123;&#125;&quot;, total);\n\n    let result = factorial(5);\n    println!(&quot;5! = &#123;&#125;&quot;, result); \n&#125;\n\n/*\n输出：\n3\n2\na * b = 2\nmaxnum = 2\ntotal = 55\n5! = 120\n*/\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "C2Rust"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/04/02/computer-science/Rust%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90/",
            "url": "https://hdqjl317.github.io/2023/04/02/computer-science/Rust%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90/",
            "title": "Rust声明宏的一些例子",
            "date_published": "2023-04-02T12:42:08.000Z",
            "content_html": "<p>eg1:</p>\n<pre><code class=\"rust\">macro_rules! my_macro &#123;\n    // 定义宏函数\n    ($arg1:expr, $arg2:expr) =&gt; &#123;\n        // 定义宏函数体，此处为求两个参数的和\n        ($arg1) + ($arg2)\n    &#125;;\n&#125;\n\nfn main() &#123;\n    // 调用宏函数\n    let x = my_macro!(1, 2);\n    println!(&quot;&#123;&#125;&quot;, x);  // 输出 &quot;3&quot;\n&#125;\n</code></pre>\n<p>eg2:</p>\n<pre><code class=\"rust\">macro_rules! c_max &#123;\n    ($x:expr, $y:expr) =&gt; &#123;\n        if $x &gt; $y &#123;\n            $x\n        &#125; else &#123;\n            $y\n        &#125;\n    &#125;;\n&#125;\n\nfn main() &#123;\n    let a = 3;\n    let b = 5;\n    let max = c_max!(a, b);\n    println!(&quot;The max value is &#123;&#125;&quot;, max);\n&#125;\n</code></pre>\n<p>eg3:</p>\n<pre><code class=\"rust\">macro_rules! SQUARE &#123;\n    ($x:expr) =&gt; &#123;\n        ($x) * ($x)\n    &#125;;\n&#125;\n\nfn main() &#123;\n    let x = 2;\n    let result = SQUARE!(x + x);\n    println!(&quot;The square of &#123;&#125; is &#123;&#125;&quot;, x + x, result);\n&#125;\n</code></pre>\n<p>eg4:</p>\n<pre><code class=\"rust\">macro_rules! print_fmt &#123;\n    ($fmt:expr) =&gt; (print!(&quot;&#123;&#125;&quot;, $fmt));\n    ($fmt:expr, $($arg:tt)*) =&gt; (print_fmt_args!($fmt, $($arg)*));\n&#125;\n\nmacro_rules! print_fmt_args &#123;\n    ($fmt:expr, $($arg:tt)*) =&gt; &#123;&#123;\n        #[cfg(target_os = \"linux\")]\n        &#123;\n            print!($fmt, $($arg)*);\n        &#125;\n\n        #[cfg(target_os = \"windows\")]\n        &#123;\n            use std::os::windows::raw::c_int;\n            extern \"system\" &#123;\n                fn printf(_: *const i8, ...) -> c_int;\n            &#125;\n\n            let c_str = std::ffi::CString::new($fmt).unwrap();\n            unsafe &#123; printf(c_str.as_ptr(), $($arg)*) &#125;;\n        &#125;\n    &#125;&#125;;\n&#125;\n\nfn main() &#123;\n    let name = &quot;Rust&quot;;\n    let age = 5;\n    let pi = 3.14159;\n\n    print_fmt!(&quot;Hello, my name is &#123;&#125; and I&#39;m &#123;&#125; years old. PI is &#123;:.2&#125;\\n&quot;, name, age, pi);\n&#125;\n</code></pre>\n<p>exp5:</p>\n<p>这个例子是一个使用 Rust 声明宏来实现一个简单的链表的例子。这个宏叫做 <code>list!</code>，它可以帮助我们生成一个链表。这个宏支持三种不同的用法：</p>\n<ol>\n<li><code>list!()</code>：生成一个空链表（<code>Nil</code>）；</li>\n<li><code>list!(expr)</code>：生成一个只有一个元素的链表，元素的值为 <code>expr</code>；</li>\n<li><code>list!(expr1, expr2, ..., exprn)</code>：生成一个包含多个元素的链表，元素的值分别为 <code>expr1</code> 到 <code>exprn</code>。</li>\n</ol>\n<p>在这个例子中，我们使用了 <code>Box</code> 来实现链表的尾部指针，以避免使用递归结构导致的栈溢出问题。</p>\n<pre><code class=\"rust\">macro_rules! list &#123;\n    () =&gt; &#123;\n        Nil\n    &#125;;\n    ($e:expr) =&gt; &#123;\n        Cons($e, Box::new(Nil))\n    &#125;;\n    ($e:expr, $($tail:tt)*) =&gt; &#123;&#123;\n        let tail = list!($($tail)*);\n        Cons($e, Box::new(tail))\n    &#125;&#125;;\n&#125;\n\nenum List &#123;\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n&#125;\n\nfn main() &#123;\n    let list = list![1, 2, 3];\n    println!(&quot;&#123;:?&#125;&quot;, list);\n&#125;\n</code></pre>\n<p>exp6:</p>\n<p>这个例子实现了一个计算平均数的宏，可以接受任意数量的参数，忽略空值，计算非空值的平均值并返回。宏使用了 Rust 的模式匹配语法，同时也用到了 Rust 的闭包和类型推导等特性。</p>\n<pre><code class=\"rust\">macro_rules! calculate &#123;\n    ($($args:tt)*) =&gt; &#123;&#123;\n        let mut sum = 0;\n        let mut count = 0;\n        $(\n            if let Some(val) = $args &#123;\n                sum += val;\n                count += 1;\n            &#125;\n        )*\n        if count > 0 &#123;\n            Some(sum / count)\n        &#125; else &#123;\n            None\n        &#125;\n    &#125;&#125;;\n&#125;\n\nfn main() &#123;\n    let result = calculate!(Some(10), None, Some(20), Some(30), None, Some(40));\n    println!(&quot;&#123;:?&#125;&quot;, result);\n&#125;\n</code></pre>\n<p>exp7:</p>\n<p>这个宏定义了一个结构体和一组方法，其中方法可以有不同的参数和返回值。通过使用宏规则中的 <code>$($method:ident ($($param:ident : $type:ty),*) -&gt; $ret:ty)*</code>，可以将方法名称、参数列表和返回值类型分别提取出来，然后使用嵌套的宏规则实现方法的实现。这个例子相比之前的例子更加复杂，宏规则中涉及到了宏的嵌套、可变参数和泛型类型等高级特性。</p>\n<pre><code class=\"rust\">macro_rules! define_struct_and_methods &#123;\n    ($name:ident, $field:ident, $($method:ident ($($param:ident : $type:ty),*) -&gt; $ret:ty)*) =&gt; &#123;\n        struct $name &#123;\n            $field: i32,\n        &#125;\n        \n        impl $name &#123;\n            fn new($field: i32) -&gt; Self &#123;\n                $name &#123; $field &#125;\n            &#125;\n            $($(\n            fn $method(&amp;self, $($param : $type),*) -&gt; $ret &#123;\n                // method implementation here\n            &#125;\n            )*)*\n        &#125;\n    &#125;;\n&#125;\n\ndefine_struct_and_methods!(\n    MyStruct, \n    my_field, \n    method1() -&gt; i32, \n    method2(x: i32) -&gt; bool, \n    method3(x: i32, y: i32) -&gt; String\n);\n</code></pre>\n<p>exp8:</p>\n<p>这是一个用于生成哈希映射的声明宏。这个宏可以接受 1 个或多个键值对参数，每个键值对之间使用逗号分隔，键和值之间使用 <code>=&gt;</code> 分隔。</p>\n<p>这个宏会生成一个 <code>HashMap</code>，其中包含三个键值对。如果调用时只传入一个参数，则该参数必须是偶数个，因为每个键都必须有一个对应的值。如果键或值是表达式，则需要用括号将它们括起来。</p>\n<p>这个宏的实现使用了 Rust 中的 <code>std::collections::HashMap</code>，并且使用了一些比较复杂的宏技巧来计算参数个数，并生成一个指定容量的哈希映射。</p>\n<pre><code class=\"rust\">macro_rules! map &#123;\n    (@single $($x:tt)*) =&gt; (());\n    (@count $($rest:expr),*) =&gt; (&lt;[()]&gt;::len(&amp;[$(map!(@single $rest)),*]));\n    ($($key:expr =&gt; $value:expr,)+) =&gt; &#123; map!($($key =&gt; $value),+) &#125;;\n    ($($key:expr =&gt; $value:expr),*) =&gt; &#123;\n        &#123;\n            let _cap = map!(@count $($key),*);\n            let mut _map = ::std::collections::HashMap::with_capacity(_cap);\n            $(\n                let _ = _map.insert($key, $value);\n            )*\n            _map\n        &#125;\n    &#125;;\n&#125;\n\nlet m = map! &#123;\n    &quot;a&quot; =&gt; 1,\n    &quot;b&quot; =&gt; 2,\n    &quot;c&quot; =&gt; 3,\n&#125;;\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "C2Rust"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/04/02/computer-science/Rust%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/",
            "url": "https://hdqjl317.github.io/2023/04/02/computer-science/Rust%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/",
            "title": "Rust条件编译",
            "date_published": "2023-04-02T12:41:05.000Z",
            "content_html": "<h1 id=\"Rust条件编译\"><a href=\"#Rust条件编译\" class=\"headerlink\" title=\"Rust条件编译\"></a>Rust条件编译</h1><p>下面是一个简单的 Rust 条件编译的例子，它展示了如何使用 <code>cfg</code> 属性来选择在哪个平台上编译代码。</p>\n<pre><code class=\"rust\">#[cfg(target_os = &quot;windows&quot;)]\nfn main() &#123;\n    println!(&quot;This is Windows.&quot;);\n&#125;\n\n#[cfg(target_os = &quot;linux&quot;)]\nfn main() &#123;\n    println!(&quot;This is Linux.&quot;);\n&#125;\n\n#[cfg(not(any(target_os = &quot;windows&quot;, target_os = &quot;linux&quot;)))]\nfn main() &#123;\n    println!(&quot;This is neither Windows nor Linux.&quot;);\n&#125;\n</code></pre>\n<p>下面使用了 <code>any</code>、<code>not</code>、<code>all</code> 三个关键字，分别表示“任意一个特性被启用”、“没有任何一个特性被启用”、“所有特性都被启用”等条件。这个例子可以根据不同的特性组合打印出不同的信息，可以在编译时根据需要指定不同的特性来编译程序。</p>\n<pre><code class=\"rust\">fn main() &#123;\n    #[cfg(any(feature = &quot;foo&quot;, feature = &quot;bar&quot;))]\n    println!(&quot;Foo or Bar feature is enabled&quot;);\n\n    #[cfg(not(any(feature = &quot;foo&quot;, feature = &quot;bar&quot;)))]\n    println!(&quot;Neither Foo nor Bar feature is enabled&quot;);\n\n    #[cfg(all(feature = &quot;foo&quot;, not(feature = &quot;bar&quot;)))]\n    println!(&quot;Only Foo feature is enabled&quot;);\n\n    #[cfg(all(not(feature = &quot;foo&quot;), feature = &quot;bar&quot;))]\n    println!(&quot;Only Bar feature is enabled&quot;);\n&#125;\n</code></pre>\n<p>这个例子展示了如何使用<code>#[cfg]</code>属性来针对不同的平台和条件进行条件编译。这个程序输出当前系统的操作系统名称，架构，指针位数和调试模式状态。<code>#[cfg]</code>属性还支持逻辑运算符，使得可以更灵活地控制编译时执行的代码块。</p>\n<pre><code class=\"rust\">fn main() &#123;\n    #[cfg(target_os = &quot;windows&quot;)]\n    println!(&quot;This is Windows.&quot;);\n\n    #[cfg(target_os = &quot;macos&quot;)]\n    println!(&quot;This is macOS.&quot;);\n\n    #[cfg(target_os = &quot;linux&quot;)]\n    println!(&quot;This is Linux.&quot;);\n\n    #[cfg(all(target_arch = &quot;x86_64&quot;, target_os = &quot;linux&quot;))]\n    println!(&quot;This is a 64-bit Linux system.&quot;);\n\n    #[cfg(any(target_arch = &quot;arm&quot;, target_arch = &quot;aarch64&quot;))]\n    println!(&quot;This is an ARM system.&quot;);\n\n    #[cfg(target_pointer_width = &quot;32&quot;)]\n    println!(&quot;This is a 32-bit system.&quot;);\n\n    #[cfg(target_pointer_width = &quot;64&quot;)]\n    println!(&quot;This is a 64-bit system.&quot;);\n\n    #[cfg(debug_assertions)]\n    println!(&quot;Debug mode is on.&quot;);\n\n    #[cfg(not(debug_assertions))]\n    println!(&quot;Debug mode is off.&quot;);\n&#125;\n</code></pre>\n<p>下面这个例子根据不同的平台选择不同的实现，其中：</p>\n<ul>\n<li><code>#[cfg(any(unix, windows))]</code> 表示只有在 Unix 或者 Windows 平台才编译这个模块；</li>\n<li><code>#[cfg_attr(all(unix, not(target_os = &quot;macos&quot;)), path = &quot;platforms/linux.rs&quot;)]</code> 表示如果是 Linux 平台则使用 <code>platforms/linux.rs</code> 文件，否则跳过；</li>\n<li><code>#[cfg_attr(all(unix, target_os = &quot;macos&quot;), path = &quot;platforms/macos.rs&quot;)]</code> 表示如果是 macOS 平台则使用 <code>platforms/macos.rs</code> 文件，否则跳过；</li>\n<li><code>#[cfg(windows)]</code> 表示如果是 Windows 平台则使用 <code>platforms/windows.rs</code> 文件；</li>\n<li><code>mod platform;</code> 表示引入 <code>platform</code> 模块，实际上会根据条件编译的结果选择不同的实现文件。</li>\n</ul>\n<p>这个例子比之前的例子更加复杂，它涉及到了多个条件的判断，以及根据条件选择不同的文件进行编译。</p>\n<pre><code class=\"rust\">#[cfg(any(unix, windows))]\n#[cfg_attr(\n    all(unix, not(target_os = &quot;macos&quot;)),\n    path = &quot;platforms/linux.rs&quot;\n)]\n#[cfg_attr(\n    all(unix, target_os = &quot;macos&quot;),\n    path = &quot;platforms/macos.rs&quot;\n)]\n#[cfg(windows)]\n#[path = &quot;platforms/windows.rs&quot;]\nmod platform;\n</code></pre>\n<p>下面是一个使用<code>#[cfg_attr]</code>属性的例子：</p>\n<p>在这个例子中，<code>#[cfg_attr(debug_assertions, allow(dead_code))]</code>指定了在debug模式下允许未使用的函数。另外，根据不同的目标架构，使用了不同的代码。如果目标架构是x86_64，则<code>let x = 42</code>语句会被编译，如果是aarch64，则<code>let x = 0</code>语句会被编译。在实际编译时，根据条件会为代码添加不同的属性。</p>\n<pre><code class=\"rust\">#[cfg_attr(debug_assertions, allow(dead_code))]\nfn foo() &#123;\n    #[cfg(target_arch = &quot;x86_64&quot;)]\n    let x = 42;\n    #[cfg(target_arch = &quot;aarch64&quot;)]\n    let x = 0;\n    println!(&quot;x = &#123;&#125;&quot;, x);\n&#125;\n</code></pre>\n<p>在下面的例子中，<code>foo</code> 函数只有在 <code>foo</code> 特性启用时才会编译。<code>bar_or_baz</code> 函数只有在 <code>bar</code> 或 <code>baz</code> 两个特性之一启用时才会编译，并使用了 <code>cfg!(...)</code> 宏来检查当前是否启用了 <code>bar</code> 特性。<code>qux_without_baz</code> 函数只有在 <code>qux</code> 特性启用且 <code>baz</code> 特性未启用时才会编译。最后，<code>no_features_enabled</code> 函数只有在没有任何特性启用时才会编译。</p>\n<p>你可以根据需要调整特性的名称和条件来满足你的要求。</p>\n<pre><code class=\"rust\">#[cfg(feature = &quot;foo&quot;)]\nfn foo() &#123;\n    println!(&quot;foo feature enabled&quot;);\n&#125;\n\n#[cfg(any(feature = &quot;bar&quot;, feature = &quot;baz&quot;))]\nfn bar_or_baz() &#123;\n    if cfg!(feature = &quot;bar&quot;) &#123;\n        println!(&quot;bar feature enabled&quot;);\n    &#125; else &#123;\n        println!(&quot;baz feature enabled&quot;);\n    &#125;\n&#125;\n\n#[cfg(all(feature = &quot;qux&quot;, not(feature = &quot;baz&quot;)))]\nfn qux_without_baz() &#123;\n    println!(&quot;qux feature enabled, but baz is not enabled&quot;);\n&#125;\n\n#[cfg(not(any(feature = &quot;foo&quot;, feature = &quot;bar&quot;, feature = &quot;baz&quot;, feature = &quot;qux&quot;)))]\nfn no_features_enabled() &#123;\n    println!(&quot;No features enabled&quot;);\n&#125;\n\nfn main() &#123;\n    foo();\n    bar_or_baz();\n    qux_without_baz();\n    no_features_enabled();\n&#125;\n</code></pre>\n<p>还可以通过结合其他宏实现更复杂的条件编译。以下是一个稍微复杂一些的例子：</p>\n<pre><code class=\"rust\">macro_rules! debug_println &#123;\n    () =&gt; &#123;&#125;;\n    ($($args:expr),*) =&gt; &#123;\n        #[cfg(feature = &quot;debug_print&quot;)]\n        &#123;\n            println!(&quot;[DEBUG] &#123;&#125;&quot;, format_args!($($args),*));\n        &#125;\n    &#125;;\n&#125;\n\nmacro_rules! error_println &#123;\n    () =&gt; &#123;&#125;;\n    ($($args:expr),*) =&gt; &#123;\n        #[cfg(feature = &quot;error_print&quot;)]\n        &#123;\n            println!(&quot;[ERROR] &#123;&#125;&quot;, format_args!($($args),*));\n        &#125;\n    &#125;;\n&#125;\n\nmacro_rules! info_println &#123;\n    () =&gt; &#123;&#125;;\n    ($($args:expr),*) =&gt; &#123;\n        #[cfg(feature = &quot;info_print&quot;)]\n        &#123;\n            println!(&quot;[INFO] &#123;&#125;&quot;, format_args!($($args),*));\n        &#125;\n    &#125;;\n&#125;\n\nfn main() &#123;\n    let x = 10;\n    debug_println!(&quot;The value of x is &#123;&#125;&quot;, x);\n    error_println!(&quot;An error occurred!&quot;);\n    info_println!(&quot;This is an information message.&quot;);\n&#125;\n\n/*这个例子使用了三个宏来打印不同类型的日志，每个宏都带有条件编译，仅在启用相应特性时才会执行打印操作。可以在编译时使用不同的特性来控制打印哪些日志，例如：*/\n$ cargo run --features debug_print # 打印调试信息\n[DEBUG] The value of x is 10\n\n$ cargo run --features error_print # 打印错误信息\n[ERROR] An error occurred!\n\n$ cargo run --features info_print # 打印信息日志\n[INFO] This is an information message.\n\n//这种方法可以帮助开发人员在不同的情况下，对代码进行不同程度的详细度调试。同时，还可以根据项目需要轻松地开启或关闭日志输出。\n</code></pre>\n<p>以下是一个结合条件编译和声明宏的复杂例子：</p>\n<pre><code class=\"rust\">#[macro_use]\n#[cfg(feature = &quot;my_feature&quot;)]\nmod my_module &#123;\n    #[cfg(target_arch = &quot;x86&quot;)]\n    macro_rules! my_macro &#123;\n        () =&gt; &#123;\n            println!(&quot;my_macro for x86&quot;);\n        &#125;;\n    &#125;\n    #[cfg(target_arch = &quot;x86_64&quot;)]\n    macro_rules! my_macro &#123;\n        () =&gt; &#123;\n            println!(&quot;my_macro for x86_64&quot;);\n        &#125;;\n    &#125;\n    pub fn my_function() &#123;\n        my_macro!();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"Rust的条件编译，可以总结为以下几个部分：\"><a href=\"#Rust的条件编译，可以总结为以下几个部分：\" class=\"headerlink\" title=\"Rust的条件编译，可以总结为以下几个部分：\"></a><strong>Rust的条件编译，可以总结为以下几个部分：</strong></h3><p>1.cfg属性(attribute)</p>\n<pre><code>句法\nCfgAttrAttribute :\n   cfg ( ConfigurationPredicate )\n</code></pre>\n<p><code>#[attribute]</code>可以应用于表达式、函数、模块、变量等各种语法结构，用于控制编译器的行为。可以使用<code>cfg</code>属性指定条件编译。</p>\n<p>例如：</p>\n<pre><code class=\"rust\">#[cfg(feature = &quot;my_feature&quot;)]\nfn my_func() &#123;\n    // do something\n&#125;\n</code></pre>\n<p>这段代码中，<code>#[cfg(feature = &quot;my_feature&quot;)]</code>属性表明<code>my_func()</code>函数只有在启用了名为<code>my_feature</code>的特性时才会被编译。</p>\n<p>2.cfg_if</p>\n<p>这段代码中，<code>#[cfg(target_os = &quot;linux&quot;)]</code>属性表明<code>my_func()</code>函数只有在编译目标平台为Linux时才会被编译。<code>cfg_if!</code>宏则根据不同的条件编译选项选择不同的代码块。例如：</p>\n<pre><code class=\"rust\">#[cfg(target_os = &quot;linux&quot;)]\nfn my_func() &#123;\n    // do something\n&#125;\n\n// ...\n\nfn main() &#123;\n    cfg_if::cfg_if! &#123;\n        if #[cfg(target_os = &quot;linux&quot;)] &#123;\n            // linux-specific code\n        &#125; else if #[cfg(target_os = &quot;macos&quot;)] &#123;\n            // macos-specific code\n        &#125; else &#123;\n            // generic code\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>3.cfg_matches!宏</p>\n<p><code>cfg_matches!</code>宏用于检查一个属性是否与指定的条件匹配。可以使用它来自定义条件编译选项。</p>\n<p>例如：</p>\n<pre><code class=\"rust\">fn my_func() &#123;\n    cfg_if::cfg_if! &#123;\n        if #[cfg_matches!(feature = &quot;my_feature&quot;)] &#123;\n            // feature-specific code\n        &#125; else &#123;\n            // generic code\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这段代码中，<code>#[cfg_matches!(feature = &quot;my_feature&quot;)]</code>属性表明<code>my_func()</code>函数只有在启用了名为<code>my_feature</code>的特性时才会执行特定的代码块。</p>\n<p>4.if&#x2F;else块</p>\n<p>Rust的条件编译也可以使用if&#x2F;else块来实现。</p>\n<p>例如：</p>\n<pre><code class=\"rust\">fn my_func() &#123;\n    #[cfg(feature = &quot;my_feature&quot;)]\n    &#123;\n        // feature-specific code\n    &#125;\n    #[cfg(not(feature = &quot;my_feature&quot;))]\n    &#123;\n        // generic code\n    &#125;\n&#125;\n</code></pre>\n<p>这段代码中，<code>#[cfg(feature = &quot;my_feature&quot;)]</code>和<code>#[cfg(not(feature = &quot;my_feature&quot;))]</code>分别表示在启用和禁用<code>my_feature</code>特性时执行不同的代码块。</p>\n<h1 id=\"Rust条件编译上下文无关文法\"><a href=\"#Rust条件编译上下文无关文法\" class=\"headerlink\" title=\"Rust条件编译上下文无关文法\"></a>Rust条件编译上下文无关文法</h1><p>Rust的条件编译系统提供了一种强大的方法，使得开发者能够根据不同的条件来编写和编译代码。条件编译的语法类似于C++和C#，使用<code>#[cfg(condition)]</code>属性来指定编译条件。Rust的条件编译语法可以总结为以下上下文无关文法：</p>\n<p>cfg属性的上下文无关文法:</p>\n<pre><code class=\"html\">其中，meta_item表示一个元数据项，可以是一个标识符、一个带值的标识符、一个带参数的标识符或者一个代码块。meta_item_list表示一个元数据项列表，包含若干个用逗号分隔的元数据项。meta表示一个元数据，可以是一个单独的元数据项，或者由多个元数据项组成的列表。attribute表示一个属性，包含一个由方括号括起来的元数据列表。\n\nmeta_item ::=\n     IDENTIFIER\n   |  IDENTIFIER &#39;=&#39; LITERAL\n   |  IDENTIFIER &#39;(&#39; meta_item_list? &#39;)&#39;\n   |  IDENTIFIER &#39;&#123;&#39; meta_item* &#39;&#125;&#39;\n\nmeta_item_list ::=\n    meta_item (&#39;,&#39; meta_item)*\n\nmeta ::=\n    meta_item\n   | meta_item &#39;,&#39; meta\n\nattribute ::=\n    &#39;#&#39; &#39;[&#39; meta &#39;]&#39;\n</code></pre>\n<h1 id=\"cfg-if宏\"><a href=\"#cfg-if宏\" class=\"headerlink\" title=\"cfg_if宏\"></a>cfg_if宏</h1><pre><code class=\"rust\">#[macro_export]\nmacro_rules! my_cfg_if &#123;\n    (\n        $(if #[$attr:meta] $type_alias:ident = $ty:ty;)+\n        $(else if #[$attr_else:meta] $type_alias_else:ident = $ty_else:ty;)+\n        $(else $type_alias_default:ident = $ty_default:ty;)*\n    ) =&gt; &#123;\n        $(\n            #[cfg($attr)]\n            pub type $type_alias = $ty;\n        )+\n        $(\n            #[cfg(not($attr))][cfg($attr_else)]\n            pub type $type_alias_else = $ty_else;\n        )*\n        $(\n            #[cfg(not(any($($attr),+)))]\n            pub type $type_alias_default = $ty_default;\n        )*\n    &#125;;\n&#125;\n</code></pre>\n<p>使用：</p>\n<pre><code class=\"rust\">my_cfg_if!(\n    if #[cfg(feature = &quot;a&quot;)] MyType = i32;\n    else if #[cfg(feature = &quot;b&quot;)] MyType = f32;\n    else MyType = u32;\n);\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "C2Rust"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/03/29/computer-science/%E4%BB%A5time-gettimeofday%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%BA%E4%BE%8B%E5%88%86%E6%9E%90ARM64-Linux5-4-34/",
            "url": "https://hdqjl317.github.io/2023/03/29/computer-science/%E4%BB%A5time-gettimeofday%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%BA%E4%BE%8B%E5%88%86%E6%9E%90ARM64-Linux5-4-34/",
            "title": "以time/gettimeofday系统调用为例分析ARM64-Linux5.4.34",
            "date_published": "2023-03-29T12:39:29.000Z",
            "content_html": "<h3 id=\"使用内嵌汇编触发-time-x2F-gettimeofday-系统调用\"><a href=\"#使用内嵌汇编触发-time-x2F-gettimeofday-系统调用\" class=\"headerlink\" title=\"使用内嵌汇编触发 time&#x2F;gettimeofday 系统调用\"></a>使用内嵌汇编触发 time&#x2F;gettimeofday 系统调用</h3><p>首先编写一个test.c程序，该程序会通过gettimeofday库函数来触发系统调用。</p>\n<p><code>gettimeofday</code> 是 C 库提供的函数，它封装了内核里的<code>sys_gettimeofday</code> 系统调用。</p>\n<p>在 ARM64 架构下 Linux 系统调用由同步异常 svc 指令触发。当用户态（EL0级）程序调用库函数从而触发系统调用的时候，先把系统调用的参数依次放入X0-X5 这 6 个寄存器（ Linux 系统调用最多有 6 个参数，ARM64 函数调用参数可以使用 X0-X7 这 8 个寄存器），然后把系统调用号放在 X8 寄存器 里，最后执行 svc 指令，CPU 即进入内核态（EL1级）。svc 指令一般会带一个立即数参数，一般是 0x0，但并没有被 Linux 内核使用，而是把系统调用号放到了 X8 寄存器 里。</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/time.h&gt;\n \nint main()\n&#123;\n      time_t tt;\n      struct timeval tv;\n      struct tm *t;\n#if 0\n      gettimeofday(&amp;tv,NULL); // 使用库函数的方式触发系统调用\n#else\n      asm volatile( // 使用内嵌汇编的方式触发系统调用\n          &quot;add   x0, x29, 16\\n\\t&quot;  //X0寄存器用于传递参数&amp;tv\n          &quot;mov   x1, #0x0\\n\\t&quot;     //X1寄存器用于传递参数NULL\n          &quot;mov   x8, #0xa9\\n\\t&quot;   //使用X8传递系统调用号169\n          &quot;svc   #0x0\\n\\t&quot;            //触发系统调用\n      );\n#endif\n      tt = tv.tv_sec;                    //tv是保存获取时间结果的结构体\n      t = localtime(&amp;tt);                //将世纪秒转换成对应的年月日时分秒\n      printf(&quot;time: %d/%d/%d %d:%d:%d\\n&quot;,\n             t-&gt;tm_year + 1900,\n             t-&gt;tm_mon,\n             t-&gt;tm_mday,\n             t-&gt;tm_hour,\n             t-&gt;tm_min,\n             t-&gt;tm_sec);\n      return 0;\n&#125;\n</code></pre>\n<p>交叉编译test.c，这里要使用静态编译，因为默认的动态链接编译产生的二进制文件并不会有 gettimeofday 系统调用的入口，只有相应的库函数。</p>\n<pre><code class=\"shell\">aarch64-linux-gnu-gcc -o test test.c -static\n</code></pre>\n<p>然后把test复制到根文件系统中，用 ARM 环境下编译的 busybox 重新制作一个根文件系统，test 可执行文件就在虚拟机的根目录下了。然后重新编译下：</p>\n<pre><code class=\"shell\">make ARCH=arm64 Image -j8  CROSS_COMPILE=aarch64-linux-gnu-\n</code></pre>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>启动qemu：</p>\n<pre><code class=\"shell\"> qemu-system-aarch64 -m 512M -smp 4 -cpu cortex-a57 -machine virt -kernel arch/arm64/boot/Image -append &quot;rdinit=/linuxrc nokaslr console=ttyAMA0 loglevel=8&quot; -nographic -s \n</code></pre>\n<p>在 VSCode 中启动调试。这里触发的系统调用对应的内核函数是__arm64_sys_gettimeofday。</p>\n<p><img data-src=\"/%E4%BB%A5time-gettimeofday%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%BA%E4%BE%8B%E5%88%86%E6%9E%90ARM64-Linux5-4-34/image-20230330092727353.png\"></p>\n<p>ARM64 架构的 CPU 中的 系统调用和其他异常的处理过程大致相同。异常发生时，CPU 首先把异常的原因，这里是比如执行 svc 指令触发系统调用放在 ESR_EL1 寄存器里，然后把当前的处理器状态PSTATE放入 SPSR_EL1 寄存器里，把当前程序指针寄存器 PC 的值存入 ELR_EL1 寄存器里来保存断点，然后 CPU 通过异常向量表基地址和异常的类型计算出异常处理程序的入口地址，即 VBAR_EL1 寄存器加上偏移量取得异常处理的入口地址，接着开始执行异常处理入口的第一行代码。</p>\n<p>以 svc 指令对应的 el0_sync 为例。</p>\n<p>el0_sync主要分为两部分：</p>\n<ul>\n<li>第一部分实现从用户空间到内核空间的上下文切换： kernel_entry 0；</li>\n<li>第二部是根据异常症状寄存器esr_el1判断异常原因，然后再进入具体处理函数。</li>\n</ul>\n<p>el0_sync首先执行kernel_entry 0，将通用寄存器x0~x29保存到当前进程的内核栈，然后是从SP_EL0、SPSR_EL1、ELR_EL1寄存器中读取用户栈栈顶地址、发生异常时的处理器状态和返回地址，将这三个值以及发生异常时的LR寄存器中的值都保存到当前进程的内核栈中，以struct pt_regs结构体的格式保存在当前进程内核栈的栈底，完成保存现场过程。</p>\n<p><img data-src=\"/%E4%BB%A5time-gettimeofday%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%BA%E4%BE%8B%E5%88%86%E6%9E%90ARM64-Linux5-4-34/image-20230330102417429.png\"></p>\n<p>系统调用是用户态执行SVC指令导致的，因此要进入el0_svc处理函数，根据ESR_EL1 寄存器中的内容跳转到 el0_svc，el0_svc 会调用 el0_svc_handler、el0_svc_common 函数，将 X8 寄存器（regs-&gt;regs[8]）中存放的系统调用号传递给 invoke_syscall 函数。</p>\n<p><img data-src=\"/%E4%BB%A5time-gettimeofday%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%BA%E4%BE%8B%E5%88%86%E6%9E%90ARM64-Linux5-4-34/image-20230330094042682.png\"></p>\n<p><img data-src=\"/%E4%BB%A5time-gettimeofday%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%BA%E4%BE%8B%E5%88%86%E6%9E%90ARM64-Linux5-4-34/image-20230330093847343.png\"></p>\n<p><img data-src=\"/%E4%BB%A5time-gettimeofday%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%BA%E4%BE%8B%E5%88%86%E6%9E%90ARM64-Linux5-4-34/image-20230330095034638.png\"></p>\n<p><img data-src=\"/%E4%BB%A5time-gettimeofday%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%BA%E4%BE%8B%E5%88%86%E6%9E%90ARM64-Linux5-4-34/image-20230330094929209.png\"></p>\n<p>接着执行 invoke_syscall 函数，将通用寄存器中的内容传入 syscall_fn()，引出系统调用内核处理函数 __arm64_sys_gettimeofday，然后等系统调用内核处理函数执行完成，会将系统调用的返回值存放在 X0 寄存器中。</p>\n<p><img data-src=\"/%E4%BB%A5time-gettimeofday%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%BA%E4%BE%8B%E5%88%86%E6%9E%90ARM64-Linux5-4-34/image-20230330095311264.png\"></p>\n<p><img data-src=\"/%E4%BB%A5time-gettimeofday%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%BA%E4%BE%8B%E5%88%86%E6%9E%90ARM64-Linux5-4-34/image-20230330095419963.png\"></p>\n<p>从系统调用返回前会处理一些工作（work_pending），比如处理信号、判断是否需要进程调度等，ret_to_user的最后是kernel_exit 0负责恢复现场，与保存现场kernel_entry 0相对应，kernel_exit 0的最后会执行eret指令系统调用返回。eret指令所做的工作与svc指令相对应，eret指令会将ELR_EL1寄存器里值恢复到程序指针寄存器PC中，把SPSR_EL1寄存器里的值恢复到PSTATE处理器状态中，同时会从内核态转换到用户态。</p>\n<p><img data-src=\"/%E4%BB%A5time-gettimeofday%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%BA%E4%BE%8B%E5%88%86%E6%9E%90ARM64-Linux5-4-34/image-20230330100637352.png\"></p>\n",
            "tags": [
                "计算机科学",
                "Linux"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/03/26/computer-science/Rust%E5%A3%B0%E6%98%8E%E5%AE%8F%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/",
            "url": "https://hdqjl317.github.io/2023/03/26/computer-science/Rust%E5%A3%B0%E6%98%8E%E5%AE%8F%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/",
            "title": "Rust声明宏上下文无关文法",
            "date_published": "2023-03-26T12:34:32.000Z",
            "content_html": "<p><strong>Rust声明宏：</strong></p>\n<pre><code class=\"html\">MacroRulesDefinition :\n   macro_rules ! IDENTIFIER MacroRulesDef\n\nMacroRulesDef :\n      ( MacroRules ) ;\n   | [ MacroRules ] ;\n   | &#123; MacroRules &#125;\n\nMacroRules :\n   MacroRule ( ; MacroRule )* ;?\n\nMacroRule :\n   MacroMatcher =&gt; MacroTranscriber\n\nMacroMatcher :\n      ( MacroMatch* )\n   | [ MacroMatch* ]\n   | &#123; MacroMatch* &#125;\n\nMacroMatch :\n      Token排除 $ 和 定界符\n   | MacroMatcher\n   | $ IDENTIFIER : MacroFragSpec\n   | $ ( MacroMatch+ ) MacroRepSep? MacroRepOp\n\nMacroFragSpec :\n      block | expr | ident | item | lifetime | literal\n   | meta | pat | path | stmt | tt | ty | vis\n\nMacroRepSep :\n   Token排除 定界符 和 重复操作符\n\nMacroRepOp :\n   * | + | ?\n\nMacroTranscriber :\n   DelimTokenTree\n</code></pre>\n<p><strong>条件编译：</strong></p>\n<pre><code class=\"html\">ConfigurationPredicate :\n      ConfigurationOption\n   | ConfigurationAll\n   | ConfigurationAny\n   | ConfigurationNot\n\nConfigurationOption :\n   IDENTIFIER (= (STRING_LITERAL | RAW_STRING_LITERAL))?\n\nConfigurationAll\n   all ( ConfigurationPredicateList? )\n\nConfigurationAny\n   any ( ConfigurationPredicateList? )\n\nConfigurationNot\n   not ( ConfigurationPredicate )\n\nConfigurationPredicateList\n   ConfigurationPredicate (, ConfigurationPredicate)* ,?\n</code></pre>\n<p>每种形式的编译条件都有一个计算结果为真或假的*配置谓词(configuration predicate)*。谓词是以下内容之一：</p>\n<ul>\n<li>一个配置选项。如果设置了该选项，则为真，如果未设置则为假。</li>\n<li><code>all()</code> 这样的配置谓词列表，列表内的配置谓词以逗号分隔。如果至少有一个谓词为假，则为假。如果没有谓词，则为真。</li>\n<li><code>any()</code> 这样的配置谓词列表，列表内的配置谓词以逗号分隔。如果至少有一个谓词为真，则为真。如果没有谓词，则为假。</li>\n<li>带一个配置谓词的 <code>not()</code> 模式 。如果此谓词为假，整个配置它为真；如果此谓词为真，整个配置为假。</li>\n</ul>\n<p><em>配置选项</em>可以是名称，也可以是键值对，它们可以设置，也可以不设置。名称以单个标识符形式写入，例如 <code>unix</code>。键值对被写为标识符后跟 <code>=</code>，然后再跟一个字符串。例如，<code>target_arch=“x86_64”</code> 就是一个配置选项。键在键值对配置选项列表中不是唯一的。例如，<code>feature = &quot;std&quot;</code> and <code>feature = &quot;serde&quot;</code> 可以同时设置。</p>\n",
            "tags": [
                "计算机科学",
                "C2Rust"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/03/26/computer-science/Rust%E5%A3%B0%E6%98%8E%E5%AE%8F%E4%B8%8E%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/",
            "url": "https://hdqjl317.github.io/2023/03/26/computer-science/Rust%E5%A3%B0%E6%98%8E%E5%AE%8F%E4%B8%8E%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/",
            "title": "Rust声明宏与条件编译",
            "date_published": "2023-03-26T12:32:30.000Z",
            "content_html": "<p>在rust中，声明宏本质就是匹配规则 + 转译替换规则，也是代码模版按照匹配规则进行代码化替换。调用声明宏时，就是传入一串代码片段，在编译期由编译期根据传入代码片段来匹配宏自身定义的匹配规则，再经过转译替换规则，将宏调用代码替换为转译后的代码。</p>\n<h3 id=\"声明式宏的几类写法：\"><a href=\"#声明式宏的几类写法：\" class=\"headerlink\" title=\"声明式宏的几类写法：\"></a>声明式宏的几类写法：</h3><ol>\n<li><p>常量宏，简单模式匹配替换</p>\n</li>\n<li><p>语句宏，语句替换，返回表达式结果</p>\n</li>\n<li><p>函数宏（Function-like macro），和过程中的类函数式宏极为相似。</p>\n</li>\n</ol>\n<p>这里对前两种用法做个总结，然后对Rust中条件编译宏cfg和cfg_if用法做简要总结。</p>\n<h3 id=\"声明宏一般形式：\"><a href=\"#声明宏一般形式：\" class=\"headerlink\" title=\"声明宏一般形式：\"></a>声明宏一般形式：</h3><pre><code class=\"rust\">macro_rules! $name &#123;\n    $pattern0 =&gt; ($expansion);\n    $pattern1 =&gt; ($expansion);\n    _ =&gt; ($expansion);\n&#125;\n</code></pre>\n<p><strong>注意：</strong></p>\n<ol>\n<li><code>$name</code>表示宏的名字，内部一般由1个或者多个模式匹配组成。匹配上规则之后就用<code>($expansion)</code>代替。 举个栗子。</li>\n<li>每个 <code>rule</code> 的格式：<code>($pattern) =&gt; &#123;$expansion&#125;</code>，其中括号和大括号不是特定的。可以使用 <code>[]</code>、<code>()</code>、<code>&#123;&#125;</code> 中的任意一种，在调用宏的时候也是，而过程宏中的类函数式宏后面只能是<code>()</code>。</li>\n<li><strong>从最具体到最不具体的顺序编写宏规则很重要</strong>，pattern越准确书写的pattern的位置越靠前，否则会有意想不到的错误。</li>\n</ol>\n<h3 id=\"常量宏形式：\"><a href=\"#常量宏形式：\" class=\"headerlink\" title=\"常量宏形式：\"></a>常量宏形式：</h3><pre><code class=\"c\">#define pi 3.14\n#define p\nint a = pi;\n</code></pre>\n<p>可以使用 <code>[]</code>、<code>()</code>、<code>&#123;&#125;</code> 中的任意一种。</p>\n<pre><code class=\"rust\">macro_rules! pi &#123;\n    () =&gt; &#123; 3.14 &#125;;\n&#125;\n\nlet a = pi();\nlet b = pi[];\nlet c = pi&#123;&#125;;\n</code></pre>\n<h3 id=\"语句宏形式：\"><a href=\"#语句宏形式：\" class=\"headerlink\" title=\"语句宏形式：\"></a>语句宏形式：</h3><pre><code class=\"c\">// demo mutliply(2 + 3, 4 + 5)\n#define multiply(x, y) x * y // 错误，宏展开: 2 + 3 * 4 + 5，结果19\n#define multiply(x, y) ((x) * (y)) // 正确，红展开: ((2 + 3) * (4 + 5))，结果45\n</code></pre>\n<p><strong>而Rust中不用考虑这((x) * (y))加括号的情况</strong>，Rust中的Token trees介于tokens和 AST 之间，tokens是Token trees的叶子，而值得注意的是(…)、[…]和{…}不是叶子，而是Token trees的内部节点。比如：a + b + (c + d[0]) + e将有如下Token trees的结构：</p>\n<pre><code class=\"shell\">«a» «+» «b» «+» «(   )» «+» «e»\n          ╭────────┴──────────╮\n           «c» «+» «d» «[   ]»\n                        ╭─┴─╮\n                         «0»\n</code></pre>\n<p><strong>这与表达式将产生的 AST没有关系</strong>；根级别有七棵Token trees，而不是单个根节点。</p>\n<p>所以之前的例子可以翻译为如下rust代码：</p>\n<pre><code class=\"rust\">macro_rules! multiply &#123;\n    ($x:expr, $y:expr) =&gt; &#123;\t\t\t\t//匹配模式越精准的要放在前面，否则可能有意想不到的错误！\n        $x * $y\n    &#125;;\n    ($x:expr) =&gt; &#123;\n        $x\n    &#125;;\n&#125;\n\nfn main() &#123;\n    let a = multiply!(2 + 3, 4 + 5);\n    let b = multiply!(2);\n&#125;\n</code></pre>\n<p>如果是有多个expr，add_as(x,y,z) 或 add_as(x,y,z,m) 或 add_as(x,y,z,m,n) ……</p>\n<pre><code class=\"rust\">macro_rules! add_as&#123;\n    ( $($a:expr),* )=&gt;&#123;\n           &#123;\n               // to handle the case without any arguments\n               0\n               // block to be repeated\n               $(+$a)*\n        &#125;\n    &#125;\n&#125;\n\nfn main()&#123;\n    println!(&quot;&#123;&#125;&quot;,add_as!(1,2,3,4)); // =&gt; println!(&quot;&#123;&#125;&quot;,&#123;0+1+2+3+4&#125;)\n&#125;\n</code></pre>\n<p>匹配规则中包含meta变量用$标识来标示，其类型包括block、expr、ident、item、lifetime、literal、meta、pat、path、stmt、tt、ty、vis。具体用法可见<span class=\"exturl\" data-url=\"aHR0cHM6Ly92ZXlrcmlsLmdpdGh1Yi5pby90bGJvcm0vZGVjbC1tYWNyb3MvbWludXRpYWUvZnJhZ21lbnQtc3BlY2lmaWVycy5odG1s\">片段说明符</span>。</p>\n<ul>\n<li><code>item</code>：<a href=\"https://doc.rust-lang.org/reference/items.html\"><em>Item</em></a>，如函数定义，常量声明 等</li>\n<li><code>block</code>：<a href=\"https://doc.rust-lang.org/reference/expressions/block-expr.html\"><em>BlockExpression</em></a>，如<code>&#123; ... &#125;</code></li>\n<li><code>stmt</code>：<a href=\"https://doc.rust-lang.org/reference/statements.html\"><em>Statement</em></a>，如 <code>let</code> 表达式（传入为 stmt 类型的参数时不需要末尾的分号，但需要分号的 item 语句除外）</li>\n<li><code>pat</code>：<a href=\"https://doc.rust-lang.org/reference/patterns.html\"><em>Pattern</em></a>，模式匹配中的模式，如 <code>Some(a)</code></li>\n<li><code>expr</code>：<a href=\"https://doc.rust-lang.org/reference/expressions.html\"><em>Expression</em></a>，表达式，如 <code>Vec::new()</code></li>\n<li><code>ty</code>：<a href=\"https://doc.rust-lang.org/reference/types.html#type-expressions\"><em>Type</em></a>，类型，如 <code>i32</code></li>\n<li><code>ident</code>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvaWRlbnRpZmllcnMuaHRtbA==\">IDENTIFIER_OR_KEYWORD</span>，标识符或关键字，如 <code>i</code> 或 <code>self</code></li>\n<li><code>path</code>：<a href=\"https://doc.rust-lang.org/reference/paths.html#paths-in-types\"><em>TypePath</em></a>，类型路径，如 <code>std::result::Result</code></li>\n<li><code>tt</code>：<a href=\"https://doc.rust-lang.org/reference/macros.html#macro-invocation\"><em>TokenTree</em></a>，Token 树，被匹配的定界符 <code>(</code>、<code>[]</code> 或 <code>&#123;&#125;</code> 中的单个或多个 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvdG9rZW5zLmh0bWw=\">token</span></li>\n<li><code>meta</code>：<a href=\"https://doc.rust-lang.org/reference/attributes.html\"><em>Attr</em></a>，形如 <code>#[...]</code> 的属性中的内容</li>\n<li><code>lifetime</code>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvdG9rZW5zLmh0bWwjbGlmZXRpbWVzLWFuZC1sb29wLWxhYmVscw==\">LIFETIME_TOKEN</span>，生命周期 Token，如 <code>&#39;static</code></li>\n<li><code>vis</code>：<a href=\"https://doc.rust-lang.org/reference/visibility-and-privacy.html\"><em>Visibility</em></a>，可能为空的可见性限定符，如 <code>pub</code></li>\n<li><code>literal</code>：匹配 -? <a href=\"https://doc.rust-lang.org/reference/expressions/literal-expr.html\"><em>LiteralExpression</em></a></li>\n</ul>\n<p><strong>匹配器可以包含重复项。这些允许匹配一系列标记。这些都有一般的形式<code>$ ( ... ) sep rep</code>。</strong></p>\n<ul>\n<li><p><code>$</code>是字面上的美元标记。</p>\n</li>\n<li><p><code>( ... )</code>是被重复的 paren 分组匹配器。</p>\n</li>\n<li><p><strong><code>sep</code>是一个<em>可选的</em>分隔符。</strong>它可能不是定界符或重复运算符之一。常见的例子是<code>,</code>和<code>;</code>。</p>\n</li>\n<li><p><code>rep</code>是<em>必需的</em>重复运算符。目前，这可以是：</p>\n<ul>\n<li><code>?</code>: 表示最多重复一次</li>\n<li><code>*</code>：表示零次或多次重复</li>\n<li><code>+</code>: 表示一次或多次重复</li>\n</ul>\n<p>由于<code>?</code>最多代表一次出现，因此不能与分隔符一起使用。</p>\n</li>\n</ul>\n<p>重复可以包含任何其他有效的匹配器，包括token trees、元变量和其他允许任意嵌套的重复。</p>\n<p><strong>注意：这里<code>sep</code>可以是其他的形式，比如下面的; and和; or</strong></p>\n<pre><code class=\"rust\">/// test宏定义了两组匹配和转译替换规则\n    macro_rules! test_macro &#123;\n        ($left:expr; and $right:expr) =&gt; &#123;\n            println!(&quot;&#123;:?&#125; and &#123;:?&#125; is &#123;:?&#125;&quot;,\n                     // $left变量的内容对应匹配上的语法片段的内容\n                     stringify!($left),\n                     // $right变量的内容对应匹配上的语法片段的内容\n                     stringify!($right),\n                     $left &amp;&amp; $right)\n        &#125;;\n        ($left:expr; or $right:expr) =&gt; &#123;\n            println!(&quot;&#123;:?&#125; or &#123;:?&#125; is &#123;:?&#125;&quot;,\n                     stringify!($left),\n                     stringify!($right),\n                     $left || $right)\n        &#125;;\n    &#125;\n\n/// 传入的字面上的代码片段，解析后生成的语法片段，\n///  - 在解析过程中进行简易分词和解析后生成一个语法片段(包含解析出来的不同类型及其对应的值)\n///  - 与声明宏中定义的匹配规则包含的字面量token和meta变量类型等，按照从左到右一对一的方式进行匹配(匹配都是进行深度匹配的，一旦当前规则匹配过程出现问题，则不会再进行后续的规则匹配)\n///  - 一旦提供的语法片段和某个声明宏定义的规则匹配了，那么对应类型的值绑定到meta变量中，即用$标示来代替;\n///    再匹配后，进入转译替换阶段，直接读取对应的转译替换规则的内容，将其meta变量的内容用上一阶段绑定过来的值替换，完成处理后输出即可;\n/// 正好能匹配上第一个匹配规则；\n/// - 第一个匹配规则为\n///  一个表达式类型语法片段和; and 和另一个表达式类型语法片段\n///  其中;和and需要字面上一对一匹配；\ntest_macro!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);\n\n/// 下面传入的字面上的代码片段，解析后生成的语法片段，\n/// 正好能匹配上第二个匹配规则；\n/// - 第二个匹配规则为：\n/// 一个表达式类型语法片段和; or 和另一个表达式类型语法片段\n/// 其中;和or需要字面上一对一匹配；\ntest_macro!(true; or false);\n</code></pre>\n<h3 id=\"Hygiene\"><a href=\"#Hygiene\" class=\"headerlink\" title=\"Hygiene\"></a>Hygiene</h3><p>Hygiene是Rust宏中的一个重要的特性，写声明宏时注意以下问题。</p>\n<pre><code class=\"rust\">macro_rules! using_x &#123;\n    ( ¥action:expr ) =&gt; &#123;\n        &#123;\n            let x = 1;\t\t\t// let macro_x = 1;\n            ¥action\t\t\t\t// 这里展开后为x + 1 ，实际上这里是outer_x + 1 不同的x\n        &#125;\n    &#125;\n&#125;\n\nfn main() &#123;\n    let two = using_x!(x + 1);\n&#125;\n\n// 报错： using_x!(x + 1);\n//      \t\t ^ not found in this scope\n\n// using_X换成以下写法则可通过\nmacro_rules! using_x &#123;\n    ( ¥id:ident, ¥action:expr ) =&gt; &#123;\n        &#123;\n            let ¥id = 1;\n            ¥action\n        &#125;\n    &#125;\n&#125;\n\nfn main() &#123;\n    let two = using_x!(x, x + 1);\n&#125;\n</code></pre>\n<h3 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h3><p>条件编译可能通过两种不同的操作符实现：</p>\n<ul>\n<li><p><code>cfg</code> 属性：在属性位置中使用 <code>#[cfg(...)]</code></p>\n</li>\n<li><p><code>cfg!</code> 宏：在布尔表达式中使用 <code>cfg!(...)</code></p>\n</li>\n<li><p><code>cfg_if!</code>宏：这个 crate 提供的宏<code>cfg_if</code>类似于<code>if/elif</code>C 预处理器宏，允许定义级联<code>#[cfg]</code>案例，发出最先匹配的实现。这使您可以方便地提供一长串<code>#[cfg]</code>代码块，而不必多次重写每个子句。</p>\n</li>\n</ul>\n<p> <code>#[cfg(...)]</code>是属性宏，<strong>这里考虑用cfg！宏和cfg_if！宏完成条件编译</strong>。下面是前两种条件编译宏的用法：</p>\n<pre><code class=\"rust\">// 这个函数仅当目标系统是 Linux 的时候才会编译\n#[cfg(target_os = &quot;linux&quot;)]\nfn are_you_on_linux() &#123;\n    println!(&quot;You are running linux!&quot;)\n&#125;\n\n// 而这个函数仅当目标系统 **不是** Linux 时才会编译\n#[cfg(not(target_os = &quot;linux&quot;))]\nfn are_you_on_linux() &#123;\n    println!(&quot;You are *not* running linux!&quot;)\n&#125;\n\nfn main() &#123;\n    are_you_on_linux();\n    \n    println!(&quot;Are you sure?&quot;);\n    if cfg!(target_os = &quot;linux&quot;) &#123;\n        println!(&quot;Yes. It&#39;s definitely linux!&quot;);\n    &#125; else &#123;\n        println!(&quot;Yes. It&#39;s definitely *not* linux!&quot;);\n    &#125;\n&#125;\n\n/* 输出\nYou are running linux!\nAre you sure?\nYes. It&#39;s definitely linux!\n*/\n</code></pre>\n<h4 id=\"cfg-格式：\"><a href=\"#cfg-格式：\" class=\"headerlink\" title=\"cfg!格式：\"></a><strong>cfg!格式</strong>：</h4><pre><code class=\"rust\">macro_rules! cfg &#123;\n    ($($cfg:tt)*) =&gt; &#123; ... &#125;;\t\t\t\n&#125;\n</code></pre>\n<p>cfg！宏在编译时评估配置标志的布尔组合，赋予cfg！宏与属性#[cfg(…)]相同的功能。</p>\n<p>内置的 <code>cfg</code>宏接受单个配置谓词，当谓词为真时计算为 <code>true</code> 字面量，当谓词为假时计算为 <code>false</code> 字面量。</p>\n<pre><code class=\"rust\">#![allow(unused)]\nfn main() &#123;\n    let machine_kind = if cfg!(unix) &#123;\n      &quot;unix&quot;\n    &#125; else if cfg!(windows) &#123;\n      &quot;windows&quot;\n    &#125; else &#123;\n      &quot;unknown&quot;\n    &#125;;\n\n    println!(&quot;I&#39;m running on a &#123;&#125; machine!&quot;, machine_kind);\n&#125;\n</code></pre>\n<h4 id=\"cfg-if！格式：\"><a href=\"#cfg-if！格式：\" class=\"headerlink\" title=\"cfg_if！格式：\"></a><strong>cfg_if！格式</strong>：</h4><pre><code class=\"rust\">cfg_if::cfg_if! &#123;\n    if #[cfg(unix)] &#123;\n        fn foo() &#123; /* unix specific functionality */ &#125;\n    &#125; else if #[cfg(target_pointer_width = &quot;32&quot;)] &#123;\n        fn foo() &#123; /* non-unix, 32-bit functionality */ &#125;\n    &#125; else &#123;\n        fn foo() &#123; /* fallback implementation */ &#125;\n    &#125;\n&#125;\n\nfn main() &#123;\n    foo();\n&#125;\n</code></pre>\n<p>将扩展为：</p>\n<pre><code class=\"rust\">#[cfg(unix)]\nfn foo() &#123; /* unix specific functionality */ &#125;\n#[cfg(all(target_pointer_width = &quot;32&quot;, not(unix)))]\nfn foo() &#123; /* non-unix, 32-bit functionality */ &#125;\n#[cfg(not(any(unix, target_pointer_width = &quot;32&quot;)))]\nfn foo() &#123; /* fallback implementation */ &#125;        \n</code></pre>\n<p>cfg_if更多信息见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLnJzL2NmZy1pZi9sYXRlc3QvY2ZnX2lmL21hY3JvLmNmZ19pZi5odG1s\">cfg_if</span>。</p>\n<h4 id=\"设置配置选项\"><a href=\"#设置配置选项\" class=\"headerlink\" title=\"设置配置选项\"></a>设置配置选项</h4><p>设置哪些配置选项是在 crate 编译期时就静态确定的。一些选项属于<em>编译器设置集(compiler-set)<em>，这部分选项是编译器根据相关编译数据设置的。其他选项属于</em>任意设置集(arbitrarily-set)<em>，这部分设置必须从代码之外传参给编译器来自主设置。无法在正在编译的 crate 的源代码中设置编译配置选项。**对于 <code>rustc</code>，任意配置集的配置选项要使用命令行参数 <a href=\"https://doc.rust-lang.org/rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment\"><code>--cfg</code></a> 来设置。</em></em></p>\n<p>**编译器设置集(compiler-set)**： <a href=\"https://rustwiki.org/zh-CN/reference/conditional-compilation.html\"><code>编译器设置集</code></a></p>\n<p>条件编译更多用法详细见：[条件编译]</p>\n",
            "tags": [
                "计算机科学",
                "C2Rust"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/03/22/computer-science/start-kernel%E5%88%86%E6%9E%90/",
            "url": "https://hdqjl317.github.io/2023/03/22/computer-science/start-kernel%E5%88%86%E6%9E%90/",
            "title": "start_kernel分析",
            "date_published": "2023-03-22T12:37:30.000Z",
            "content_html": "<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><pre><code class=\"shell\">sudo apt install build-essential\nsudo apt install qemu \nsudo apt install libncurses5-dev bison flex libssl-dev libelf-dev\n</code></pre>\n<h3 id=\"下载内核源码\"><a href=\"#下载内核源码\" class=\"headerlink\" title=\"下载内核源码\"></a>下载内核源码</h3><pre><code class=\"shell\">sudo apt install axel\naxel -n 20 https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.4.34.tar.xz\nxz -d linux-5.4.34.tar.xz\ntar -xvf linux-5.4.34.tar \ncd linux-5.4.34\n</code></pre>\n<h3 id=\"配置内核选项\"><a href=\"#配置内核选项\" class=\"headerlink\" title=\"配置内核选项\"></a>配置内核选项</h3><pre><code class=\"shell\">make defconfig \t# Default configuration is based on &#39;x86_64_defconfig&#39;\nmake menuconfig\t# 打开debug相关选项\n</code></pre>\n<p><img data-src=\"/start-kernel%E5%88%86%E6%9E%90/image-20230322184745975.png\"></p>\n<p>进行如下设置：</p>\n<pre><code class=\"shell\">Kernel hacking —&gt;\nCompile-time checks and compiler options —&gt;\n[*] Compile the kernel with debug info\n[*] Provide GDB scripts for kernel debugging\n[*] Kernel debugging\n关闭KASLR（随机地址），否则会导致打断点失败。\nProcessor type and features ----&gt;\n[ ] Randomize the address of the kernel image (KASLR)\n</code></pre>\n<h3 id=\"编译运行内核\"><a href=\"#编译运行内核\" class=\"headerlink\" title=\"编译运行内核\"></a>编译运行内核</h3><pre><code class=\"shell\">make -j$(nproc) \nqemu-system-x86_64 -kernel arch/x86/boot/bzImage\n</code></pre>\n<h3 id=\"制作内存根文件系统\"><a href=\"#制作内存根文件系统\" class=\"headerlink\" title=\"制作内存根文件系统\"></a>制作内存根文件系统</h3><pre><code class=\"shell\">#首先从https://www.busybox.net下载 busybox源代码解压，解压完成后，跟内核一样先配置编译，并安装。\naxel -n 20 https://busybox.net/downloads/busybox-1.31.1.tar.bz2\ntar -jxvf busybox-1.31.1.tar.bz2\ncd busybox-1.31.1\nmake menuconfig #Setting里的Build static binary (no shared libs)选中\n</code></pre>\n<p>然后编译安装，默认会安装到源码目录下的 _install 目录中。</p>\n<pre><code class=\"shell\">make -j$(nproc) &amp;&amp; sudo make install\n</code></pre>\n<p>然后制作内存根文件系统镜像:</p>\n<pre><code>mkdir rootfs # 在/linux-5.4.34文件夹下新建rootfs文件夹\ncd rootfs\ncp ../busybox-1.31.1/_install/* ./ -rf\nmkdir dev proc sys home\nsudo cp -a /dev/&#123;null,console,tty,tty1,tty2,tty3,tty4&#125; dev/\n</code></pre>\n<p>准备init脚本文件放在根文件系统跟目录下（rootfs&#x2F;init），添加如下内容到init文件。</p>\n<pre><code class=\"shell\">#!/bin/sh\nmount -t proc none /proc\nmount -t sysfs none /sys\necho “Wellcome qjliOS!”\necho “--------------------”\ncd home\n/bin/sh\n</code></pre>\n<p>给init脚本添加可执行权限：</p>\n<pre><code class=\"shell\">chmod +x init\n</code></pre>\n<p>打包成内存根文件系统镜像：</p>\n<pre><code class=\"shell\">find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../rootfs.cpio.gz \n</code></pre>\n<p>测试挂载根文件系统，看内核启动完成后是否执行init脚本。</p>\n<pre><code class=\"shell\">qemu-system-x86_64 -kernel ./arch/x86/boot/bzImage -initrd rootfs.cpio.gz\n</code></pre>\n<p>出现 “Wellcome qjliOS!”则init脚本执行成功。</p>\n<h3 id=\"VSCode配置Linux内核调试环境\"><a href=\"#VSCode配置Linux内核调试环境\" class=\"headerlink\" title=\"VSCode配置Linux内核调试环境\"></a>VSCode配置Linux内核调试环境</h3><p>由于 Linux 内核高度定制化，所以没有办法直接通过配置 includePath 等让 Intellisense 正常提示，这里借助一个 Python 脚本来生成 compile_commands.json 文件帮助 Intellisense 正常提示（包括头文件和宏定义等）。在Linux源代码目录下直接运行如下命令就可以生成compile_commands.json 了。</p>\n<pre><code class=\"shell\">python ./scripts/gen_compile_commands.py\n</code></pre>\n<p>新建一个.vscode文件夹，将配置文件放入该文件夹内,配置如下五个文件：c_cpp_properties.json，init，launch.json，settings.json，tasks.json。</p>\n<p><strong>c_cpp_properties.json</strong></p>\n<pre><code class=\"json\">&#123;\n    &quot;configurations&quot;: [\n        &#123;\n            &quot;name&quot;: &quot;Linux&quot;,\n            &quot;includePath&quot;: [\n                &quot;$&#123;workspaceFolder&#125;/arch/x86/include/**&quot;,\n                &quot;$&#123;workspaceFolder&#125;/include/**&quot;,\n                &quot;$&#123;workspaceFolder&#125;/include/linux/**&quot;,\n                &quot;$&#123;workspaceFolder&#125;/arch/x86/**&quot;,\n                &quot;$&#123;workspaceFolder&#125;/**&quot;\n            ],\n            &quot;cStandard&quot;: &quot;c11&quot;,\n            &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;,\n            &quot;compileCommands&quot;: &quot;$&#123;workspaceFolder&#125;/compile_commands.json&quot;\n        &#125;\n    ],\n    &quot;version&quot;: 4\n&#125;\n</code></pre>\n<p><strong>init</strong></p>\n<pre><code class=\"shell\">#!/bin/sh\nmount -t proc none /proc\nmount -t sysfs none /sys\n\necho &quot;Wellcome qjlOS!&quot;\necho &quot;--------------------&quot;\ncd home\n/bin/sh\n</code></pre>\n<p><strong>launch.json</strong></p>\n<pre><code class=\"json\">&#123;\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    &quot;version&quot;: &quot;0.2.0&quot;,\n    &quot;configurations&quot;: [\n      &#123;\n        &quot;name&quot;: &quot;(gdb) linux&quot;,\n        &quot;type&quot;: &quot;cppdbg&quot;,\n        &quot;request&quot;: &quot;launch&quot;,\n        &quot;preLaunchTask&quot;: &quot;vm&quot;,\n        &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/vmlinux&quot;,\n        &quot;miDebuggerServerAddress&quot;: &quot;localhost:1234&quot;,\n        &quot;args&quot;: [],\n        &quot;stopAtEntry&quot;: true,\n        &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,\n        &quot;environment&quot;: [],\n        &quot;externalConsole&quot;: false,\n        &quot;MIMode&quot;: &quot;gdb&quot;,\n        &quot;miDebuggerArgs&quot;: &quot;-n&quot;,\n        &quot;targetArchitecture&quot;: &quot;x64&quot;,\n        &quot;setupCommands&quot;: [\n          &#123;\n            &quot;text&quot;: &quot;set arch i386:x86-64:intel&quot;,\n            &quot;ignoreFailures&quot;: false\n          &#125;,\n          &#123;\n            &quot;text&quot;: &quot;dir .&quot;,\n            &quot;ignoreFailures&quot;: false\n          &#125;,\n          &#123;\n            &quot;text&quot;: &quot;add-auto-load-safe-path ./&quot;,\n            &quot;ignoreFailures&quot;: false\n          &#125;,\n          &#123;\n            &quot;text&quot;: &quot;-enable-pretty-printing&quot;,\n            &quot;ignoreFailures&quot;: true\n          &#125;\n        ]\n      &#125;\n    ]\n  &#125;\n</code></pre>\n<p><strong>settings.json</strong></p>\n<pre><code class=\"json\">&#123;\n    &quot;search.exclude&quot;: &#123;\n        &quot;**/.git&quot;: true,\n        &quot;**/.svn&quot;: true,\n        &quot;**/.DS_Store&quot;: true,\n        &quot;**/drivers&quot;: true,\n        &quot;**/sound&quot;: true,\n        &quot;**/tools&quot;: true,\n        &quot;**/arch/alpha&quot;: true,\n        &quot;**/arch/arc&quot;: true,\n        &quot;**/arch/c6x&quot;: true,\n        &quot;**/arch/h8300&quot;: true,\n        &quot;**/arch/hexagon&quot;: true,\n        &quot;**/arch/ia64&quot;: true,\n        &quot;**/arch/m32r&quot;: true,\n        &quot;**/arch/m68k&quot;: true,\n        &quot;**/arch/microblaze&quot;: true,\n        &quot;**/arch/mn10300&quot;: true,\n        &quot;**/arch/nds32&quot;: true,\n        &quot;**/arch/nios2&quot;: true,\n        &quot;**/arch/parisc&quot;: true,\n        &quot;**/arch/powerpc&quot;: true,\n        &quot;**/arch/s390&quot;: true,\n        &quot;**/arch/sparc&quot;: true,\n        &quot;**/arch/score&quot;: true,\n        &quot;**/arch/sh&quot;: true,\n        &quot;**/arch/um&quot;: true,\n        &quot;**/arch/unicore32&quot;: true,\n        &quot;**/arch/xtensa&quot;: true\n    &#125;,\n    &quot;files.exclude&quot;: &#123;\n        &quot;**/.*.*.cmd&quot;: true,\n        &quot;**/.*.d&quot;: true,\n        &quot;**/.*.o&quot;: true,\n        &quot;**/.*.S&quot;: true,\n        &quot;**/.git&quot;: true,\n        &quot;**/.svn&quot;: true,\n        &quot;**/.DS_Store&quot;: true,\n        &quot;**/drivers&quot;: true,\n        &quot;**/sound&quot;: true,\n        &quot;**/tools&quot;: true,\n        &quot;**/arch/alpha&quot;: true,\n        &quot;**/arch/arc&quot;: true,\n        &quot;**/arch/c6x&quot;: true,\n        &quot;**/arch/h8300&quot;: true,\n        &quot;**/arch/hexagon&quot;: true,\n        &quot;**/arch/ia64&quot;: true,\n        &quot;**/arch/m32r&quot;: true,\n        &quot;**/arch/m68k&quot;: true,\n        &quot;**/arch/microblaze&quot;: true,\n        &quot;**/arch/mn10300&quot;: true,\n        &quot;**/arch/nds32&quot;: true,\n        &quot;**/arch/nios2&quot;: true,\n        &quot;**/arch/parisc&quot;: true,\n        &quot;**/arch/powerpc&quot;: true,\n        &quot;**/arch/s390&quot;: true,\n        &quot;**/arch/sparc&quot;: true,\n        &quot;**/arch/score&quot;: true,\n        &quot;**/arch/sh&quot;: true,\n        &quot;**/arch/um&quot;: true,\n        &quot;**/arch/unicore32&quot;: true,\n        &quot;**/arch/xtensa&quot;: true\n    &#125;,\n    &quot;[c]&quot;: &#123;\n        &quot;editor.detectIndentation&quot;: false,\n        &quot;editor.tabSize&quot;: 8,\n        &quot;editor.insertSpaces&quot;: false\n    &#125;,\n    &quot;C_Cpp.errorSquiggles&quot;: &quot;Disabled&quot;\n&#125;\n</code></pre>\n<p><strong>tasks.json</strong></p>\n<pre><code class=\"json\">&#123;\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    // for the documentation about the tasks.json format\n    &quot;version&quot;: &quot;2.0.0&quot;,\n    &quot;tasks&quot;: [\n      &#123;\n        &quot;label&quot;: &quot;vm&quot;,\n        &quot;type&quot;: &quot;shell&quot;,\n        &quot;command&quot;: &quot;qemu-system-x86_64 -kernel $&#123;workspaceFolder&#125;/arch/x86/boot/bzImage -initrd ../rootfs.cpio.gz -S -s -nographic -append \\&quot;console=ttyS0\\&quot;&quot;,\n        &quot;presentation&quot;: &#123;\n          &quot;echo&quot;: true,\n          &quot;clear&quot;: true,\n          &quot;group&quot;: &quot;vm&quot;\n        &#125;,\n        &quot;isBackground&quot;: true,\n        &quot;problemMatcher&quot;: [\n          &#123;\n            &quot;pattern&quot;: [\n              &#123;\n                &quot;regexp&quot;: &quot;.&quot;,\n                &quot;file&quot;: 1,\n                &quot;location&quot;: 2,\n                &quot;message&quot;: 3\n              &#125;\n            ],\n            &quot;background&quot;: &#123;\n              &quot;activeOnStart&quot;: true,\n              &quot;beginsPattern&quot;: &quot;.&quot;,\n              &quot;endsPattern&quot;: &quot;.&quot;,\n            &#125;\n          &#125;\n        ]\n      &#125;,\n      &#123;\n        &quot;label&quot;: &quot;build linux&quot;,\n        &quot;type&quot;: &quot;shell&quot;,\n        &quot;command&quot;: &quot;make&quot;,\n        &quot;group&quot;: &#123;\n          &quot;kind&quot;: &quot;build&quot;,\n          &quot;isDefault&quot;: true\n        &#125;,\n        &quot;presentation&quot;: &#123;\n          &quot;echo&quot;: false,\n          &quot;group&quot;: &quot;build&quot;\n        &#125;\n      &#125;\n    ]\n&#125;\n</code></pre>\n<h3 id=\"start-kernel分析\"><a href=\"#start-kernel分析\" class=\"headerlink\" title=\"start_kernel分析\"></a>start_kernel分析</h3><p>Linux内核的起点是start_kernel函数，因此先在start_kernel处打断点，启动调试，程序在断点处暂停，从start_kernel开始进行跟踪分析。单步跳过进行跟踪分析，发现0号进程init_task被设为整个系统的初始进程，即0号进程是手工创建的，其他进程都是0号进程创建的。在内核引导时，init_task会被创建并启动，是所有其他进程的起点。</p>\n<p><img data-src=\"/start-kernel%E5%88%86%E6%9E%90/image-20230322182527537.png\"></p>\n<p>继续单步跳过，start_kernel执行各种初始化操作。</p>\n<p><img data-src=\"/start-kernel%E5%88%86%E6%9E%90/image-20230322182615765.png\"></p>\n<p>在start_kernel()函数末尾，arch_call_rest_init()函数体内为rest_init()函数，因此设置一个rest_init函数断点，进入rest_init函数体内，该函数由0号进程执行。</p>\n<p><img data-src=\"/start-kernel%E5%88%86%E6%9E%90/image-20230322182637929.png\"></p>\n<p>kernel_thread函数创建kernel_init，对应1号进程，是所有用户进程的祖先。</p>\n<p><img data-src=\"/start-kernel%E5%88%86%E6%9E%90/image-20230322182654775.png\"></p>\n<p>接着kernel_thread函数创建kthreadd，对应2号进程，是所有内核进程的祖先。</p>\n<p><img data-src=\"/start-kernel%E5%88%86%E6%9E%90/image-20230322182731769.png\"></p>\n<p>进入kernel_thread函数查看，该函数通过do_fork函数创建进程。通过kernel_thread函数代码可以看到1号进程和2号进程最终都是通过do_fork创建的，用户态通过系统调用fork创建一个进程最终也是通过do_fork来完成的。</p>\n<p><img data-src=\"/start-kernel%E5%88%86%E6%9E%90/image-20230322182849414.png\"></p>\n<p>进程的创建过程大致是父进程通过fork系统调用进入内核_do_fork函数，复制进程描述符及相关进程资源（采用写时复制技术）、分配子进程的内核堆栈并对内核堆栈和thread等进程关键上下文进行初始化，最后将子进程放入就绪队列，fork系统调用返回；而子进程则在被调度执行时根据设置的内核堆栈和thread等进程关键上下文开始执行。</p>\n<p>查看kernel_init函数定义，如下图的代码实现部分会调用run_init_process函数。</p>\n<p><img data-src=\"/start-kernel%E5%88%86%E6%9E%90/image-20230322183036095.png\"></p>\n<p>run_init_process函数如下，其中do_execve用于加载可执行文件、运行init程序并执行exec系统调用。1号进程完成用户态初始化。</p>\n<p><img data-src=\"/start-kernel%E5%88%86%E6%9E%90/image-20230322183100553.png\"></p>\n<p>查看kthreadd函数定义。2号进程创建并完成初始化。</p>\n<p><img data-src=\"/start-kernel%E5%88%86%E6%9E%90/image-20230322183119712.png\"></p>\n",
            "tags": [
                "计算机科学",
                "Linux"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/03/12/computer-science/RISCV%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/",
            "url": "https://hdqjl317.github.io/2023/03/12/computer-science/RISCV%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/",
            "title": "RISCV汇编代码分析",
            "date_published": "2023-03-12T12:22:27.000Z",
            "content_html": "<h2 id=\"实验步骤\"><a href=\"#实验步骤\" class=\"headerlink\" title=\"实验步骤\"></a>实验步骤</h2><h4 id=\"1-安装RISC-V的交叉编译器\"><a href=\"#1-安装RISC-V的交叉编译器\" class=\"headerlink\" title=\"1.安装RISC-V的交叉编译器\"></a>1.安装RISC-V的交叉编译器</h4><pre><code class=\"shell\">sudo apt-get install gcc-riscv64-linux-gnu\n</code></pre>\n<p><img data-src=\"/../../../../hugo/site/myblogs/content/post/RISC-V/pic/image-20230312205620329.png\" alt=\"image-20230312205620329\"></p>\n<h4 id=\"2-编写一个测试程序\"><a href=\"#2-编写一个测试程序\" class=\"headerlink\" title=\"2.编写一个测试程序\"></a>2.编写一个测试程序</h4><p><img data-src=\"/../../../../hugo/site/myblogs/content/post/RISC-V/pic/image-20230312205719027.png\" alt=\"image-20230312205719027\"></p>\n<h4 id=\"3-生成RISC-V的汇编代码\"><a href=\"#3-生成RISC-V的汇编代码\" class=\"headerlink\" title=\"3.生成RISC-V的汇编代码\"></a>3.生成RISC-V的汇编代码</h4><pre><code class=\"shell\">riscv64-linux-gnu-gcc -S -o risc_test.s risc_test.c\n</code></pre>\n<p><img data-src=\"/../../../../hugo/site/myblogs/content/post/RISC-V/pic/image-20230312205952918.png\" alt=\"image-20230312205952918\"><img data-src=\"/../../../../hugo/site/myblogs/content/post/RISC-V/pic/image-20230312210023794.png\" alt=\"image-20230312210023794\"></p>\n<p><img data-src=\"/../../../../hugo/site/myblogs/content/post/RISC-V/pic/image-20230312210039519.png\" alt=\"image-20230312210039519\"></p>\n<h4 id=\"4-分析汇编代码\"><a href=\"#4-分析汇编代码\" class=\"headerlink\" title=\"4.分析汇编代码\"></a>4.分析汇编代码</h4><pre><code class=\"shell\">    .file\t&quot;risc_test.c&quot; \t; 原C代码文件名\n    .option nopic\n    .text\n    .align\t1\t\t\t\t\n    .globl\tg\t\t\t\t; g为全局符号\n    .type\tg, @function\t; g定义为函数\ng:\n    add\tsp,sp,-32\t\t\t; sp = sp - 32, sp为栈顶指针\n    sd\ts0,24(sp)\t\t\t; s0的值保存在sp+24的地址中， s0为栈底指针\n    add\ts0,sp,32\t\t\t; s0 = sp + 32\n    mv\ta5,a0\t\t\t\t; a5 = a0 \n    sw\ta5,-20(s0)\t\t\t; a5的值保存在s0-20的地址中\n    lw\ta5,-20(s0)\t\t\t; 将s0-20地址中的值保存在a5\n    addw\ta5,a5,3\t\t\t; a5 = a5 + 3\n    sext.w\ta5,a5\n    mv\ta0,a5\t\t\t\t; g函数的返回a5保存在a0中用于返回\n    ld\ts0,24(sp)\t\t\t; s0 = sp + 24，恢复栈底指针原值\n    add\tsp,sp,32\t\t\t; 恢复栈顶指针原值\n    jr\tra\t\t\t\t\t; 跳转，函数返回\n    .size\tg, .-g\n    .align\t1\n    .globl\tf\t\t\t\t; f为全局符号\n    .type\tf, @function\t; f定义为函数\nf:\n    add\tsp,sp,-32\t\t\t; sp = sp - 32, sp为栈顶指针\n    sd\tra,24(sp)\t\t\t; ra的值（返回地址）保存在sp+24的地址中\n    sd\ts0,16(sp)\t\t\t; s0的值保存在sp+16的地址中， s0为栈底指针\n    add\ts0,sp,32\t\t\t; s0 = sp + 32\n    mv\ta5,a0\t\t\t\t; a5 = a0,保存函数传入进来的的参数\n    sw\ta5,-20(s0)a\t\t\t; a5的值存放到s0-20指向的地址中\n    lw\ta5,-20(s0)\t\t\t; 将s0-20地址中的值存放到a5中\n    mv\ta0,a5\t\t\t\t; a0 = a5保存调用g函数的待传的参数\n    call\tg\t\t\t\t; 调用g函数\n    mv\ta5,a0\t\t\t\t; a5 = a0\n    mv\ta0,a5\t\t\t\t; a0 = a5, f函数的返回值保存在a0中\n    ld\tra,24(sp)\t\t\t; ra = sp + 24, 得到返回地址\n    ld\ts0,16(sp)\t\t\t; s0 = sp + 16, 将sp+16的值重新存储到s0栈底指针中，指向main函数的栈空间\n    add\tsp,sp,32\t\t\t; sp = sp + 32, 指向main函数栈空间栈顶\n    jr\tra\t\t\t\t\t; 函数返回，回到mian函数\n    .size\tf, .-f\n    .align\t1\n    .globl\tmain\n    .type\tmain, @function\nmain:\n    add\tsp,sp,-16\t\t\t; sp = sp - 16\n    sd\tra,8(sp)\t\t\t; ra存放的返回地址值放到sp+8\n    sd\ts0,0(sp)\t\t\t; s0为栈底指针，将s0的值存放到sp指向的地址中\n    add\ts0,sp,16\t\t\t; s0=sp+16，构造main函数的栈空间\n    li\ta0,8\t\t\t\t; 保存函数调用的待传参数\n    call\tf\t\t\t\t; 调用f函数\n    mv\ta5,a0\t\t\t\t; a5 = a0, f函数返回值保存到a5中\n    addw\ta5,a5,1\t\t\t; a5 = a5 + 1\n    sext.w\ta5,a5\n    mv\ta0,a5\t\t\t\t; a0 = a5, 保存main函数的返回值\n    ld\tra,8(sp)\t\t\t; 得到返回地址\n    ld\ts0,0(sp)\t\t\t; 恢复栈底指针\n    add\tsp,sp,16\t\t\t; 恢复栈顶指针\n    jr\tra\t\t\t\t\t; 函数返回\n    .size\tmain, .-main\n    .ident\t&quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "RISCV"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/03/08/computer-science/Rust%E5%AE%8F/",
            "url": "https://hdqjl317.github.io/2023/03/08/computer-science/Rust%E5%AE%8F/",
            "title": "Rust宏",
            "date_published": "2023-03-08T12:31:06.000Z",
            "content_html": "<h3 id=\"宏和函数的区别\"><a href=\"#宏和函数的区别\" class=\"headerlink\" title=\"宏和函数的区别\"></a>宏和函数的区别</h3><p>宏和函数的区别并不少，而且对于宏擅长的领域，函数其实是有些无能为力的。</p>\n<h4 id=\"元编程\"><a href=\"#元编程\" class=\"headerlink\" title=\"元编程\"></a>元编程</h4><p>从根本上来说，宏是通过一种代码来生成另一种代码，如果大家熟悉元编程，就会发现两者的共同点。</p>\n<p><code>derive</code> 属性会自动为结构体派生出相应特征所需的代码，例如 <code>#[derive(Debug)]</code>，还有熟悉的 <code>println!</code> 和 <code>vec!</code>，所有的这些宏都会展开成相应的代码，且很可能是长得多的代码。</p>\n<p>总之，元编程可以帮我们减少所需编写的代码，也可以一定程度上减少维护的成本，虽然函数复用也有类似的作用，但是宏依然拥有自己独特的优势。</p>\n<h4 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h4><p>Rust 的函数签名是固定的：定义了两个参数，就必须传入两个参数，多一个少一个都不行，对于从 JS&#x2F;TS 过来的同学，这一点其实是有些恼人的。而宏就可以拥有可变数量的参数，例如可以调用一个参数的 <code>println!(&quot;hello&quot;)</code>，也可以调用两个参数的 <code>println!(&quot;hello &#123;&#125;&quot;, name)</code>。</p>\n<h4 id=\"宏展开\"><a href=\"#宏展开\" class=\"headerlink\" title=\"宏展开\"></a>宏展开</h4><p>由于宏会被展开成其它代码，且这个展开过程是发生在编译器对代码进行解释之前。因此，宏可以为指定的类型实现某个特征：先将宏展开成实现特征的代码后，再被编译。而函数就做不到这一点，因为它直到运行时才能被调用，而特征需要在编译期被实现。</p>\n<h4 id=\"宏的缺点\"><a href=\"#宏的缺点\" class=\"headerlink\" title=\"宏的缺点\"></a>宏的缺点</h4><p>相对函数来说，由于宏是基于代码再展开成代码，因此实现相比函数来说会更加复杂，再加上宏的语法更为复杂，最终导致定义宏的代码相当地难读，也难以理解和维护。</p>\n<h3 id=\"宏的分类\"><a href=\"#宏的分类\" class=\"headerlink\" title=\"宏的分类\"></a>宏的分类</h3><p>​\t\tRust 中的宏相较C&#x2F;C++更为强大。C&#x2F;C++ 中的宏在预处理阶段可以展开为文本，Rust 的宏则是对语法的扩展，是在构建语法树时，才展开的宏。</p>\n<p>​\t\tRust 中宏可以分为很多类，包括通过 macro_rules 定义的<strong>声明式宏</strong>和三种<strong>过程式宏</strong>。</p>\n<ul>\n<li>声明式宏（Declarative macros）使得你能够写出类似 match 表达式的东西，来操作你所提供的 Rust 代码。它使用你提供的代码来生成用于替换宏调用的代码。</li>\n<li>过程宏（Procedural macros）允许你操作给定 Rust 代码的抽象语法树（abstract syntax tree, AST）。过程宏是从一个（或者两个）<code>TokenStream</code>到另一个<code>TokenStream</code>的函数，用输出的结果来替换宏调用。</li>\n</ul>\n<p>有三种类型的过程宏：</p>\n<ul>\n<li>派生宏（Derive macros）：适用于结构、枚举和联合，并使用<code>#[derive(MyMacro)]</code>声明进行注释。它们还可以声明辅助属性，这些属性可以附加到项目的成员（例如枚举变体或结构字段）。</li>\n<li>类属性式宏（Attribute-like macros）：类属性式宏能够让你创建一个自定义的属性，该属性将其自身关联一个项（item），并允许对该项进行操作。它也可以接收参数。类似于派生宏，但可以附加到更多项，例如特征定义和函数。</li>\n<li>类函数式宏（Function-like macros）：类函数宏类似于声明式宏，因为它们是用宏调用运算符调用的<code>!</code>，看起来像函数调用。它们对您放在括号内的代码进行操作。</li>\n</ul>\n<h3 id=\"声明宏的用法\"><a href=\"#声明宏的用法\" class=\"headerlink\" title=\"声明宏的用法\"></a>声明宏的用法</h3><p>在Rust中，应用最广泛的一种宏就是声明式宏，类似于模式匹配的写法，将传入的 Rust 代码与预先指定的模式进行比较，在不同模式下生成不同的代码。</p>\n<p>使用<code>macro_rules!</code>来定义一个声明式宏。</p>\n<p>最基础的例子是很常见的<code>vec!</code>：</p>\n<pre><code class=\"rust\">let v: Vec&lt;u32&gt; = vec![1, 2, 3];\n</code></pre>\n<p>简化版的定义是（实际的版本有其他分支，而且该分支下要预先分配内存防止在push时候再动态分划）</p>\n<pre><code class=\"rust\">#[macro_export]\nmacro_rules! vec &#123;\n    ( $( $x:expr ),* ) =&gt; &#123;\n        &#123;\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        &#125;\n    &#125;;\n&#125;\n</code></pre>\n<p>::: <code>$( $x:expr ),*</code>和<code>$( $x:expr,)*</code>的区别是什么？</p>\n<p>前者，最后的<code>,</code>是MacroRepSep，意味着 <code>1,2,3</code>是一个合法的序列。</p>\n<p>后者，最后的<code>,</code>是MacroMatch的一部分，意味着 <code>1,2,3,</code>才是一个合法的序列。</p>\n<p><code>#[macro_export]</code>标签是用来声明：只要 use 了这个crate，就可以使用该宏。同时包含被 export 出的宏的模块，在声明时必须放在前面，否则靠前的模块里找不到这些宏。</p>\n<p>按照官方文档的说法，<code>macro_rules!</code>目前有一些设计上的问题，日后将推出新的机制来取代他。但是他依然是一个很有效的语法扩展方法。</p>\n<p>这里一个注意点是：如果想要创建临时变量，那么必须要像上面这个例子这样，放在某个块级作用域内，以便自动清理掉，否则会认为是不安全的行为。</p>\n<h3 id=\"声明宏的限制\"><a href=\"#声明宏的限制\" class=\"headerlink\" title=\"声明宏的限制\"></a>声明宏的限制</h3><p>声明式宏有一些限制，有些是与 Rust 宏本身有关，有些则是声明式宏所特有的：</p>\n<ul>\n<li>缺少对宏的自动完成和展开的支持</li>\n<li>声明式宏调式困难</li>\n<li>修改能力有限</li>\n<li>更大的二进制</li>\n<li>更长的编译时间（这一条对于声明式宏和过程宏都存在）</li>\n</ul>\n<h3 id=\"过程宏的使用\"><a href=\"#过程宏的使用\" class=\"headerlink\" title=\"过程宏的使用\"></a>过程宏的使用</h3><ol>\n<li>cargo new custom   新建一个名为custom的工程。</li>\n<li>cd custom &amp;&amp; cargo new custom-derive  在custom内新建一个名为custom-derive 用于编写过程宏。</li>\n</ol>\n<p>custom  Cargo.toml</p>\n<pre><code class=\"toml\">[package]\nname = &quot;custom&quot;\nversion = &quot;0.1.0&quot;\n[dependencies]\ncustom-derive=&#123;path=&quot;custom-derive&quot;&#125;\n</code></pre>\n<p>custom-derive  Cargo.toml</p>\n<pre><code class=\"toml\">[package]\nname=&quot;custom-derive&quot;\nversion=&quot;0.1.0&quot;\n\n[lib]\nproc-macro = true   # 使用过程宏\n\n[dependencies]\n# quote = &quot;1.0.9&quot;                 # 目前没用到，先注释了\n# proc-macro2 = &quot;1.0.27&quot; \n# syn = &#123;version=&quot;1.0.72&quot;, features=[&quot;full&quot;]&#125;\n</code></pre>\n<p>项目结构：</p>\n<pre><code>.\n├── Cargo.toml\n├── custom-derive\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── src\n│   └── main.rs\n</code></pre>\n<ol start=\"3\">\n<li>lib.rs</li>\n</ol>\n<pre><code class=\"rust\">use proc_macro::TokenStream;\n\nextern crate proc_macro;\n\n// 函数式宏\n#[proc_macro]\npub fn make_hello(item: TokenStream) -&gt; TokenStream &#123;\n    let name = item.to_string();\n    let hell = &quot;Hello &quot;.to_string() + name.as_ref();\n    let fn_name =\n        &quot;fn hello_&quot;.to_string() + name.as_ref() + &quot;()&#123; println!(\\&quot;&quot; + hell.as_ref() + &quot;\\&quot;); &#125;&quot;;\n    fn_name.parse().unwrap()\n&#125;\n\n// 属性宏 （两个参数）\n#[proc_macro_attribute]\npub fn log_attr(attr:TokenStream, item:TokenStream)-&gt;TokenStream&#123;\n    println!(&quot;Attr:&#123;&#125;&quot;, attr.to_string());\n    println!(&quot;Item:&#123;&#125;&quot;, item.to_string());\n    item\n&#125;\n\n\n// 派生宏\n#[proc_macro_derive(Hello)]\npub fn hello_derive(input: TokenStream)-&gt; TokenStream &#123;\n    println!(&quot;&#123;:?&#125;&quot;, input);\n    TokenStream::new()  \n    // 如果直接返回input，编译会报重复定义，说明派生宏用于扩展定义\n    // input   \n&#125;\n</code></pre>\n<p><code>TokenStream</code> 相当编译过程中的语法树的流。</p>\n<ol start=\"4\">\n<li>main.rs</li>\n</ol>\n<pre><code class=\"rust\">extern crate custom_derive;\nuse custom_derive::log_attr;\nuse custom_derive::make_hello;\nuse custom_derive::Hello;\n\nmake_hello!(world);\nmake_hello!(张三);\n\n#[log_attr(struct, &quot;world&quot;)]\nstruct Hello&#123;\n    pub name: String,\n&#125;\n\n#[log_attr(func, &quot;test&quot;)]\nfn invoked()&#123;&#125;\n\n\n#[derive(Hello)]\nstruct World;\n\nfn main() &#123;\n    // 使用make_hello生成\n    hello_world();\n    hello_张三();\n&#125;\n</code></pre>\n<p>make_hello 使用<code>#[proc_macro]</code> ，定义自动生成一个传入参数函数。</p>\n<pre><code class=\"shell\">Hello world\nHello 张三\n</code></pre>\n<p>log_attr 使用<code>#[proc_macro_attribute]</code> ，编译期间会打印结构类型和参数，后面可用修改替换原属性定义。</p>\n<pre><code class=\"shell\">Attr:struct, &quot;world&quot;                                  \nItem:struct Hello &#123; pub name : String, &#125;\nAttr:func, &quot;test&quot;\nItem:fn invoked() &#123; &#125;\n</code></pre>\n<p>#[derive(Hello)]  使用<code>#[proc_macro_derive(Hello)]</code>·，会打印当前TokenStream 结点流，可以和 syn 与 quto 库结合，扩展定义。</p>\n<pre><code class=\"shell\">TokenStream [Ident &#123; ident: &quot;struct&quot;, span: #0 bytes(286..292) &#125;, Ident &#123; ident: &quot;World&quot;, span: #0 bytes(293..298) &#125;, Punct &#123; ch: &#39;;&#39;, spacing: Alone, span: #0 bytes(298..299) &#125;]\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "C2Rust"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/03/08/computer-science/Rust%E8%BF%87%E7%A8%8B%E5%AE%8F/",
            "url": "https://hdqjl317.github.io/2023/03/08/computer-science/Rust%E8%BF%87%E7%A8%8B%E5%AE%8F/",
            "title": "Rust过程宏",
            "date_published": "2023-03-08T12:29:54.000Z",
            "content_html": "<p>过程宏，它更像函数，接受一些代码作为参数输入，然后对他们进行加工，生成新的代码，他不是在做声明式宏那样的模式匹配。三种过程式宏都是这种思路。</p>\n<p>过程宏分为三种：</p>\n<ul>\n<li>派生宏（Derive macro）：用于结构体（struct）、枚举（enum）、联合（union）类型，可为其实现函数或特征（Trait）。</li>\n<li>属性宏（Attribute macro）：用在结构体、字段、函数等地方，为其指定属性等功能。如标准库中的#[inline]、#[derive(…)]等都是属性宏。</li>\n<li>函数式宏（Function-like macro）：用法与普通的规则宏类似，但功能更加强大，可实现任意语法树层面的转换功能。</li>\n</ul>\n<p>不能在原始的crate中直接写过程式宏，需要把过程式宏放到一个单独的crate中（以后可能会消除这种约定）。定义过程式宏的方法如下：</p>\n<pre><code class=\"rust\">use proc_macro;\n\n#[some_attribute]\npub fn some_name(input: TokenStream) -&gt; TokenStream &#123;\n&#125;\n</code></pre>\n<p>需要引入<code>proc_macro</code> 这个 crate，然后标签是用来声明它是哪种过程式宏的，接着就是一个函数定义，函数接受 <code>TokenStream</code>，返回 <code>TokenStream</code>。<code>TokenStream</code> 类型就定义在 <code>proc_macro</code> 包中，表示 token 序列。除了标准库中的这个包，还可以使用<code>proc_macro2</code> 包，使用 <code>proc_macro2::TokenStream::from()</code> 和 <code>proc_macro::TokenStream::from()</code> 可以很便捷地在两个包的类型间进行转换。使用 <code>proc_macro2</code> 的好处是可以在过程宏外部使用 <code>proc_macro2</code> 的类型，相反 <code>proc_macro</code> 中的类型只可以在过程宏的上下文中使用。且 <code>proc_macro2</code> 写出的宏更容易编写测试代码。</p>\n<p>下面详细说明如何定义三类过程宏。</p>\n<h3 id=\"Custom-Derive-宏\"><a href=\"#Custom-Derive-宏\" class=\"headerlink\" title=\"Custom Derive 宏\"></a>Custom Derive 宏</h3><p>在本节中，我们的目的是实现下面的代码，使用编译器为我们生成名为 <code>HelloMacro</code> 的 <code>Trait</code></p>\n<pre><code class=\"rust\">use hello_macro::HelloMacro;\nuse hello_macro_derive::HelloMacro;\n\n#[derive(HelloMacro)]\nstruct Pancakes;\n\nfn main() &#123;\n    Pancakes::hello_macro();\n&#125;\n</code></pre>\n<p>该 <code>Trait</code> 的定义如下，目的是打印实现该宏的类型名</p>\n<pre><code class=\"rust\">pub trait HelloMacro &#123;\n    fn hello_macro();\n&#125;\n</code></pre>\n<p>由于过程宏不能在原 crate 中实现，我们需要如下在 <code>hello_crate</code> 的目录下新建一个 <code>hello_macro_derive</code> crate</p>\n<pre><code class=\"bash\">cargo new hello_macro_derive --lib\n</code></pre>\n<p>在新的 crate 内，我们需要修改 <code>Cargo.toml</code> 配置文件，</p>\n<pre><code class=\"toml\">[lib]\nproc-macro = true\n\n[dependencies]\nsyn = &quot;1.0&quot;\nquote = &quot;1.0&quot;\n</code></pre>\n<p>在 <code>src/lib.rs</code> 中可以着手实现该宏，其中 <code>syn</code> 是用来解析 rust 代码的，而quote则可以用已有的变量生成代码的 <code>TokenStream</code>，可以认为 <code>quote!</code> 宏内的就是我们想要生成的代码</p>\n<pre><code class=\"rust\">extern crate proc_macro;\n\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn;\n\n#[proc_macro_derive(HelloMacro)]\npub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream &#123;\n    // Construct a representation of Rust code as a syntax tree\n    // that we can manipulate\n    let ast = syn::parse(input).unwrap();\n\n    // Build the trait implementation\n    impl_hello_macro(&amp;ast)\n&#125;\n\nfn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream &#123;\n    let name = &amp;ast.ident;\n    let gen = quote! &#123;\n        impl HelloMacro for #name &#123;\n            fn hello_macro() &#123;\n                println!(&quot;Hello, Macro! My name is &#123;&#125;!&quot;, stringify!(#name));\n            &#125;\n        &#125;\n    &#125;;\n    gen.into()\n&#125;\n</code></pre>\n<p>另外，<strong>Custom Derive 宏可以携带Attributes，称为 Derive macro helper attributes</strong>，具体编写方法可以参考 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvcHJvY2VkdXJhbC1tYWNyb3MuaHRtbCNkZXJpdmUtbWFjcm8taGVscGVyLWF0dHJpYnV0ZXM=\">Reference</span>（Rust 中共有<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvYXR0cmlidXRlcy5odG1s\">四类 Attributes</span>）。关于 Derive macro helper attributes 这里有一个坑就是<strong>在使用 <code>cfg_attr</code> 时，需要把 Attributes 放在宏之前。</strong></p>\n<p>举个例子：</p>\n<p>使用 kube-rs 可以很方便地定义 CRD（Custom Resource Definition）：</p>\n<pre><code class=\"rust\">#[derive(CustomResource, Clone, Debug, Deserialize, Serialize, JsonSchema)]\n#[kube(group = &quot;clux.dev&quot;, version = &quot;v1&quot;, kind = &quot;Foo&quot;, namespaced)]\nstruct FooSpec &#123;\n    info: String,\n&#125;\n</code></pre>\n<p>我第一反应是 <code>#[kube]</code> 是一个 Attribute-Like 宏，但是查阅 kube-rs 文档才发现它其实是 <code>CustomResource</code> Custom Derive 宏的 Attribute。这里我们想用 <code>cfg_attr</code> 来控制是否去做 derive，一开始就想当然地这么写了：</p>\n<pre><code class=\"rust\">#[cfg_attr(feature=&quot;use_kube_rs&quot;,\n    derive(CustomResource, Clone, Debug, Deserialize, Serialize, JsonSchema),\n    kube(group = &quot;clux.dev&quot;, version = &quot;v1&quot;, kind = &quot;Foo&quot;, namespaced)\n)]\nstruct FooSpec &#123;\n    info: String,\n&#125;\n</code></pre>\n<p>然而这是错误的打开方式，需要写成：</p>\n<pre><code class=\"rust\">#[cfg_attr(feature=&quot;use_kube_rs&quot;,\n    kube(group = &quot;clux.dev&quot;, version = &quot;v1&quot;, kind = &quot;Foo&quot;, namespaced),\n    derive(CustomResource, Clone, Debug, Deserialize, Serialize, JsonSchema)\n)]\nstruct FooSpec &#123;\n    info: String,\n&#125;\n</code></pre>\n<p>Attributes 需要写在宏的 derive 前面。</p>\n<h3 id=\"Attribute-Like-宏\"><a href=\"#Attribute-Like-宏\" class=\"headerlink\" title=\"Attribute-Like 宏\"></a>Attribute-Like 宏</h3><p>attribute-like 宏和 custom derive 宏很相似，只是标签可以自定义，更加灵活，甚至可以使用在函数上。他的使用方法如下，比如假设有一个宏为 <code>route</code> 的宏</p>\n<pre><code class=\"rust\">#[route(GET, &quot;/&quot;)] \nfn index() &#123; ... &#125;\n</code></pre>\n<p>按下面的语法定义 <code>route</code> 宏</p>\n<pre><code class=\"rust\">#[proc_maco_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream &#123; ... &#125;\n</code></pre>\n<p>其中 <code>attr</code> 参数是上面的 <code>Get</code>，<code>&quot;/&quot;</code> ；<code>item</code> 参数是 <code>fn index()&#123;&#125;</code> 。</p>\n<h3 id=\"Function-Like-宏\"><a href=\"#Function-Like-宏\" class=\"headerlink\" title=\"Function-Like 宏\"></a>Function-Like 宏</h3><p>这种宏看上去和 <code>macro_rules!</code> 比较类似，但是在声明式宏只能用 <code>match</code> 去做模式匹配，但是在这里可以有更复杂的解析方式，所以可以写出来</p>\n<pre><code class=\"rust\">let sql = sql!(SELECT * FROM posts WHERE id=1);\n</code></pre>\n<p>上面这个 <code>sql</code> 宏的定义方法如下</p>\n<pre><code class=\"rust\">#[proc_macro]\npub fn sql(input: TokenStream) -&gt; TokenStream &#123; ... &#125;\n</code></pre>\n<h2 id=\"好用的库\"><a href=\"#好用的库\" class=\"headerlink\" title=\"好用的库\"></a>好用的库</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9wcm9jX21hY3JvL2luZGV4Lmh0bWw=\">proc_macro</span>：默认 token 流库，只能在过程宏中使用，编译器要用它，将它作为过程宏的返回值，大多数情况我们不需要，只需要在宏返回结果的时候把 <code>proc_macro2::TokenSteam</code> 的流 <code>into()</code> 到 <code>proc_macro::TokenSteam</code> 就行了。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcmF0ZXMuaW8vY3JhdGVzL3Byb2NfbWFjcm8y\">proc_macro2</span>：我们真正在使用的过程宏库，可以在过程宏外使用。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcmF0ZXMuaW8vY3JhdGVzL3N5bg==\">syn</span>：过程宏左护法，可以将 <code>TokenStream</code> 解析成语法树，注意两个 <code>proc_macro</code> 和 <code>proc_macro</code> 都支持，需要看文档搞清楚库函数到底是在解析哪个库中的 <code>TokenStream</code>。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcmF0ZXMuaW8vY3JhdGVzL3F1b3Rl\">quote</span>：过程宏右护法，将语法树解析成 <code>TokenStream</code>。只要一个 <code>quote!&#123;&#125;</code> 就够了！<code>quote!&#123;&#125;</code> 宏内都是字面量，即纯纯的代码，要替换进去的变量是用的 <code>#</code> 符号标注，为了和声明宏中使用的 <code>$</code> 相区分（也就意味着用 <code>quote</code> 写过程宏的时候，可以和声明宏结合 🤤 ）。模式匹配时用到的表示重复的符号和声明宏中一样，是使用 <code>*</code>。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcmF0ZXMuaW8vY3JhdGVzL2Rhcmxpbmc=\">darling</span> 好用的标签宏解析库。</p>\n",
            "tags": [
                "计算机科学",
                "C2Rust"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2023/02/03/computer-science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/",
            "url": "https://hdqjl317.github.io/2023/02/03/computer-science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/",
            "title": "编译原理",
            "date_published": "2023-02-03T08:50:54.000Z",
            "content_html": "<h2 id=\"什么是编译器\"><a href=\"#什么是编译器\" class=\"headerlink\" title=\"什么是编译器\"></a>什么是编译器</h2><p>所谓编译原理，也就是编译器的工作原理，因此先要明白什么是编译器。编译器的基本定义是：将一门语言转换为另一门语言，一般指将高级语言转换为机器语言，但仅仅是转换并不执行。编译器最基本的底线，就是保证源代码和目标代码的语义相同。</p>\n<h3 id=\"在程序运行中的地位\"><a href=\"#在程序运行中的地位\" class=\"headerlink\" title=\"在程序运行中的地位\"></a>在程序运行中的地位</h3>\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165538192.png\"></p>\n<p>如上图。编译器就是将源代码转换（即翻译）为目标程序，然后再交给机器去执行，这个应该很好理解。之所以要转换，是因为计算机本质上只能识别机器代码，不能识别高级语言 。简单解释一下这张图的各个部分。</p>\n<ul>\n<li>“源代码”是 C java 等高级语言，每种程序对应的编译器可能都不一样</li>\n<li>“静态计算”是指编译器只根据程序文本静态的分析（如做报错分析、优化分析），而不是真的拿 CPU 去执行</li>\n<li>生成的“目标程序”可能是 x86 汇编（如对应 C 语言），也可能是 bytecode 字节码（如对应 java）</li>\n<li>“计算机”可能是一个 x86 的物理器（如对应 C 语言），也可能是 JVM java 虚拟机（如对应 java）。即不一定是一个真实的机器，可能是虚拟机，但这里都统称为“计算机”</li>\n</ul>\n<p>另外再解释一下编译器和另外一个常见的叫做“解释器”的对比。两者有很多共同点，但是有以下区别：</p>\n<ul>\n<li>编译器：输入源代码，输出的一个可执行程序，但不去执行（存放在磁盘上等待被加载到内存中执行）</li>\n<li>解释器：输入源代码，直接输出执行结果。其实 JVM 就是一个解释器，而不是一个单纯的编译器。输入 java 字节码 bytecode ，然后直接输出执行结果，而不是输出汇编代码。</li>\n</ul>\n<h3 id=\"内部结构\"><a href=\"#内部结构\" class=\"headerlink\" title=\"内部结构\"></a>内部结构</h3>\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165616680.png\"></p>\n<p>如上图，就是一个编译器最简单的内部结构（没有考虑代码优化过程）。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165702453.png\"></p>\n<p>如上图，这是一个更加复杂的编译器，各个过程都比较完备。其实拆开来看，编译器是一个“流水线”，由一个一个的小程序分流水线执行。因为编译器规模庞大复杂，拆分模块容易实现和维护。</p>\n<p>编译器通常会被划分为两个部分（如下图）：</p>\n<ul>\n<li><p>前端：源代码生成中间代码，和源代码有关</p>\n</li>\n<li><p>后端：中间代码生成目标代码并优化，和目标代码有关</p>\n</li>\n<li><p>两者以抽象语法树 AST 作为连接数据</p>\n</li>\n</ul>\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165702453.png\"></p>\n<h3 id=\"一个简单的例子\"><a href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"></a>一个简单的例子</h3><p>背景一，现在我们设计一个叫做 Sum 的语言，特别简单，仅仅支持两种语法。第一是整形数字 <code>n</code> ，第二是加法表达式 <code>e1 + e2</code> 。举几个例子：</p>\n<ul>\n<li><code>3</code></li>\n<li><code>5 + 6</code></li>\n<li><code>7 + 8 + 9</code> （加法要满足左结合性，即先计算 <code>7 + 8</code>）</li>\n<li><code>7 + (8 + 9)</code></li>\n<li>但不支持 <code>7 + 8 * 9</code> Sum 语言中没有乘法</li>\n</ul>\n<p>背景二，有一个栈试计算机 Stack （后面会再次讲到），其中有一个操作数栈，然后只支持两条指令 <code>push n</code> 和 <code>add</code> 。之所以选择栈式计算机，第一是因为简单，第二是因为 JVM 就是采用了这种形式。其指令的详情是：</p>\n<ul>\n<li><code>push 3</code> 将 3 压栈</li>\n<li><code>push 4</code> 将 4 压栈</li>\n<li><code>add</code> 将 3 和 4 出栈，然后做加法得到 7 ，再将 7 压栈。即将栈顶的两个元素都出栈，做加分，将结果再压栈</li>\n</ul>\n<p>有了上述两个背景之后，接下来的任务是：编译程序 <code>1 + 2 + 3</code> 到栈式计算机 Stack 。</p>\n<p>第一个阶段进行词法分析，先不管其中的原理是什么，总之词法分析会将 <code>1 + 2 + 3</code> 拆分为 <code>1</code> <code>+</code> <code>2</code> <code>+</code> <code>3</code> 这 5 个部分。<br>第二阶段是语法分析，就是将词法分析拆分出来的内容，分析是否满足 Sum 语言的语法要求，即 <code>e1 + e2</code> 这种语法。<br>第三个阶段是语法树构造，经过某些计算之后，得到的抽象语法树如下图。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165829650.png\"></p>\n<p>第四个阶段，根据抽象语法树做代码生成。首先，要满足加法的左结合性，对树进行遍历的时候就要优先遍历左子树，即<strong>后序遍历</strong>。在遍历树节点的过程中，如果遇到整数 <code>n</code> 就生成一条 <code>push n</code> 指令，如果遇到 <code>+</code> 就生成一条 <code>add</code> 指令。接下来详细看一下这棵树的遍历过程：</p>\n<ul>\n<li>第一步要访问的节点是 <code>1</code> ，生成 <code>push 1</code> ，将 1 压栈</li>\n<li>第二步要访问的节点是 <code>2</code> ，生成 <code>push 2</code> ，将 2 压栈</li>\n<li>第三步要访问的节点是 <code>+</code> ，生成 <code>add</code> ，将 1 2 出栈，计算加法得到 3 ，将 3 压栈 （这里即体现了加法的左结合性）</li>\n<li>第四步要访问的节点是 <code>3</code> ，生成 <code>push 3</code> ，将 3 压栈</li>\n<li>第五步要访问的节点是 <code>+</code> ，生成 <code>add</code> ，将 3 3 出栈，计算加法得到 6 ，将 6 压栈，完成</li>\n</ul>\n<hr>\n<h2 id=\"词法分析\"><a href=\"#词法分析\" class=\"headerlink\" title=\"词法分析\"></a>词法分析</h2><p>从编译器内部结构得知，执行编译的第一个阶段就是词法分析。<strong>输入是源程序代码，输出一个记号（即 token）流或者单词流</strong>。通俗来说，就是将源代码进行最细粒度的拆解，例如上面的例子将 <code>1 + 2 + 3</code> 拆分为 <code>1</code> <code>+</code> <code>2</code> <code>+</code> <code>3</code> 一样。</p>\n<h3 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h3>\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201165938490.png\"></p>\n<p>如上图。从源代码到记号流（或单词流），记号就是 token 。词法分析器会将源程序根据关键字、标识符（变量）、括号、引号、运算符、值（整数、字符串）等这些要素，将其从左到右拆分为若干个记号（或者单词），其中会忽略空格和换行等。上图中：</p>\n<ul>\n<li><code>IF</code> 关键字</li>\n<li><code>LPAREN</code> <code>RPAREN</code> 左右括号</li>\n<li><code>INDENT(x)</code> 即标识符（变量），有一个属性 <code>x</code> ，表示变量名</li>\n<li><code>GR</code> 即 <code>&gt;</code></li>\n<li><code>INT(t)</code> 即 <code>int</code> 类型值，属性是 <code>5</code></li>\n<li>其他同理……</li>\n<li>最后红色的 <code>EOF</code> 是结束符</li>\n</ul>\n<p>根据上面的例子，可以总结出 token 其实有固定的形式，就可以定义其数据结构，如下图（本文中高级语言的示例，默认情况下都是 C 语言）</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170050889.png\"></p>\n<p>理解了例子，定义了数据，接下来就要去探寻词法分析的实现算法，第一，手工构造；第二，自动生成 。</p>\n<h3 id=\"词法分析的手工构造法\"><a href=\"#词法分析的手工构造法\" class=\"headerlink\" title=\"词法分析的手工构造法\"></a>词法分析的手工构造法</h3><p>手工构造即手写一个词法分析器，例如 GCC LLVM ，优点是利于掌控和优化细节，缺点是工作量大、易出错。手工构造法主要用到“转移图”这种数据结构，下面举两个例子说明。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170106446.png\"></p>\n<p>上图的转移图模型，即可识别逻辑运算符，如 <code>&lt;=</code> <code>&lt;</code> <code>&lt;&gt;</code> <code>&gt;=</code> <code>&gt;</code> 。识别到第一个字符，就继续往下做分支判断，直到返回一个确定的运算符。图中的 <code>*</code> 即一次回溯，即将当前的这个字符再返回到词法分析器重新进行分析。例如 <code>&gt;1</code> ，读到了 <code>1</code> 这个字符时，此时已经确定了运算符是 <code>&gt;</code> ，而当前的 <code>1</code> 并不是运算符的一部分，因此将 <code>1</code> 再重新返回到词法分析器中重新进行分析。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170142816.png\"></p>\n<p>上图是标识符（变量）的转移图模型，以及伪代码。其中 <code>*</code> 即一次回溯，跟上面一样。</p>\n<p>关键字（如 <code>class</code> <code>if</code> <code>for</code> 等）是一种特殊的标识符，也满足标识符的规则。要识别关键字，有两种解决方案：</p>\n<ul>\n<li>继续扩展转移图的分支，识别到关键字走不通的分支逻辑，最后识别出关键字。</li>\n<li>先识别所有的合法标识符，然后从已经识别出来的标识符中查找关键字。此时需要为该语言所有的关键字维护一个哈希表，如果数据结构合理（完美哈希），查询可以在 <code>O(1)</code> 复杂度内完成。</li>\n</ul>\n<h3 id=\"词法分析的自动生成技术\"><a href=\"#词法分析的自动生成技术\" class=\"headerlink\" title=\"词法分析的自动生成技术\"></a>词法分析的自动生成技术</h3><p>所谓自动生成技术，就是有这样现成的工具（如 lex flex jlex），输入一些声明式的规范，即可自动生成一个词法分析器。有点当然是简单快速，缺点就是无法控制细节。而这里的“声明式规范”，就是我们常见的正则表达式。下文的内容，就是如何用程序去解析正则表达式，如果你之前看过关于“正则表达式 原理”这类的文章，可能早就有了解了。</p>\n<p>先说一下自动生成技术的几个阶段，专业术语后面都有解释：</p>\n<ul>\n<li>正则表达式 -&gt; NFA</li>\n<li>NFA -&gt; DFA</li>\n<li>DFA -&gt; 词法分析代码，即完成自动生成</li>\n</ul>\n<h4 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h4><p>不要以为用过正则表达式就觉得它很简单了，如果你是通过看“30 分钟入门正则表达式”这类文章开始接触的，还是建议你仔细阅读这里关于正则表达式的解释。笔者也是看了这门课才对正则表达式有了新的认识。</p>\n<p>正则表达式是一种数学上的概念，首先它要有一个完整的字符集 <code>Σ = &#123;...&#125;</code> 要能涵盖程序所有的关键字、变量名、数字、运算符、括号、引号、特殊符号等</p>\n<ul>\n<li>如 C 语言的这个字符集就是 ASC 编码，即 256 个字符</li>\n<li>如 java 的字符集就是 unicode 编码，可能几万甚至十几万个字符集（因为 java 的变量名称并不仅限于英文、中文也可以作为变量）</li>\n</ul>\n<p>然后只有以下几个基本的逻辑：</p>\n<ul>\n<li>空串是正则表达式</li>\n<li>单个字符是正则表达式</li>\n<li><code>a|b</code> 是正则表达式，两者取并集</li>\n<li><code>ab</code> 是正则表达式，两者相连</li>\n<li><code>a*</code> 成为“闭包”（和程序的闭包不一样），即可以有 0 或者若干个 <code>a</code></li>\n<li>以上随机组合，都是正则表达式，例如 <code>a|(bc*)</code></li>\n</ul>\n<p>这就是正则表达式的定义，而现代正则表达式这么多的语法，例如 <code>[a-b]</code> <code>?</code> <code>+</code> 等，都是后来扩展出的语法糖，即对基本规则的一种简写方式。</p>\n<h4 id=\"有限状态自动机-FA\"><a href=\"#有限状态自动机-FA\" class=\"headerlink\" title=\"有限状态自动机 FA\"></a>有限状态自动机 FA</h4><p>也称“有穷自动机”，是一种数学模型。简单理解，就是输入一个字符串，输出这个字符串是否满足某个规则（true &#x2F; false）。例如有 <code>a + b</code> 这样一个规则，输入<code>“1 + 2 ”</code> 就满足，输 <code>“abc”</code> 这就不满足。其实现原理，就是先设定几个状态，然后根据输入的字符做状态转移，看最后能否转移到最终的状态。如下图，输入 <code>abbaabb</code> ，初始状态是 <code>0</code> ，然后分别输入一个一个的字符，看最后能否将状态转移到 <code>3</code> 。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170207504.png\"></p>\n<p>有限状态自动机 FA 又分为两种：</p>\n<ul>\n<li>确定的有限状态自动机 DFA 。针对一个状态，输入一个字符，只能有一个出口。</li>\n<li>非确定的有限状态自动机 NFA 。针对一个状态，输入一个字符，可能会有多个出口。如上图中的 <code>0</code> 状态，输入 <code>a</code> 时有两个出口，所以它是 NFA 。</li>\n</ul>\n<p>看过“正则表达式 原理”类似文章的应该知道，其实每一个正则表达式，都能对应一个 FA ，因此接下来看一下正则表达式如何生成 FA 。</p>\n<h4 id=\"从正则表达式-RE-到有限状态自动机-FA\"><a href=\"#从正则表达式-RE-到有限状态自动机-FA\" class=\"headerlink\" title=\"从正则表达式 RE 到有限状态自动机 FA\"></a>从正则表达式 RE 到有限状态自动机 FA</h4><p>先将正则表达式生成 NFA ，再将 NFA 生成 DFA 。这是因为：第一，RE 生成 NFA 比直接生成 DFA 更加简单；第二， NFA 做分析算法比较复杂，多个出口导致复杂度变高。因此，往往是将 NFA 转换为等价的 DFA ，然后再拿来做运算。</p>\n<p>从 RE 生成 NFA 课程中讲解了 Thompson 算法（Ken Thompson，unix 和 C 语言之父，1984 年图领奖）。具体内容我大体看明白了，不过太细节的也没必要记录了。其基本的逻辑是：</p>\n<ul>\n<li>对基本的 RE（空串、单个字符） 直接构造</li>\n<li>对复杂的 RE （或、连接、闭包）递归构造</li>\n</ul>\n<p>从 NFA 转换 DFA ，子集构造算法。所谓“子集”就是原来 NFA 的若干状态的集合，通过构造子集，来实现 DFA 。也就是说，此时构造出来的 DFA 就不单单是一个一个的状态节点了，而是一个一个的状态子集。</p>\n<p>另外，转换到了 DFA 之后，还要对 DFA 进行最小化的优化，课程中讲了 Hopcroft 算法。基本逻辑是，将生成的 DFA 的子集再进行合并，减少节点数量。状态节点越少，占用的空间复杂度越少，提高运算效率。</p>\n<h4 id=\"根据-DFA-生成词法分析代码\"><a href=\"#根据-DFA-生成词法分析代码\" class=\"headerlink\" title=\"根据 DFA 生成词法分析代码\"></a>根据 DFA 生成词法分析代码</h4>\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170236807.png\"></p>\n<p>DFA 实质上是带有边和节点的有向图，如上图。图中第一列是状态，第一行是字符，例如：</p>\n<ul>\n<li>在状态 <code>0</code> 时，输入字符 <code>a</code> ，行列交叉点是 <code>1</code> ，表示可以转向状态 <code>1</code></li>\n<li>在状态 <code>1</code> 时，输入字符 <code>a</code> ，行列交叉点是 <code>2</code> ，表示可以转向状态 <code>2</code></li>\n<li>在状态 <code>1</code> 时，输入字符 <code>b</code> ，行列交叉点是 <code>1</code> ，表示可以转向状态 <code>1</code></li>\n</ul>\n<p>有了以上所有的逻辑，就可以判断一个字符串是否符合一个 RE 的规定，即可将字符串拆分为一个一个的 token 。这个方法叫做“转移表法”，课程中还讲了“哈希表”和“跳转表”，没有详细记录。</p>\n<hr>\n<h2 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h2><p>词法分析之后，输出了记号流，然后传递给语法分析，这里主要有两部分工作：</p>\n<ul>\n<li>输入一个程序语法的表示，判断是否符合程序的语法</li>\n<li>如果符合，就根据输入的符号集，生成抽象语法树 AST</li>\n</ul>\n<h3 id=\"上下文无关文法-CFG\"><a href=\"#上下文无关文法-CFG\" class=\"headerlink\" title=\"上下文无关文法 CFG\"></a>上下文无关文法 CFG</h3><p>上文所说的“程序语法的表示”，就是上下文无关文法 CFG ，是一个描述语言语法规则的标准的数学工具。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170303206.png\"></p>\n<p>上图的左侧就是一个 CFG 的简单示例，其中每一条叫做“产生式”，图中的 <code>|</code> 即“或”的意思。简单解释一下这个 CFG 的意思：</p>\n<ul>\n<li><p>“S -&gt; N V N” 就是一个句子，其实 S 是开始符号</p>\n</li>\n<li><p>N 和 V 都是非终结符，即它可以继续再往下扩展拆分，就像 “S -&gt; N V N” 那样拆分</p>\n</li>\n<li><p>t g e 等这些都是终结符，即已经表述一个具体的事情了，没法再往下拆分了</p>\n</li>\n</ul>\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170317523.png\"></p>\n<p>上图就用 CFG 描述了一个 <code>*</code> 和 <code>+</code> 表达式，\b其中 <code>num</code> 表示一个具体的数字， <code>id</code> 表示标识符（变量），这俩都是终结符，\b<code>E</code> 是非终结符。</p>\n<p>从上面的例子来看，可以根据一个 CFG 推导出若干个句子，例如上图的 CFG 可以推导出 <code>id + num</code> 或者 <code>id * num</code> 或者 <code>(id + num) * num</code> 或者 ……</p>\n<p><strong>语法分析就是：给定一个文法 G 和句子 s ，要确定：是否能在 G 的推导结果中，找到 s ？（即，是否存在对句子的推导）</strong> 如果能推导出来，说明\b句子 s 符合文法 G 的语法，否则不符合。如下图：</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170406338.png\"></p>\n<p>推导方式一般有两种：</p>\n<ul>\n<li>最左推导：每次推导过程当中总是选择最左侧的符号进行替换</li>\n<li>最右推导：同理，选择最右侧</li>\n</ul>\n<h3 id=\"分析树和二义性\"><a href=\"#分析树和二义性\" class=\"headerlink\" title=\"分析树和二义性\"></a>分析树和二义性</h3>\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170430263.png\"></p>\n<p>如上图，在文法的推导过程中，可以用树的形式来表示，即分析树。\b其中， 内部节点都是非终结符，叶子节点都是终结符，<strong>中序遍历</strong>即可得到最终的句子。PS：到这里，貌似已经看到了\b最终输出的抽象语法树 AST 的雏形了，其本质就是来源于 CFG 的格式。</p>\n<p>所谓“二义性”就是指文法的书写会产生一些歧义，例如上图中 <code>*</code> 和 <code>+</code> 表达式的文法，\b采用最左推导和最右推导得出的结果是不一样的，可能分别得出 <code>(3+4)*5</code> 和 <code>3+(4*5)</code> ，显然计算结果不同。为了避免\b文法的二义性，只能是重写文法，将文法表述的更加详细一些，此处不做详解。</p>\n<h3 id=\"自顶向下分析算法\"><a href=\"#自顶向下分析算法\" class=\"headerlink\" title=\"自顶向下分析算法\"></a>自顶向下分析算法</h3><p>上文已经明确了语法分析的\b定义，即看一个文法 G 是否存在对句子 s 的推导。自顶向下分析就是其中一个比较典型的算法，其基本逻辑是：</p>\n<ul>\n<li>即通过文法 G 随意推导出一个句子 t ，然后拿 t 和目标句子 s 进行对比</li>\n<li>如果 t &#x3D;&#x3D; s ，则成功</li>\n<li>如果 t !&#x3D; s ，则回溯，从新计算一个 t1 ，再比较</li>\n</ul>\n<p>但是，上述过程比较笨重，因为一个 G 能推导出来的句子可能有非常多种，都拿来跟 s 做比较，会发生很多回溯，非常耗时。可以用以下方式进行优化：</p>\n<ul>\n<li>从左到右的推导顺序，可以最先得到句子 t 的左侧</li>\n<li>拿 t 最先得到的左侧，和 s 左侧进行对比</li>\n<li>对比成功，则继续从左到右推导（接下来的推导，也都是没推导出左侧就和 s 对应的左侧部分进行对比，看是否成功）</li>\n<li>对比不成功，则回溯重来</li>\n</ul>\n<p>但是，上述优化后的算法，还是可能会有回溯发生，这\b远远达不到编译器的性能要求。编译器要处理的程序动辄\b\b几十万行，必须要求线性时间复杂度的算法，一旦有回溯\b就会严重\b影响性能。</p>\n<h3 id=\"递归下降分析算法\"><a href=\"#递归下降分析算法\" class=\"headerlink\" title=\"递归下降分析算法\"></a>递归下降分析算法</h3><p>也称预测分析算法，其基本思路是：</p>\n<ul>\n<li><p>每个非终结符构造一个分析函数（即将整个文法匹配整个句子的方式，拆解开，用单个非终结符去匹配句子中的字符，即算法的分治思想），因为非终结符是可以层层定义的，因此是“递归”，如下图。</p>\n</li>\n<li><p>用“前看符号”（即不知道匹配哪一个，就去目标句子 s 中看一眼，给一个提示）指导当前产生式规则的选择。</p>\n</li>\n</ul>\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170448660.png\"></p>\n<p>递归下降分析算法的特点是</p>\n<ul>\n<li>线性时间复杂度，运行高效</li>\n<li>容易实现，适合手工编码。错误定位准确。使用者有 GCC LLVM</li>\n</ul>\n<h3 id=\"LL-1-分析算法\"><a href=\"#LL-1-分析算法\" class=\"headerlink\" title=\"LL(1) 分析算法\"></a>LL(1) 分析算法</h3><p>递归下降分析算法适合于手工编码，而 LL(1) 分析算法适用于语法分析的自动生成。所谓“LL(1)”，是指：从左（L）向右读入程序，最左（L）推导，采用 1 个前看符号。分析高效，也是线性时间复杂度。</p>\n<p>其基本思想是 —— 表驱动的算法，如下图。第一列都是非终结符，第一行都是终结符，行列交叉点表示对应的产生式序号。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170520036.png\"></p>\n<p>回顾之前讲过的自顶向下分析算法，最大的问题就在于去盲目推导，盲目匹配出句子，然后再去和目标句子 s 做对比，对比出错就要回溯，时间复杂度非常高。因此，就需要在推导过程中就需要做分析预测，就可以从参考这个分析表。从分析表中，通过预测输入能得到产生式的序号，就知道接下来要匹配哪个产生式了，就不需要回溯了。</p>\n<h3 id=\"LR-分析算法\"><a href=\"#LR-分析算法\" class=\"headerlink\" title=\"LR 分析算法\"></a>LR 分析算法</h3><p>上文主要将自顶向下的分析算法，而 LR 分析算法是自底向上的思路，但是输入、输出都是一样的。我没有看这部分，想详细了解的可以自己去看视频。</p>\n<h3 id=\"抽象语法树-AST\"><a href=\"#抽象语法树-AST\" class=\"headerlink\" title=\"抽象语法树 AST\"></a>抽象语法树 AST</h3>\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170628092.png\"></p>\n<p>如上图，先看下抽象语法树 AST 和高级语言如何对应，根据代码对比一下，应该不难理解。其中，if 的最左侧节点是判断条件，中间节点是成功分支，右侧节点是 else 分支。</p>\n<p>再来回顾一下上文讲的 CFG 的分析树（上文有示意图），它详细编码了句子的推导过程，并且包含了很多无关信息（非终结符），会占用很多存储空间，会增加算法的空间和时间复杂度。如果能把这些“无关信息”给去掉，只留下运算符，数字，标识符等和程序相关的信息，就构成了抽象语法树 AST ，如下图。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170648389.png\"></p>\n<p>既然是一棵树，那么就是一个标准的数据结构，各个类型的节点的数据结构，也就可以固定了。如下图</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170704479.png\"></p>\n<p>AST 是编译器中非常重要的数据结构，因为它是编译器前端和后端的接口形式。后续的过程仅仅依赖于 AST ，不会再依赖于前面的源码或者字符集。因此，一旦生成了 AST ，前面的源码就会被丢弃。因此，AST 中要有很详细的信息，不仅仅是本课程中讲的这个简单的树。例如，AST 要存储当前程序的文件、行、列，这样在语法报错时才能准确的给出具体的错误位置。</p>\n<hr>\n<h2 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h2><p>语法分析输出 AST ，然后对 AST 进行语义分析（有些教材也会叫做 “类型检查” 或者 “上下文相关分析” 等名字）。注意，程序如果能通过了语义分析这个阶段，那再往后就不应该出现任何语法错误，除非是编译器自己的 bug 。</p>\n<h3 id=\"主要任务\"><a href=\"#主要任务\" class=\"headerlink\" title=\"主要任务\"></a>主要任务</h3><p>上文中的语法分析用到的是 CFG 即上下文无关的语法，即不依赖于上下文。例如 C 语言中 <code>printf(n);</code> 不符合语法，而 <code>print(&quot;%d&quot;, n);</code> 就符合语法，但是其中的 <code>n</code> 变量是否在上文已经定义了，语法分析是不知道的。</p>\n<p>因此，语义分析是在 AST 基础上，结合上下文来分析：</p>\n<ul>\n<li>变量在使用前先进行声明</li>\n<li>每个表达式都有合适的类型</li>\n<li>函数调用和函数定义一致</li>\n<li>等等 ……（每种语言的要求不一样）</li>\n</ul>\n<h3 id=\"语义规则和实现\"><a href=\"#语义规则和实现\" class=\"headerlink\" title=\"语义规则和实现\"></a>语义规则和实现</h3><p>例如表达式的类型检查，定义一个类型检查函数，传入 AST 的某个表达式的节点，然后判断最后返回的类型。如果类型检查错误，就报错。如下图。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170727674.png\"></p>\n<h3 id=\"符号表\"><a href=\"#符号表\" class=\"headerlink\" title=\"符号表\"></a>符号表</h3><p>上下文相关分析，就涉及到上下文信息的记录和读取，这些信息就被记录到符号表中，一个非常核心的数据结构。符号表用来存储程序中的变量相关信息（表的信息要足够丰富）：</p>\n<ul>\n<li>类型</li>\n<li>作用域</li>\n<li>访问控制信息（例如 <code>privte</code> <code>protected</code> 等）</li>\n<li>……</li>\n</ul>\n<p>其数据结构最简单的可以使用一个 <code>key-val</code> 的字典来实现，例如 <code>&#123; key1: &#123;…&#125;, key2: &#123;…&#125;, key3: &#123;…&#125; &#125;</code> 。但是编译器要处理的程序规模可能非常庞大，因此这个数据结构必须要合理规划。在实际工程中，高效的查询方式可以有一下选择：</p>\n<ul>\n<li>选择一：为了高效，使用哈希表来实现符号表，查找是 <code>O(1)</code> 的时间复杂度</li>\n<li>选择二：为了节约空间，可以使用红黑树等平衡树，查找是 <code>O(logN)</code> 的时间复杂度</li>\n</ul>\n<p>变量都有“作用域”的概念，不同作用域可以有相同的变量名。符号表处理作用域的方式：</p>\n<ul>\n<li><p>第一，进入作用域时插入元素，退出作用域时删除元素</p>\n</li>\n<li><p>第二，采用栈：进入作用域时插入新的符号表（push），退出作用域时删除栈顶符号表（pop），如下图。 （栈的实现方式很很多种，例如链表）</p>\n</li>\n</ul>\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170745226.png\"></p>\n<hr>\n<h2 id=\"代码生成\"><a href=\"#代码生成\" class=\"headerlink\" title=\"代码生成\"></a>代码生成</h2><p>经过语义分析的 AST ，即可用来做代码生成，即生成最终的机器（物理机或者虚拟机）代码。注意，这里直接从 AST 到目标代码，是一种最简单的编译器模型，暂时忽略了优化的部分。优化过程下文会详细解说。</p>\n<h3 id=\"主要工作\"><a href=\"#主要工作\" class=\"headerlink\" title=\"主要工作\"></a>主要工作</h3><p>代码生成是把源程序翻译成“目标机器”（可能是真实的机器，也可能是虚拟机）上的代码，而且要保证和源程序的“等价性”（重要！！！）。主要的任务是：</p>\n<ul>\n<li>给源程序的数据（全局变量，局部变量等）分配计算资源（寄存器、数据区、代码区、栈区、堆区）</li>\n<li>给源程序的代码（运算 语句 函数）选择指令（算数运算 逻辑运算 跳转 函数调用等）</li>\n<li>（而且要考虑空间和时间的效率，在满足等价性的前提下）</li>\n</ul>\n<p>接下来通过两个示例来看代码生成的过程：</p>\n<ul>\n<li>栈计算机 Stack —— 代表了虚拟机，例如 JVM</li>\n<li>寄存器计算机 Reg —— 代表了 RISC 精简指令集，如 ARM 芯片</li>\n</ul>\n<h3 id=\"Stack-栈计算机代码生成技术\"><a href=\"#Stack-栈计算机代码生成技术\" class=\"headerlink\" title=\"Stack 栈计算机代码生成技术\"></a>Stack 栈计算机代码生成技术</h3><p>70 年代有栈计算机的物理机，但是今天已经退出了历史舞台，因为执行效率太低。但是这里还要研究 Stack ，一来是因为在 Stack 上代码生成比较简单，二来是很多虚拟机是这样设计的，例如 JVM 。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170805003.png\"></p>\n<p>上图就是一个 Stack 的原型图，简单解释一下图中各个部分。</p>\n<ul>\n<li>内存，存放程序变量<ul>\n<li>给变量 <code>x</code> 分配内存空间的伪指令：<code>.int x</code> （伪指令，不会被 ALU 执行）</li>\n</ul>\n</li>\n<li>stack ，进行计算的空间（计算的输入、计算的中间结果和最终结果）</li>\n<li>ALU ，计算单元 。指令集是：<ul>\n<li><code>push NUM</code> ，把一个立即数压栈</li>\n<li><code>load x</code> ，得到内存中的变量 <code>x</code> 的值，并压栈</li>\n<li><code>store x</code> ，把栈顶元素弹出，并赋值给 <code>x</code></li>\n<li><code>add</code> ，加法，pop 赋值给 <code>x</code> ，再 pop 赋值给 <code>y</code> ，然后 push <code>x+y</code></li>\n<li><code>sub</code> ，减法，同上</li>\n<li><code>times</code> ，乘法，同上</li>\n<li><code>div</code> ，除法，同上</li>\n</ul>\n</li>\n</ul>\n<p>PS：以上这几条指令，就是 java 字节码的一个子集。真实的 java 字节码有 200+ 个。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170830490.png\"></p>\n<p>上图就是高级语言到最终的 Stack 计算机机器语言的对应，展示了最终的输入和输出。至于代码生成如何实现，在文章一开始的“Sum 语言 + Stack”的例子中这部分已经写的比较详细，就不再赘述了，翻看上文吧。</p>\n<h3 id=\"REG-寄存器计算机的代码生成技术\"><a href=\"#REG-寄存器计算机的代码生成技术\" class=\"headerlink\" title=\"REG 寄存器计算机的代码生成技术\"></a>REG 寄存器计算机的代码生成技术</h3><p>这种机器类型是基于寄存器架构，所有操作都在寄存器完成，执行效率非常高（因为寄存器访问速度是内存访问速度的百倍），访存都通过 <code>load</code> 或 <code>store</code> 指令（RISC 指令集特点）。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170858118.png\"></p>\n<p>上图就是寄存器计算机的原型图，解释一下图中各个部分。</p>\n<ul>\n<li><p>内存：存放“溢出”的变量（寄存器中放不开的变量，如果假设寄存器有无限多个的话，就不用考虑“溢出”了）</p>\n</li>\n<li><p>寄存器：进行计算的空间，有 r1 r2 … rn 无限个寄存器（假定无限个，实际上寄存器个数是有限的）</p>\n<ul>\n<li>给变量 <code>x</code> 分配寄存器的伪指令 <code>.int x</code> （伪指令不会被 ALU 执行）</li>\n</ul>\n</li>\n<li><p>ALU 计算单元。指令集：</p>\n<ul>\n<li><code>movn n, r1</code> 把立即数 n 存入寄存器 r1</li>\n<li><code>mov r1, r2</code> 把 r1 的值赋值给 r2</li>\n<li><code>load [x], r1</code> 将 x 地址的值取出，放在 r1 。其中 x 是指针，[x] 即取出指针对应内存的值。</li>\n<li><code>store r1, [x]</code> 将 r1 的值赋值给 x 内存地址</li>\n<li><code>add r1, r2, r3</code> 加法，表示 r3 &#x3D; r1 + r2</li>\n<li><code>sub r1, r2, r3</code> 减法，同理</li>\n<li><code>times r1, r2, r3</code> 乘法，同理</li>\n<li><code>div r1, r2, r3</code> 除法，同理</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170928307.png\"></p>\n<p>上图就是高级语言和目标代码的对应关系。图中有对应的 AST ，对这棵树进行后续遍历（先左、再右、最后根），每遍历一个节点都会对应到右侧的一行指令。</p>\n<ul>\n<li>“1” 节点会对应第一行指令</li>\n<li>“2” 节点会对应第二行指令</li>\n<li>“+” 节点会对应第三行指令</li>\n<li>“3” 节点会对应第四行指令</li>\n<li>……</li>\n</ul>\n<p>最后，实际的物理机器上不可能有无限多的寄存器，因此要确定哪些变量被用于寄存器？哪些变量被“溢出”放在内存？—— 这个问题是另外一个编译器的重要部分：编译器分配。如何进行编译器分配，这个问题会在下文介绍。</p>\n<hr>\n<h2 id=\"中间表示\"><a href=\"#中间表示\" class=\"headerlink\" title=\"中间表示\"></a>中间表示</h2><p>中间表示是一个统称，有很多种表示形式，AST 就是其中之一。上文提到，从 AST 直接生成目标代码是比较原始的编译技术，现代编译器中往往会在编译器的“后端”进行各种各样的代码优化，不同的优化形式就需要不同的表示形式。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170944117.png\"></p>\n<p>常见的中间代码形式：</p>\n<ul>\n<li>树和有向无环图：高层表示，适用于程序源代码</li>\n<li>三地址码：低层表示，靠近目标机器</li>\n<li>控制流图：更精细的三地址码，程序的图状表示</li>\n<li>静态单赋值形式 SSA ：更精细的控制流图</li>\n<li>连续传递风格：更一般的 SSA （函数式语言中用的比较多）</li>\n<li>还有很多。。。</li>\n</ul>\n<h3 id=\"三地址码\"><a href=\"#三地址码\" class=\"headerlink\" title=\"三地址码\"></a>三地址码</h3><p>所谓“三地址码”，即一个指令有一个运算符，最多有三个操作数。这样就使得每一条指令都比较简单，易于和机器语言对应。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201170958183.png\"></p>\n<p>上图就是一个高级语言和三地址码的对应关系（虽然三地址码是通过 AST 生成的，已经和源代码没有关系）。从图中可以看出三地址码的特点：</p>\n<ul>\n<li>给每个中间变量和计算结果命名，即没有符合表达式。例如将 <code>a = 3 + 4 * 5</code> 拆解成一个一个的中间变量</li>\n<li>只有最基本的控制流，即没有各种控制结构，只有 <code>goto</code> 和 <code>call</code> 。例如将 <code>if else</code> 改为 <code>Cjmp</code>（条件跳转指令）</li>\n</ul>\n<h3 id=\"控制流图\"><a href=\"#控制流图\" class=\"headerlink\" title=\"控制流图\"></a>控制流图</h3><p>三地址码是一种线性的表示方式，这就没法通过它来分析和确定流程。例如上图中，哪些指令会跳转到 <code>L_1</code> 和 <code>L_2</code> ？并不好确定。控制流图是一种更加精细的三地址码（本质上还是三地址码），将程序中的各个控制流块都表示了出来，如下图。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171022430.png\"></p>\n<p>控制流图就是一个有向图 <code>G = (V, E)</code> ，其中节点 <code>V</code> 表示程序的基本块，边 <code>E</code> 表示基本块之间的跳转关系。生成控制流图的目的有很多，但都是为了做代码优化，例如：</p>\n<ul>\n<li>做控制流分析，例如程序中有没有循环？</li>\n<li>做数据流分析，例如程序中某行的变量 <code>x</code> 可能的值是什么？</li>\n</ul>\n<h3 id=\"数据流分析\"><a href=\"#数据流分析\" class=\"headerlink\" title=\"数据流分析\"></a>数据流分析</h3><p>所谓“数据流分析”，就是通过静态的观察程序（并不执行）来判断其中的变量和数据的一些变化，例如某程序第五行的 x 变量的值会有几种可能？</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171035215.png\"></p>\n<p>如上图，通过控制流图，既可以判断一个变量 <code>y</code> 的赋值可能性。如果 <code>y</code> 能编译器识别为一个固定的值，直接 <code>a = 3</code> 并且把一开始的 <code>y = 3</code> 删掉。这就是一个优化过程。</p>\n<p>但是这仅仅是静态的分析，程序并未执行，因此如果 <code>y</code> 在一个逻辑分支中出现，就不好预估其准确结果，但是至少能预估一个结果集（称为“保守信息”）。如果能将这个结果集做到最小，和执行的结果越接近，就越好优化。这仍然是编译器现在的一个热门话题。</p>\n<p>类似数据流分析的还有“到达定义分析”，即分析一个变量是如何一步一步的被定义和使用的，原理和目的基本一致，这里不再赘述。</p>\n<h3 id=\"活性分析\"><a href=\"#活性分析\" class=\"headerlink\" title=\"活性分析\"></a>活性分析</h3><p>上文中提到 REG 机器假设有无限个寄存器，但实际情况不是。因此需要寄存器分配 —— 即用到活性分析。所谓“活性分析”，即分析变量的活跃区间（可以理解为声明周期）然后来做寄存器的分配。</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171049617.png\"></p>\n<p>如上图，三个变量，只有一个寄存器，该如何分配？答案是：计算出每个变量的活跃区间，即可共享寄存器。寄存器分配，就依赖于变量的活动区间数据。如下图：</p>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171101780.png\"></p>\n<hr>\n<h2 id=\"代码优化\"><a href=\"#代码优化\" class=\"headerlink\" title=\"代码优化\"></a>代码优化</h2><p>现代生产环境下的编译器，代码优化是其重要工作之一，而且一直在不断的持续优化中。</p>\n<h3 id=\"几点说明\"><a href=\"#几点说明\" class=\"headerlink\" title=\"几点说明\"></a>几点说明</h3><p>代码优化的目的是让目标程序更精简、更快速、更节省空间、更节能（所谓的多快好省），当然在不改变语义的前提下 —— 这些应该都比较好理解。但是还有几点关于优化的需要重点说明一下。</p>\n<ul>\n<li>没有完美的优化，即“没有最好只有更好”。因为编译器本来就是一个庞大复杂的工程，优化过程复杂度很高，不确定性很大。</li>\n<li>优化必须要在语义分析完成之后再进行，即确保源程序没有任何语法和语义的问题。因为优化可能会删改代码，如果优化之后再报错，错误信息就不准确了。</li>\n<li>优化并不是一个单独的阶段（如词法分析、语法分析等），而是在各个阶段都可能进行。可以对 AST 进行优化，也可以对各种中间表示进行优化，还可以对目标代码再继续优化，每一步的优化针对想都不一样。</li>\n<li>一般针对一个数据优化之后不会产生新的格式（但会产生新的数据，即函数式编程的思维），优化不是翻译过程。</li>\n</ul>\n\n\n<p><img data-src=\"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20230201171118467.png\"></p>\n<h3 id=\"前端优化\"><a href=\"#前端优化\" class=\"headerlink\" title=\"前端优化\"></a>前端优化</h3><p>即对 AST 进行优化，下面列举几个例子来说明。</p>\n<p>第一，常量折叠。静态计算，可以在数字类型和 bool 类型进行优化，例如：</p>\n<ul>\n<li><code>a = 3 + 5</code> 变为 <code>a = 8</code> （少了一步 <code>+</code> 计算，就相当于帮 AST 节省了一个分支）</li>\n<li><code>if (true &amp;&amp; false)</code> 变为 <code>if (false)</code> 。而且，<code>if (else)</code> 还可以进行“不可达代码”优化（见下文）</li>\n</ul>\n<p>第二，代数化简。利用代数的恒等式，进行优化，例如：</p>\n<ul>\n<li><code>a = 0 + b</code> 变为 <code>a = b</code> （少一个运算符，简化 AST）</li>\n<li><code>a = 1 * b</code> 变为 <code>a = b</code> （少一个运算符，简化 AST）</li>\n<li><code>2 * a</code> 变为 <code>a + a</code> （因为乘法运算复杂度高）</li>\n<li><code>2 * a</code> 变为 <code>a &lt;&lt; 1</code> （位运算效率最高）</li>\n</ul>\n<p>第三，死代码（不可达）代码优化，例如</p>\n<ul>\n<li><code>if (false)</code> 不会被执行，测试环境的 debug 代码，到了线上环境就会是死代码</li>\n<li>函数的 <code>return</code> 之后的语句，不会被执行</li>\n</ul>\n<h3 id=\"中间表示上的优化\"><a href=\"#中间表示上的优化\" class=\"headerlink\" title=\"中间表示上的优化\"></a>中间表示上的优化</h3><p>如常量传播、拷贝传播，在上文讲数据流分析的时候已经写过，不再赘述。</p>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>编译器真的是一个非常非常非常复杂的工具，其中涉及到的知识点包括数学理论、计算机组成原理、算法和数据结构。如果真的想要深入了解一门语言，那就到它的编译器中去看看吧。</p>\n",
            "tags": [
                "计算机科学",
                "编译"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/10/04/computer-science/Simple-distributed/",
            "url": "https://hdqjl317.github.io/2022/10/04/computer-science/Simple-distributed/",
            "title": "Simple_distributed",
            "date_published": "2022-10-04T12:43:08.000Z",
            "content_html": "<h2 id=\"服务注册\"><a href=\"#服务注册\" class=\"headerlink\" title=\"服务注册\"></a>服务注册</h2><p>服务进程是在注册中心注册自己的元数据信息，通常包括主机和端口号，有时还有身份验证信息，协议，版本号，以及运行环境的信息</p>\n<p>本系统中包含了以下内容:</p>\n<ol>\n<li>创建Web服务</li>\n<li>创建注册服务</li>\n<li>注册Web服务</li>\n<li>取消注册Web服务</li>\n</ol>\n<h3 id=\"创建日志服务\"><a href=\"#创建日志服务\" class=\"headerlink\" title=\"创建日志服务\"></a>创建日志服务</h3><p>在正式实现服务注册的功能之前，先实现日志服务，在项目文件夹下创建一个log文件夹，存放定义日志逻辑的代码</p>\n<h4 id=\"编写日志服务逻辑\"><a href=\"#编写日志服务逻辑\" class=\"headerlink\" title=\"编写日志服务逻辑\"></a>编写日志服务逻辑</h4><p>日志服务是一个WEB服务，功能是接收web请求，将POST请求的内容写入到log，注意这里对标准的log包起了别名stdlog，因为后续要自定义一个Logger对象log:</p>\n<pre><code class=\"go\">// log/server.go\npackage log\n \nimport (\n    &quot;io/ioutil&quot;\n    stdlog &quot;log&quot;\n    &quot;net/http&quot;\n    &quot;os&quot;\n)\n \nvar log *stdlog.Logger\n \ntype fileLog string\n \nfunc (fl fileLog) Write(data []byte) (int, error) &#123;\n    f, err := os.OpenFile(string(fl), os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)\n    if err != nil &#123;\n        return 0, err\n    &#125;\n    defer f.Close()\n    return f.Write(data)\n&#125;\n \nfunc Run(destination string) &#123;\n    log = stdlog.New(fileLog(destination), &quot;go&quot;, stdlog.LstdFlags)\n&#125;\n \nfunc RegisterHandlers() &#123;\n    http.HandleFunc(&quot;/log&quot;, func(w http.ResponseWriter, r *http.Request) &#123;\n        switch r.Method &#123;\n        case http.MethodPost:\n            msg, err := ioutil.ReadAll(r.Body)  // 读取Body数据\n            if err != nil || len(msg) == 0 &#123;\n                w.WriteHeader(http.StatusBadRequest)\n                return\n            &#125;\n            write(string(msg))\n        default:\n            w.WriteHeader(http.StatusMethodNotAllowed)\n            return\n        &#125;\n    &#125;)\n&#125;\n \nfunc write(message string) &#123;\n    log.Printf(&quot;%v\\n&quot;, message)\n&#125;\n</code></pre>\n<p>这段代码的作用是将日志写入文件系统，先为filelog实现io.Writer接口，定义Write方法</p>\n<p>在这个方法中，首先调用了OpenFile方法，传入一个文件路径并返回一个file对象，指定了权限和模式，并随后判断是否产生错误，最后通过io.Writer接口写入文件:</p>\n<pre><code class=\"go\">func (fl fileLog) Write(data []byte) (int, error) &#123;\n    f, err := os.OpenFile(string(fl), os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)  // 打开文件\n    if err != nil &#123;\n        return 0, err\n    &#125;\n    defer f.Close()\n    return f.Write(data)\n&#125;\n</code></pre>\n<p>接着定义Run函数，作用是将log指向某个文件路径，使用log.New来创建一个Logger对象，要传入的参数: 写入的位置(实现io.Writer接口)、日志前缀和日志内容的flag(包含了日期和时间)</p>\n<pre><code class=\"go\">func Run(destination string) &#123;\n    log = stdlog.New(fileLog(destination), &quot;go&quot;, stdlog.LstdFlags)\n&#125;\n</code></pre>\n<p>然后注册一个handler:</p>\n<pre><code class=\"go\">func RegisterHandlers() &#123;\n    http.HandleFunc(&quot;/log&quot;, func(w http.ResponseWriter, r *http.Request) &#123;\n        switch r.Method &#123;\n        case http.MethodPost:  // POST请求\n            msg, err := ioutil.ReadAll(r.Body)\n            if err != nil || len(msg) == 0 &#123;\n                w.WriteHeader(http.StatusBadRequest)\n                return\n            &#125;\n            write(string(msg))  // 写入数据\n        default:\n            w.WriteHeader(http.StatusMethodNotAllowed)\n            return\n        &#125;\n    &#125;)\n&#125;\n</code></pre>\n<p>使用了一个http.HandleFunc来处理HTTP请求，使用switch-case结构判断请求方式来分支处理请求，如果是POST请求则调用ioutil.ReadAll读取Body数据，调用write函数(之后实现)写入文件，如果读取失败或者数据为空，则返回一个BadRequest(400)响应。如果接收到的请求不是POST请求，则返回一个MethodNotAllowed响应(405)</p>\n<p>如下是write函数:</p>\n<pre><code class=\"go\">func write(message string) &#123;\n    log.Printf(&quot;%v\\n&quot;, message)\n&#125;\n</code></pre>\n<p>调用log.Printf就可以，这里的log是自定义的Logger对象(已经在Run函数中创建)，路径在New方法中指定了，这时就会把日志信息写入所指向的文件中</p>\n<h4 id=\"运行日志服务\"><a href=\"#运行日志服务\" class=\"headerlink\" title=\"运行日志服务\"></a>运行日志服务</h4><p>上述编写的server.go程序作为日志系统的后端，下面编写一段代码，将服务集中化管理，能够集中启动这些服务</p>\n<p>创建一个service目录，并在其中编写service.go文件:</p>\n<pre><code class=\"go\">package service\n \nimport (\n    &quot;context&quot;\n    &quot;fmt&quot;\n    &quot;log&quot;\n    &quot;net/http&quot;\n)\n \nfunc Start(ctx context.Context, serviceName, host, port string,\n    registerHandlerFunc func()) (context.Context, error) &#123;\n    registerHandlerFunc()  // 注册请求处理函数\n    ctx = startService(ctx, serviceName, host, port)  // 启动服务\n    return ctx, nil\n&#125;\n \nfunc startService(ctx context.Context, serviceName, host, port string) context.Context &#123;\n    ctx, cancel := context.WithCancel(ctx)\n    var srv http.Server\n    srv.Addr = &quot;:&quot; + port\n \n    go func() &#123;\n        log.Println(srv.ListenAndServe())  // 监听HTTP请求 调用ServeHTTP方法\n        cancel()\n    &#125;()\n \n    go func() &#123;\n        fmt.Printf(&quot;%v started. Press any key to stop. \\n&quot;, serviceName)\n        var s string\n        fmt.Scanln(&amp;s)\n        srv.Shutdown(ctx)\n        cancel()\n    &#125;()\n \n    return ctx\n&#125;\n</code></pre>\n<p>这段代码定义了一个Start函数，接收context接口，服务名称，地址，端口号，作用是启动指定的服务，先调用了registerHandleFunc注册请求处理函数(服务程序要有一个处理函数，来处理到来的HTTP请求)，随后调用了startService函数，结束时返回context和nil</p>\n<p>在startService函数中调用了WithCancel，返回一个context子节点和一个取消函数，用于触发取消信号，之后调一个goroutine启动HTTP服务器监听在指定的端口，处理到来的HTTP请求，当用户输入按下任意建就会触发Shutdown方法关闭服务器，并且调用取消函数撤销掉context:</p>\n<pre><code class=\"go\">func startService(ctx context.Context, serviceName, host, port string) context.Context &#123;\n    ctx, cancel := context.WithCancel(ctx)\n    var srv http.Server\n    srv.Addr = &quot;:&quot; + port\n \n    go func() &#123;\n        log.Println(srv.ListenAndServe())\n        cancel()\n    &#125;()\n \n    go func() &#123;\n        fmt.Printf(&quot;%v started. Press any key to stop. \\n&quot;, serviceName)\n        var s string\n        fmt.Scanln(&amp;s)\n        srv.Shutdown(ctx)  // 关闭服务器\n        cancel()           // 取消context\n    &#125;()\n \n    return ctx\n&#125;\n</code></pre>\n<p>创建一个cmd文件夹，编写main.go作为整个程序的入口:</p>\n<pre><code class=\"go\">package main\n \nimport (\n    &quot;context&quot;\n    &quot;distributed/log&quot;\n    &quot;distributed/service&quot;\n    &quot;fmt&quot;\n    stdlog &quot;log&quot;\n)\n \nfunc main() &#123;\n    log.Run(&quot;./distributed.log&quot;)        // 指定日志文件路径\n    host, port := &quot;localhost&quot;, &quot;4000&quot;   // 指定地址和端口号\n    ctx, err := service.Start(context.Background(),\n        &quot;Log Service&quot;,\n        host, port,\n        log.RegisterHandlers,\n    )\n \n    if err != nil &#123;\n        stdlog.Fatalln(err)\n    &#125;\n    &lt;-ctx.Done()\n \n    fmt.Println(&quot;Shutting down log service.&quot;)\n&#125;\n</code></pre>\n<p>这段代码作为入口，启动这个服务</p>\n<p>当取消函数(cancel)被调用后，ctx.Done就不会被阻塞，往下执行完整个程序</p>\n<h4 id=\"测试日志服务\"><a href=\"#测试日志服务\" class=\"headerlink\" title=\"测试日志服务\"></a>测试日志服务</h4><p>使用Postman发出POST请求用于测试，如下所示:</p>\n<p><img data-src=\"/Simple-distributed/2692436-20220822193149828-290861501.png\" alt=\"img\"></p>\n<p>发送请求后，查看日志文件:</p>\n<pre><code class=\"shell\">$ cat distributed.log \ngo 2022/08/22 19:34:08 just for test\n</code></pre>\n<p>日志被记录了下来</p>\n<h3 id=\"服务注册逻辑\"><a href=\"#服务注册逻辑\" class=\"headerlink\" title=\"服务注册逻辑\"></a>服务注册逻辑</h3><p>下面才正式实现注册中心服务注册的功能，应当实现服务注册的接口，这样客户端能够通过这个接口</p>\n<p>创建registry文件夹，编写如下的registration.go文件:</p>\n<pre><code class=\"go\">package registry\n \ntype Registration struct &#123;\n    ServiceName ServiceName\n    ServiceURL  string\n&#125;\n \ntype ServiceName string\n \nconst (\n    LogService = ServiceName(&quot;LogService&quot;)\n)\n</code></pre>\n<p>如上定义的Registration结构体代表被注册的服务，将目前存在服务定义为常量，目前只有一个日志服务LogService</p>\n<p>在这个文件夹下再编写一个server.go，包含服务注册的主要逻辑:</p>\n<pre><code class=\"go\">package registry\n \nimport (\n    &quot;encoding/json&quot;\n    &quot;log&quot;\n    &quot;net/http&quot;\n    &quot;sync&quot;\n)\n \nconst ServerPort = &quot;:3000&quot;  // 端口\nconst ServicesURL = &quot;http://localhost&quot; + ServerPort + &quot;/services&quot;  // 查询服务的URL\n \ntype registry struct &#123;\n    registrations []Registration  // 切片\n    mutex         *sync.Mutex     // 互斥锁\n&#125;\n \nfunc (r *registry) add(reg Registration) error &#123;\n    r.mutex.Lock()\n    r.registrations = append(r.registrations, reg)\n    r.mutex.Unlock()\n    return nil\n&#125;\n \nvar reg = registry&#123;\n    registrations: make([]Registration, 0),\n    mutex:         new(sync.Mutex),\n&#125;\n \ntype Service struct&#123;&#125;\n \nfunc (s Service) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\n    log.Println(&quot;Request received&quot;)\n    switch r.Method &#123;\n    case http.MethodPost:\n        dec := json.NewDecoder(r.Body)\n        var r Registration\n        err := dec.Decode(&amp;r)\n        if err != nil &#123;\n            log.Println(err)\n            w.WriteHeader(http.StatusBadRequest)\n            return\n        &#125;\n        log.Printf(&quot;Adding service: %v with URL: %s\\n&quot;, r.ServiceName, r.ServiceURL)\n        err = reg.add(r)\n        if err != nil &#123;\n            log.Println(err)\n            w.WriteHeader(http.StatusBadRequest)\n            return\n        &#125;\n    default:\n        w.WriteHeader(http.StatusMethodNotAllowed)\n        return\n    &#125;\n&#125;\n</code></pre>\n<p>定义了一个结构体registry，包含了两个成员: 一个切片，可以看成是一系列服务的集合，和一个互斥锁，用于并发控制，之后将其创建</p>\n<p>随后定义的add函数作用是注册，在上锁的情况下向集合添加元素，接着定义ServeHTTP函数，只接收POST请求，解析JSON数据，将其中服务名称通过add函数添加到上述创建的Registration结构中的集合中，这就意味着成功注册了一个服务</p>\n<h3 id=\"独立运行服务注册\"><a href=\"#独立运行服务注册\" class=\"headerlink\" title=\"独立运行服务注册\"></a>独立运行服务注册</h3><p>将上述编写的服务注册的程序独立运行起来，将启动日志服务的main.go单独丢进一个cmd下的logservice文件夹，在cmd下创建一个registryservice文件夹，编写对应的main.go文件:</p>\n<pre><code class=\"go\">package main\n \nimport (\n    &quot;context&quot;\n    &quot;distributed/registry&quot;\n    &quot;fmt&quot;\n    &quot;log&quot;\n    &quot;net/http&quot;\n)\n \nfunc main() &#123;\n    http.Handle(&quot;/services&quot;, &amp;registry.Service&#123;&#125;)\n \n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel()\n \n    var srv http.Server\n    srv.Addr = registry.ServerPort\n \n    go func() &#123;\n        log.Println(srv.ListenAndServe())\n        var s string\n        fmt.Scanln(&amp;s)\n        srv.Shutdown(ctx)\n        cancel()\n    &#125;()\n \n    &lt;-ctx.Done()\n    fmt.Println(&quot;Shutting down registry service&quot;)\n&#125;\n</code></pre>\n<p>这段代码的作用就是将服务注册程序给运行起来，registry.Service已经实现了ServeHTTP接口方法，因此可以直接将这个结构体变量传给http.Handle函数</p>\n<p>这段代码与上述service.go有点相似，在用户输入任意字符后中止掉程序</p>\n<h3 id=\"注册一个服务\"><a href=\"#注册一个服务\" class=\"headerlink\" title=\"注册一个服务\"></a>注册一个服务</h3><p>封装一个函数向服务端发送POST请求来注册一个服务，在registry下编写一个client.go文件:</p>\n<pre><code class=\"go\">package registry\n \nimport (\n    &quot;bytes&quot;\n    &quot;encoding/json&quot;\n    &quot;fmt&quot;\n    &quot;net/http&quot;\n)\n \nfunc RegisterService(r Registration) error &#123;\n    buf := new(bytes.Buffer)\n    enc := json.NewEncoder(buf)\n    err := enc.Encode(r)\n    if err != nil &#123;\n        return err\n    &#125;\n    res, err := http.Post(ServicesURL, &quot;application/json&quot;, buf)\n    if err != nil &#123;\n        return err\n    &#125;\n \n    if res.StatusCode != http.StatusOK &#123;\n        return fmt.Errorf(&quot;failed to register service. Registry service &quot;+\n            &quot;responded with code %v&quot;, res.StatusCode)\n    &#125;\n    return nil\n&#125;\n</code></pre>\n<p>上述代码中定义了一个RegisterService函数，向URL发送POST请求来注册服务，请求中包括了服务名称和服务的URL</p>\n<p>接下来要修改之前的代码，因为发送的数据是Registration结构体类型的数据，而上述编写的服务注册的服务端须要更改参数类型，修改service&#x2F;service.go文件，这里在Start函数中加上Registration结构体类型的参数，serviceName这个参数可以删掉，并且启动这个服务时应该进行注册，所以在该函数中加上RegisterService函数:</p>\n<pre><code class=\"go\">func Start(ctx context.Context, host, port string, reg registry.Registration,\n    registerHandlerFunc func()) (context.Context, error) &#123;\n    registerHandlerFunc()\n    ctx = startService(ctx, reg.ServiceName, host, port)\n    err := registry.RegisterService(reg)  // 注册服务\n    if err != nil &#123;\n        return ctx, err\n    &#125;\n    return ctx, nil\n&#125;\n</code></pre>\n<p>同时一并修改startService函数的参数:</p>\n<pre><code class=\"go\">func startService(ctx context.Context, serviceName registry.ServiceName, host, port string) context.Context &#123;\n    ctx, cancel := context.WithCancel(ctx)\n    var srv http.Server\n    srv.Addr = &quot;:&quot; + port\n \n    go func() &#123;\n        log.Println(srv.ListenAndServe())\n        cancel()\n    &#125;()\n \n    go func() &#123;\n        fmt.Printf(&quot;%v started. Press any key to stop. \\n&quot;, serviceName)\n        var s string\n        fmt.Scanln(&amp;s)\n        srv.Shutdown(ctx)\n        cancel()\n    &#125;()\n \n    return ctx\n&#125;\n</code></pre>\n<p>最后要修改logservice中的main.go，因为函数已经被修改:</p>\n<pre><code class=\"go\">....\nserviceAddress := fmt.Sprintf(&quot;http://%s:%s&quot;, host, port)\n \nr := registry.Registration&#123;\n    ServiceName: &quot;Log Service&quot;,\n    ServiceURL:  serviceAddress,\n&#125;\nctx, err := service.Start(context.Background(),\n    &quot;Log Service&quot;,\n    host, port, r, log.RegisterHandlers,\n)\n....\n</code></pre>\n<p>接下来运行这个服务，先启动registryservice&#x2F;main.go，启动服务注册的程序，在运行logservice&#x2F;main.go，这时会先发送一条POST请求到服务注册的程序，这时服务注册程序收到这条请求，其中包含了服务名称和URL，服务注册程序将其添加到集合，视为注册了这个服务:</p>\n<pre><code class=\"shell\">$ go run .\n2022/08/23 13:40:24 Request received\n2022/08/23 13:40:24 Adding service: Log Service with URL: http://localhost:4000\n</code></pre>\n<p>这时服务注册程序输出已经添加了日志服务</p>\n<h3 id=\"取消注册服务\"><a href=\"#取消注册服务\" class=\"headerlink\" title=\"取消注册服务\"></a>取消注册服务</h3><p>有增就有减，对应地，有服务注册的功能就应该有取消注册的功能</p>\n<p>在registry&#x2F;server.go中添加remove函数，与add函数作用相反，作用是从集合中去除掉指定的url所在的registration:</p>\n<pre><code class=\"go\">func (r *registry) remove(url string) error &#123;\n    for i := range reg.registrations &#123;\n        if reg.registrations[i].ServiceURL == url &#123;\n            r.mutex.Lock()\n            reg.registrations = append(reg.registrations[:i], r.registrations[i+1:]...)\n            r.mutex.Unlock()\n            return nil\n        &#125;\n    &#125;\n    return fmt.Errorf(&quot;service at URL %s not found&quot;, url)\n&#125;\n</code></pre>\n<p>使用for-range遍历reg中的切片，当遇到指定的URL时则将其去除</p>\n<p>服务注册中，POST请求用于注册服务，那么将通过DELETE请求来取消服务，所以在ServeHTTP函数中添加一个针对DELETE请求的分支:</p>\n<pre><code class=\"go\">func (s Service) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\n    log.Println(&quot;Request received&quot;)\n    switch r.Method &#123;\n    ...\n    case http.MethodDelete:\n        payload, err := ioutil.ReadAll(r.Body)\n        if err != nil &#123;\n            log.Println(err)\n            w.WriteHeader(http.StatusInternalServerError)\n            return\n        &#125;\n        url := string(payload)\n        log.Printf(&quot;Removing servcice at URL: %s&quot;, url)\n        err = reg.remove(url)\n    default:\n        w.WriteHeader(http.StatusMethodNotAllowed)\n        return\n    &#125;\n&#125;\n</code></pre>\n<p>在这个服务端接收到DELETE请求后，取出其中body的URL，再调用remove函数进行删除</p>\n<p>在registry&#x2F;client.go中添加客户端用来取消服务的函数:</p>\n<pre><code class=\"go\">func ShutdownService(url string) error &#123;\n    req, err := http.NewRequest(http.MethodDelete, ServicesURL, bytes.NewBuffer([]byte(url)))\n    if err != nil &#123;\n        return err\n    &#125;\n    req.Header.Add(&quot;Content-Type&quot;, &quot;text/plain&quot;)\n    res, err := http.DefaultClient.Do(req)\n    if err != nil &#123;\n        return err\n    &#125;\n    if res.StatusCode != http.StatusOK &#123;\n        return fmt.Errorf(&quot;failed to deregister service. Registry &quot;+\n            &quot;service responded with code %v&quot;, res.StatusCode)\n    &#125;\n    return nil\n&#125;\n</code></pre>\n<p>使用http.NewRequest来发送DELETE请求</p>\n<p>在StartService函数中，当服务停止时，调用该shutdown函数向服务端发送DELETE请求取消掉这个服务</p>\n<pre><code class=\"go\">func startService(ctx context.Context, serviceName registry.ServiceName, host, port string) context.Context &#123;\n    ...\n    go func() &#123;\n        log.Println(srv.ListenAndServe())\n        err := registry.ShutdownService(fmt.Sprintf(&quot;http://%s:%s&quot;, host, port))\n        if err != nil &#123;\n            log.Println(err)\n        &#125;\n        cancel()\n    &#125;()\n    ...\n&#125;\n</code></pre>\n<p>测试:</p>\n<p>先启动服务注册程序，然后再启动日志服务，再按任意键关闭</p>\n<p>日志服务:</p>\n<pre><code class=\"shell\">$ go run .\nLog Service started. Press any key to stop. \n \n2022/08/23 16:45:44 http: Server closed\nShutting down log service.\n</code></pre>\n<p>服务注册程序:</p>\n<pre><code class=\"shell\">$ go run .\n2022/08/23 16:45:42 Request received\n2022/08/23 16:45:42 Adding service: Log Service with URL: http://localhost:4000\n2022/08/23 16:45:44 Request received\n2022/08/23 16:45:44 Removing servcice at URL: http://localhost:4000\n2022/08/23 16:45:44 Request received\n2022/08/23 16:45:44 Removing servcice at URL: http://localhost:4000\n</code></pre>\n<h2 id=\"服务发现\"><a href=\"#服务发现\" class=\"headerlink\" title=\"服务发现\"></a>服务发现</h2><p>在此之前，先实现一个业务服务，功能是学生成绩管理，用户可以查询和增加学生的成绩信息</p>\n<h3 id=\"创建业务服务\"><a href=\"#创建业务服务\" class=\"headerlink\" title=\"创建业务服务\"></a>创建业务服务</h3><p>创建一个grades文件夹，编写相关代码，如下是grades.go文件，包含了成绩信息管理的主要逻辑:</p>\n<pre><code class=\"go\">package grades\n \nimport (\n    &quot;fmt&quot;\n    &quot;sync&quot;\n)\n \ntype Student struct &#123;\n    ID        int\n    FirstName string\n    LastName  string\n    Grades    []Grade\n&#125;\n \nfunc (s Student) Average() float32 &#123;\n    var result float32\n    for _, grade := range s.Grades &#123;\n        result += grade.Score\n    &#125;\n    return result / float32(len(s.Grades))\n&#125;\n \ntype Students []Student\n \nvar (\n    students      Students\n    studentsMutex sync.Mutex\n)\n \nfunc (ss Students) GetByID(id int) (*Student, error) &#123;\n    for i := range ss &#123;\n        if ss[i].ID == id &#123;\n            return &amp;ss[i], nil\n        &#125;\n    &#125;\n    return nil, fmt.Errorf(&quot;student with ID %d not found&quot;, id)\n&#125;\n \ntype GradeType string\n \nconst (\n    GradeQuiz = GradeType(&quot;Quiz&quot;)\n    GradeTest = GradeType(&quot;Test&quot;)\n    GradeExam = GradeType(&quot;Exam&quot;)\n)\n \ntype Grade struct &#123;\n    Title string\n    Type  GradeType\n    Score float32\n&#125;\n</code></pre>\n<p>定义了students结构体，表示了学生信息:</p>\n<pre><code class=\"go\">type Student struct &#123;\n    ID        int     // 学生ID\n    FirstName string  // 名\n    LastName  string  // 姓\n    Grades    []Grade // 成绩\n&#125;\n</code></pre>\n<p>定义了grade结构体:</p>\n<pre><code class=\"go\">type Grade struct &#123;\n    Title string       // 名称\n    Type  GradeType    // 类别\n    Score float32      // 得分\n&#125;\n</code></pre>\n<p>GetByID用于根据ID来查询学生信息，Average用于求平均成绩</p>\n<p>创建server.go文件，作为该服务的后端，之后会被services中的Start函数调用:</p>\n<pre><code class=\"go\">package grades\n \nimport (\n    &quot;bytes&quot;\n    &quot;encoding/json&quot;\n    &quot;fmt&quot;\n    &quot;log&quot;\n    &quot;net/http&quot;\n    &quot;strconv&quot;\n    &quot;strings&quot;\n)\n \nfunc RegisterHandlers() &#123;\n    handler := new(studentsHandler)\n    http.Handle(&quot;/students&quot;, handler)\n    http.Handle(&quot;/students/&quot;, handler)\n&#125;\n \ntype studentsHandler struct&#123;&#125;\n \nfunc (sh studentsHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\n    pathSegments := strings.Split(r.URL.Path, &quot;/&quot;)\n    switch len(pathSegments) &#123;\n    case 2:\n        sh.getAll(w, r)\n    case 3:\n        id, err := strconv.Atoi(pathSegments[2])\n        if err != nil &#123;\n            w.WriteHeader(http.StatusNotFound)\n            return\n        &#125;\n        sh.getOne(w, r, id)\n    case 4:\n        id, err := strconv.Atoi(pathSegments[2])\n        if err != nil &#123;\n            w.WriteHeader(http.StatusNotFound)\n            return\n        &#125;\n        sh.addGrade(w, r, id)\n    default:\n        w.WriteHeader(http.StatusNotFound)\n    &#125;\n&#125;\n \nfunc (sh studentsHandler) getAll(w http.ResponseWriter, r *http.Request) &#123;\n    studentsMutex.Lock()\n    defer studentsMutex.Unlock()\n \n    data, err := sh.toJSON(students)\n    if err != nil &#123;\n        w.WriteHeader(http.StatusInternalServerError)\n        log.Println(err)\n        return\n    &#125;\n    w.Header().Add(&quot;Content-Type&quot;, &quot;application/json&quot;)\n    w.Write(data)  // 写回数据\n&#125;\n \nfunc (sh studentsHandler) toJSON(obj interface&#123;&#125;) ([]byte, error) &#123;\n    var b bytes.Buffer\n    enc := json.NewEncoder(&amp;b)\n    err := enc.Encode(obj)\n    if err != nil &#123;\n        return nil, fmt.Errorf(&quot;failed to serialize students: %q&quot;, err)\n    &#125;\n    return b.Bytes(), nil\n&#125;\n \nfunc (sh studentsHandler) getOne(w http.ResponseWriter, r *http.Request, id int) &#123;\n    studentsMutex.Lock()\n    defer studentsMutex.Unlock()\n \n    student, err := students.GetByID(id)\n    if err != nil &#123;\n        w.WriteHeader(http.StatusNotFound)\n        log.Println(err)\n        return\n    &#125;\n \n    data, err := sh.toJSON(student)\n    if err != nil &#123;\n        w.WriteHeader(http.StatusInternalServerError)\n        log.Printf(&quot;Failed to serialize student: %q\\n&quot;, err)\n        return\n    &#125;\n    w.Header().Add(&quot;Content-Type&quot;, &quot;application/json&quot;)\n    w.Write(data)\n&#125;\n \nfunc (sh studentsHandler) addGrade(w http.ResponseWriter, r *http.Request, id int) &#123;\n    studentsMutex.Lock()\n    defer studentsMutex.Unlock()\n \n    student, err := students.GetByID(id)\n    if err != nil &#123;\n        w.WriteHeader(http.StatusNotFound)\n        log.Println(err)\n        return\n    &#125;\n    var g Grade\n    dec := json.NewDecoder(r.Body)\n    err = dec.Decode(&amp;g)\n    if err != nil &#123;\n        w.WriteHeader(http.StatusBadRequest)\n        log.Println(err)\n        return\n    &#125;\n    student.Grades = append(student.Grades, g)  // 添加数据\n    w.WriteHeader(http.StatusCreated)\n    data, err := sh.toJSON(g)\n    if err != nil &#123;\n        log.Println(err)\n        return\n    &#125;\n    w.Header().Add(&quot;Content-Type&quot;, &quot;application/json&quot;)\n    w.Write(data)\n&#125;\n</code></pre>\n<p>使用RegisterHandlers注册http handler，路径指向URL下的students，会作为Start函数的参数</p>\n<p>作为一个服务，同样要为结构体定义一个接口方法ServeHTTP，该方法要应对URL的几种情况:</p>\n<ol>\n<li><code>/students</code> 获得所有学生的成绩</li>\n<li><code>/students/&#123;id&#125;</code> 获得指定ID的学生的信息</li>\n<li><code>/students/&#123;id&#125;/grades</code>获得增加学生的成绩</li>\n</ol>\n<p>使用string.Split将URL路径切分为多段，使用switch-case结构根据分段的个数进行分支处理，段数为2、3和4分别对应了上述3种情况，分别调用getAll、getOne和addGrade函数，实现细节不再赘述</p>\n<p>这里还要定义一个将结构体序列化为JSON数据的函数，接收一个空接口:</p>\n<pre><code class=\"go\">func (sh studentsHandler) toJSON(obj interface&#123;&#125;) ([]byte, error) &#123;\n    var b bytes.Buffer\n    enc := json.NewEncoder(&amp;b)\n    err := enc.Encode(obj)\n    if err != nil &#123;\n        return nil, fmt.Errorf(&quot;failed to serialize students: %q&quot;, err)\n    &#125;\n    return b.Bytes(), nil\n&#125;\n</code></pre>\n<p>编写一个mockdata.go文件，制造一些数据:</p>\n<pre><code class=\"go\">package grades\n \nfunc init() &#123;\n    students = []Student&#123;\n        &#123;\n            ID:        1,\n            FirstName: &quot;Nick&quot;,\n            LastName:  &quot;Carter&quot;,\n            Grades: []Grade&#123;\n                &#123;\n                    &quot;Quiz 1&quot;,\n                    GradeQuiz,\n                    85,\n                &#125;,\n                &#123;\n                    &quot;Final Exam&quot;,\n                    GradeExam,\n                    94,\n                &#125;,\n                &#123;\n                    &quot;Quiz 2&quot;,\n                    GradeQuiz,\n                    97,\n                &#125;,\n            &#125;,\n        &#125;,\n        &#123;\n            ID:        2,\n            FirstName: &quot;Jack&quot;,\n            LastName:  &quot;Bright&quot;,\n            Grades: []Grade&#123;\n                &#123;\n                    &quot;Final Exam&quot;,\n                    GradeExam,\n                    100,\n                &#125;,\n                &#123;\n                    &quot;Quiz 2&quot;,\n                    GradeQuiz,\n                    80,\n                &#125;,\n                &#123;\n                    &quot;Test 1&quot;,\n                    GradeTest,\n                    99,\n                &#125;,\n            &#125;,\n        &#125;,\n    &#125;\n&#125;\n</code></pre>\n<p>这样一个业务服务就完成了，添加到registry&#x2F;registrantion.go中:</p>\n<pre><code class=\"go\">const (\n    LogService     = ServiceName(&quot;LogService&quot;)\n    GradingService = ServiceName(&quot;GradingService&quot;)  // 业务服务\n)\n</code></pre>\n<p>和日志服务相似，创建cmd&#x2F;gradingservice&#x2F;main.go文件，编写启动代码:</p>\n<pre><code class=\"go\">package main\n \nimport (\n    &quot;context&quot;\n    &quot;distributed/log&quot;\n    &quot;distributed/registry&quot;\n    &quot;distributed/service&quot;\n    &quot;fmt&quot;\n    stdlog &quot;log&quot;\n)\n \nfunc main() &#123;\n    log.Run(&quot;./distributed.log&quot;)\n    host, port := &quot;localhost&quot;, &quot;6000&quot;\n    serviceAddress := fmt.Sprintf(&quot;http://%s:%s&quot;, host, port)\n \n    r := registry.Registration&#123;\n        ServiceName: registry.GradingService,\n        ServiceURL:  serviceAddress,\n    &#125;\n    ctx, err := service.Start(context.Background(),\n        host, port, r, log.RegisterHandlers,\n    )\n \n    if err != nil &#123;\n        stdlog.Fatalln(err)\n    &#125;\n    &lt;-ctx.Done()\n \n    fmt.Println(&quot;Shutting down grading service.&quot;)\n&#125;\n</code></pre>\n<p>服务注册到这里就基本实现了，如下是项目结构:</p>\n<pre><code class=\"shell\">.\n├── cmd\n│   ├── gradingservice\n│   │   └── main.go\n│   ├── logservice\n│   │   └── main.go\n│   └── registryservice\n│       └── main.go\n├── log\n│   └── server.go\n├── registry\n│   ├── client.go\n│   ├── registration.go\n│   └── server.go\n└── service\n    └── service.go\n</code></pre>\n<h3 id=\"实现服务发现\"><a href=\"#实现服务发现\" class=\"headerlink\" title=\"实现服务发现\"></a>实现服务发现</h3><p>完成了上述的业务服务gradingservice后，要使其能够请求logservice</p>\n<p>接下来编辑registry&#x2F;registration.go文件，扩展Registration结构体:</p>\n<pre><code class=\"go\">type Registration struct &#123;\n    ServiceName      ServiceName\n    ServiceURL       string\n    RequiredServices []ServiceName\n    ServiceUpdateURL string\n&#125;\n</code></pre>\n<p>RequiredServices表示了该服务所依赖的服务名称，ServiceUpdateURL用于动态接收更新，比如注册中心就通过这个URL告诉这个服务，这里有一个logservice</p>\n<p>创建两个结构体:</p>\n<pre><code class=\"go\">type patchEntry struct &#123;\n    Name ServiceName\n    URL  string\n&#125;\n</code></pre>\n<p>该结构体表示单条更新条目</p>\n<pre><code class=\"go\">type patch struct &#123;\n    Added   []patchEntry\n    Removed []patchEntry\n&#125;\n</code></pre>\n<p>该结构体记录增加和减少的条目</p>\n<p>编写registry&#x2F;server.go，扩展注册中心的后端，先扩展add函数，在添加服务时就添加为其依赖服务:</p>\n<pre><code class=\"go\">func (r *registry) add(reg Registration) error &#123;\n    r.mutex.Lock()\n    r.registrations = append(r.registrations, reg)\n    r.mutex.Unlock()\n    err := r.sendRequiredServices(reg)\n    if err != nil &#123;\n        return err\n    &#125;\n    return nil\n&#125;\n</code></pre>\n<p>调用了一个sendRequiredServices函数，功能是添加依赖，发送一个请求，将所要依赖的服务给请求过来，方法实现如下:</p>\n<pre><code class=\"go\">func (r *registry) sendRequiredServices(reg Registration) error &#123;\n    r.mutex.RLock()\n    defer r.mutex.RUnlock()\n \n    var p patch\n    for _, serviceReg := range r.registrations &#123;\n        for _, reqService := range reg.RequiredServices &#123;\n            if serviceReg.ServiceName == reqService &#123;\n                p.Added = append(p.Added, patchEntry&#123;\n                    Name: serviceReg.ServiceName,\n                    URL:  serviceReg.ServiceURL,\n                &#125;)\n            &#125;\n        &#125;\n    &#125;\n    err := r.sendPatch(p, reg.ServiceUpdateURL)\n    return err\n&#125;\n</code></pre>\n<p>上述函数中，循环遍历已经注册的服务，如果找到所依赖的服务，则添加到切片里，稍后调用sendPatch发送出去，实现如下:</p>\n<pre><code class=\"go\">func (r *registry) sendPatch(p patch, url string) error &#123;\n    d, err := json.Marshal(p)\n    if err != nil &#123;\n        return err\n    &#125;\n    _, err = http.Post(url, &quot;application/json&quot;, bytes.NewBuffer(d))\n    return err\n&#125;\n</code></pre>\n<p>该函数先将patch结构序列化为一个JSON数据，然后放在POST请求中发送</p>\n<p>每个客户端的服务都有所依赖的服务，要向注册中心请求这些服务，得存储这些请求的服务，比如gradingservice就要依赖logservice</p>\n<p>定义一个结构providers:</p>\n<pre><code class=\"go\">type providers struct &#123;\n    services map[ServiceName][]string\n    mutex    *sync.RWMutex\n&#125;\n</code></pre>\n<p>其中储存了服务的提供者，定义了一个map结构，和一个读写锁</p>\n<p>初始化这个结构体变量:</p>\n<pre><code class=\"go\">var prov = providers&#123;\n    services: make(map[ServiceName][]string),\n    mutex:    new(sync.RWMutex),\n&#125;\n</code></pre>\n<p>定义对于的更新方法，用于更新这个结构中的数据:</p>\n<pre><code class=\"go\">func (p *providers) Update(pat patch) &#123;\n    p.mutex.Lock()\n    defer p.mutex.Unlock()\n \n    for _, patchEntry := range pat.Added &#123;\n        if _, ok := p.services[patchEntry.Name]; !ok &#123;\n            p.services[patchEntry.Name] = make([]string, 0)\n        &#125;\n        p.services[patchEntry.Name] = append(p.services[patchEntry.Name], patchEntry.URL)\n    &#125;\n    for _, patchEntry := range pat.Removed &#123;\n        if providerURLs, ok := p.services[patchEntry.Name]; ok &#123;\n            for i := range providerURLs &#123;\n                if providerURLs[i] == patchEntry.URL &#123;\n                    p.services[patchEntry.Name] = append(providerURLs[:i], providerURLs[i+1:]...)\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>先遍历Added，也就是patch要增加的服务，如果added里的服务在providers中还不存在，则创建这个service，然后将这个服务和对应URL写入map，同理，接着遍历Removed，已有的服务就将其删除</p>\n<p>接着定义了一个get函数，通过服务名称找到对应的URL:</p>\n<pre><code class=\"go\">func (p *providers) get(name ServiceName) (string, error) &#123;\n    providers, ok := p.services[name]\n    if !ok &#123;\n        return &quot;&quot;, fmt.Errorf(&quot;no providers avaliable for service %v&quot;, name)\n    &#125;\n    idx := int(rand.Float32() * float32(len(providers)))\n    return providers[idx], nil\n&#125;\n \nfunc GetProvider(name ServiceName) (string, error) &#123;\n    return prov.get(name)\n&#125;\n</code></pre>\n<p>目前providers只有logservice</p>\n<p>接着再将ServiceUpdateURL绑定到一个handler上，从而能够对其进行处理:</p>\n<pre><code class=\"go\">func RegisterService(r Registration) error &#123;\n    serviceUpdateURL, err := url.Parse(r.ServiceUpdateURL)\n    if err != nil &#123;\n        return err\n    &#125;\n    http.Handle(serviceUpdateURL.Path, &amp;serviceUpdateHandler&#123;&#125;)\n    ....\n&#125;\n</code></pre>\n<p>定义接口方法:</p>\n<pre><code class=\"go\">type serviceUpdateHandler struct&#123;&#125;\n \nfunc (suh serviceUpdateHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\n    if r.Method != http.MethodPost &#123;\n        w.WriteHeader(http.StatusMethodNotAllowed)\n        return\n    &#125;\n    dec := json.NewDecoder(r.Body)\n    var p patch\n    err := dec.Decode(&amp;p)\n    if err != nil &#123;\n        log.Println(err)\n        w.WriteHeader(http.StatusBadGateway)\n    &#125;\n    prov.Update(p)\n&#125;\n</code></pre>\n<p>ServeHTTP中接收POST请求，将Body到数据反序列化后传入Update方法再调用</p>\n<p>因为经过了一些扩展，所以要修改Registration，增加所要依赖的服务和URL字段</p>\n<pre><code class=\"go\">type Registration struct &#123;\n    ServiceName      ServiceName\n    ServiceURL       string\n    RequiredServices []ServiceName\n    ServiceUpdateURL string\n&#125;\n</code></pre>\n<p>下面优化一下logservice，目前日志服务只有一个服务端，要让客户端能够方便地使用提供的logservice服务，在log下再编写一个client.go文件:</p>\n<pre><code class=\"go\">package log\n \nimport (\n    &quot;bytes&quot;\n    &quot;distributed/registry&quot;\n    &quot;fmt&quot;\n    stdlog &quot;log&quot;\n    &quot;net/http&quot;\n)\n \nfunc SetClientLogger(serviceURL string, clientService registry.ServiceName) &#123;\n    stdlog.SetPrefix(fmt.Sprintf(&quot;[%v] - &quot;, clientService))\n    stdlog.SetFlags(0)  // 不设置flag\n    stdlog.SetOutput(&amp;clientLogger&#123;serviceURL&#125;)\n&#125;\n \ntype clientLogger struct &#123;\n    url string\n&#125;\n \nfunc (cl clientLogger) Write(data []byte) (n int, err error) &#123;\n    b := bytes.NewBuffer([]byte(data))\n    res, err := http.Post(cl.url+&quot;/log&quot;, &quot;text/plain&quot;, b)\n    if err != nil &#123;\n        return 0, err\n    &#125;\n    if res.StatusCode != http.StatusOK &#123;\n        return 0, fmt.Errorf(&quot;failed to send log message. &quot;)\n    &#125;\n    return len(data), nil\n&#125;\n</code></pre>\n<p>SetClientLogger负责设置客户端日志打印的相关的属性，因为要为clientLogger实现io.Writer接口，所以下面为其实现一个Write方法</p>\n<p>扩展gradingservice&#x2F;main.go中结构体的定义:</p>\n<pre><code class=\"go\">r := registry.Registration&#123;\n    ServiceName:      registry.GradingService,\n    ServiceURL:       serviceAddress,\n    RequiredServices: []registry.ServiceName&#123;registry.LogService&#125;,\n    ServiceUpdateURL: serviceAddress + &quot;/services&quot;,\n&#125;\n</code></pre>\n<p>logservice同时接着还要获取Provider，即获取提供日志的服务的名称，这便是服务发现</p>\n<pre><code class=\"go\">if logProvider, err := registry.GetProvider(registry.LogService); err == nil &#123;\n    fmt.Printf(&quot;Logging service found at: %s\\n&quot;, logProvider)\n    log.SetClientLogger(logProvider, r.ServiceName)\n&#125;\n</code></pre>\n<p>运行测试:</p>\n<p>先运行注册中心</p>\n<pre><code class=\"shell\">$ go run .\n2022/08/24 13:03:05 Request received\n2022/08/24 13:03:05 Adding service: LogService with URL: http://localhost:4000\n2022/08/24 13:03:21 Request received\n2022/08/24 13:03:21 Adding service: GradingService with URL: http://localhost:6000\n</code></pre>\n<p>运行日志服务</p>\n<pre><code class=\"shell\">$ go run .\nLogService started. Press any key to stop. \n</code></pre>\n<p>运行gradding服务</p>\n<pre><code class=\"shell\">$ go run .\nGradingService started. Press any key to stop. \nLogging service found at: http://localhost:4000\n</code></pre>\n<h3 id=\"服务更新\"><a href=\"#服务更新\" class=\"headerlink\" title=\"服务更新\"></a>服务更新</h3><p>对于一个服务，当所依赖的服务发生变化时，应当发出通知，例如logservice，当这个服务停止时，应该发出一条通知来告知gradingservice，启动时也应当发出一条通知，在上面的实现中，gradingservice只能在启动时发现logservice，并且logservice要先于gradingservice启动</p>\n<p>在服务启动时就应该进行通知，所以在add函数中添加一个通知函数:</p>\n<pre><code class=\"go\">func (r *registry) add(reg Registration) error &#123;\n    ....\n    err := r.sendRequiredServices(reg)\n    r.notify(patch&#123;\n        Added: []patchEntry&#123;\n            &#123;\n                Name: reg.ServiceName,\n                URL:  reg.ServiceURL,\n            &#125;,\n        &#125;,\n    &#125;)\n    return err\n&#125;\n</code></pre>\n<p>通知函数的实现:</p>\n<pre><code class=\"go\">func (r *registry) notify(fullPatch patch) &#123;\n    r.mutex.RLock()\n    defer r.mutex.RUnlock()\n    \n    for _, reg := range r.registrations &#123;\n        go func(reg Registration) &#123;\n            for _, reqService := range reg.RequiredServices &#123;\n                p := patch&#123;\n                    Added:   []patchEntry&#123;&#125;,\n                    Removed: []patchEntry&#123;&#125;,\n                &#125;\n                sendUpdate := false\n                for _, added := range fullPatch.Added &#123;\n                    if added.Name == reqService &#123;\n                        p.Added = append(p.Added, added)\n                        sendUpdate = true\n                    &#125;\n                &#125;\n                for _, removed := range fullPatch.Removed &#123;\n                    if removed.Name == reqService &#123;\n                        p.Removed = append(p.Removed, removed)\n                        sendUpdate = true\n                    &#125;\n                &#125;\n                if sendUpdate &#123;\n                    err := r.sendPatch(p, reg.ServiceUpdateURL)  // 发送patch\n                    if err != nil &#123;\n                        log.Println(err)\n                        return\n                    &#125;\n                &#125;\n            &#125;\n        &#125;(reg)\n    &#125;\n&#125;\n</code></pre>\n<p>这个notify函数接收一个patch变量作为参数，其中包含的added和removed，对应增加和移除的服务，函数体中要做的事就是先遍历所有的服务，然后遍历其所有的依赖服务，根据传入的fullPatch和added和removed，如果依赖服务是要增加或移除的，则将sendUpdate标志设置为true，产生patch并发送，进行更新，这些流程使用goroutine来并发地进行</p>\n<p>在registry&#x2F;client.go的ServeHTTP函数中增加一句提示信息，表示接收到了更新:</p>\n<pre><code class=\"go\">func (suh serviceUpdateHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\n    ....\n    fmt.Printf(&quot;Updated received %v\\n&quot;, p)\n    prov.Update(p)\n&#125;\n</code></pre>\n<p>对remove函数同样要进行扩展:</p>\n<pre><code class=\"go\">func (r *registry) remove(url string) error &#123;\n    for i := range reg.registrations &#123;\n        if reg.registrations[i].ServiceURL == url &#123;\n            r.notify(patch&#123;\n                Removed: []patchEntry&#123;\n                    &#123;\n                        Name: r.registrations[i].ServiceName,\n                        URL:  r.registrations[i].ServiceURL,\n                    &#125;,\n                &#125;,\n            &#125;)\n    ...\n    return fmt.Errorf(&quot;service at URL %s not found&quot;, url)\n&#125;\n</code></pre>\n<p>运行测试: 先运行注册中心，然后运行logservice，然后运行gradingservice，之后关闭logservice再启动</p>\n<p>注册中心:</p>\n<pre><code class=\"shell\">$ go run .\n2022/08/24 18:03:45 Request received\n2022/08/24 18:03:45 Adding service: LogService with URL: http://localhost:4000\n2022/08/24 18:03:50 Request received\n2022/08/24 18:03:50 Adding service: GradingService with URL: http://localhost:6000\n2022/08/24 18:03:53 Request received\n2022/08/24 18:03:53 Removing servcice at URL: http://localhost:4000\n2022/08/24 18:03:53 Request received\n2022/08/24 18:03:53 Removing servcice at URL: http://localhost:4000\n2022/08/24 18:04:12 Request received\n2022/08/24 18:04:12 Adding service: LogService with URL: http://localhost:4000\n</code></pre>\n<p>日志服务:</p>\n<pre><code class=\"shell\">$ go run .\nLogService started. Press any key to stop. \nUpdated received &#123;[] []&#125;\n \n2022/08/24 18:03:53 http: Server closed\nShutting down log service.\n$ go run .\nLogService started. Press any key to stop. \nUpdated received &#123;[] []&#125;\n</code></pre>\n<p>grading服务:</p>\n<pre><code class=\"shell\">$ go run .\nGradingService started. Press any key to stop. \nUpdated received &#123;[&#123;LogService http://localhost:4000&#125;] []&#125;\nLogging service found at: http://localhost:4000\nUpdated received &#123;[] [&#123;LogService http://localhost:4000&#125;]&#125;\nUpdated received &#123;[&#123;LogService http://localhost:4000&#125;] []&#125;\n</code></pre>\n<h2 id=\"服务状态监控\"><a href=\"#服务状态监控\" class=\"headerlink\" title=\"服务状态监控\"></a>服务状态监控</h2><p>检查所有服务的健康状况，方法是发送心跳请求，得知服务是否能正常响应</p>\n<p>在Registration中加一条HeartbeatURL:</p>\n<pre><code class=\"go\">type Registration struct &#123;\n    ServiceName      ServiceName\n    ServiceURL       string\n    RequiredServices []ServiceName\n    ServiceUpdateURL string\n    HeartbeatURL     string\n&#125;\n</code></pre>\n<p>增加心跳检查函数:</p>\n<pre><code class=\"go\">func (r *registry) heartbeat(freq time.Duration) &#123;\n    for &#123;\n        var wg sync.WaitGroup\n        for _, reg := range r.registrations &#123;\n            wg.Add(1)\n            go func(reg Registration) &#123;\n                defer wg.Done()\n                success := true\n                for attemps := 0; attemps &lt; 3; attemps++ &#123;\n                    res, err := http.Get(reg.HeartbeatURL)\n                    if err != nil &#123;\n                        log.Println(err)\n                    &#125; else if res.StatusCode == http.StatusOK &#123;\n                        log.Printf(&quot;Heartbeat check passed for %v&quot;, reg.ServiceName)\n                        if !success &#123;\n                            r.add(reg)\n                        &#125;\n                        break\n                    &#125;\n                    log.Printf(&quot;Heartbeat check failed for %v&quot;, reg.ServiceName)\n                    if success &#123;\n                        success = false\n                        r.remove(reg.ServiceURL)\n                    &#125;\n                &#125;\n            &#125;(reg)\n            wg.Wait()\n            time.Sleep(freq)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>上述代码中用到了waitgroup和goroutine，对每个服务的HeartbeatURL间隔freq的时间发起get请求，连续发送三次，如果有一次失败(状态码不等于200)，那么success为false，那么会调用remove来移除服务，如果success为false又得到了正常的相应，那么又会调用add将服务加回来</p>\n<p>上述这段代码将会在如下函数中调用，将其定义在registry&#x2F;server.go中，每隔3秒检查一次服务健康状况:</p>\n<pre><code class=\"go\">var once sync.Once\n \nfunc SetupRegistryService() &#123;\n    once.Do(func() &#123;\n        go reg.heartbeat(3 * time.Second)\n    &#125;)\n&#125;\n</code></pre>\n<p>与此同时，所有的客户端都应该知道如何相应这种心跳请求:</p>\n<pre><code class=\"go\">func RegisterService(r Registration) error &#123;\n    heartbeatURL, err := url.Parse(r.HeartbeatURL)\n    if err != nil &#123;\n        return err\n    &#125;\n    http.HandleFunc(heartbeatURL.Path, func(w http.ResponseWriter, r *http.Request) &#123;\n        w.WriteHeader(http.StatusOK)\n    &#125;)\n    ....\n&#125;\n</code></pre>\n<p>在服务注册时，就在心跳URL注册一个handler，处理心跳请求，最后为logservice和gradingservice都加上心跳URL:</p>\n<pre><code class=\"go\">r := registry.Registration&#123;\n    ServiceName:      registry.LogService,\n    ServiceURL:       serviceAddress,\n    RequiredServices: make([]registry.ServiceName, 0),\n    ServiceUpdateURL: serviceAddress + &quot;/services&quot;,\n    HeartbeatURL:     serviceAddress + &quot;/heartbeat&quot;,\n&#125;\n</code></pre>\n<p>测试</p>\n<p>启动注册中心和两个服务，中途关掉logservice</p>\n<p>注册中心的输出:</p>\n<pre><code class=\"shell\">2022/08/24 19:12:24 Adding service: LogService with URL: http://localhost:4000\n2022/08/24 19:12:24 Heartbeat check passed for LogService\n2022/08/24 19:12:26 Request received\n2022/08/24 19:12:26 Adding service: GradingService with URL: http://localhost:6000\n2022/08/24 19:12:27 Heartbeat check passed for LogService\n2022/08/24 19:12:30 Heartbeat check passed for GradingService\n2022/08/24 19:12:33 Heartbeat check passed for LogService\n2022/08/24 19:12:36 Heartbeat check passed for GradingService\n2022/08/24 19:12:36 Request received\n2022/08/24 19:12:36 Removing servcice at URL: http://localhost:4000\n2022/08/24 19:12:36 Request received\n2022/08/24 19:12:36 Removing servcice at URL: http://localhost:4000\n2022/08/24 19:12:39 Heartbeat check passed for GradingService\n2022/08/24 19:12:42 Heartbeat check passed for GradingService\n2022/08/24 19:12:45 Heartbeat check passed for GradingService\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "分布式系统"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/",
            "url": "https://hdqjl317.github.io/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/",
            "title": "vscode通过密钥连接远程服务器",
            "date_published": "2022-08-20T08:28:27.000Z",
            "content_html": "<p><strong>一，生成密钥，或者在购买服务器时选择 ssh 密匙登录</strong></p>\n<p>第一种：通过指令 ssh-keygen 生成，具体的我就不说了</p>\n<p>第二种：通过服务商生成，阿里云，腾讯云，华为云的网站有创建密钥的，比如腾讯云</p>\n<p></p>\n<p><img data-src=\"vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204153756653.png\" alt=\"\" /></p>\n<p><strong>二，将密钥绑定到服务器，也可以在网站直接操作，修改密码为密钥就好了</strong></p>\n<p><strong>三，在 vscode 上安装 Remote Development 插件，然后将几个扩展包也安装一下</strong></p>\n<p><strong>四，点击远程资源管理器</strong></p>\n<p></p>\n<p><img data-src=\"vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204153918156.png\" alt=\"\" /><br />\n<strong>五，点击 + 号在输入框输入 ssh 登录名 @IP 地址</strong></p>\n<p></p>\n<p><img data-src=\"vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204153949670.png\" alt=\"\" /></p>\n<p><strong>六，输入完成后按回车会出现选择选择，选择 C:User\\XXX.ssh\\config</strong></p>\n<p></p>\n<p><img data-src=\"vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204154137681.png\" alt=\"\" /></p>\n<p>上面三条是自动生成的，Host 那条是本地名称，可以修改用来区分服务器，最后一条写的是私钥的地址，地址加上 “”。然后点击下图这个符号就可以连接远程服务器了。</p>\n<p></p>\n<p><img data-src=\"vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230204154455497.png\" alt=\"\" /></p>\n",
            "tags": [
                "工作技能",
                "vscode"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/08/10/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%873/",
            "url": "https://hdqjl317.github.io/2022/08/10/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%873/",
            "title": "cpp11新特性篇3",
            "date_published": "2022-08-10T08:24:51.000Z",
            "content_html": "<h2 id=\"autodecltype\"><a class=\"anchor\" href=\"#autodecltype\">#</a> auto&amp;&amp;decltype</h2>\n<p>静态类型：类型检查在编译阶段</p>\n<p>动态类型：类型检查在运行阶段</p>\n<p>auto 声明变量的类型必须由编译器在编译时期推导而得，其优势是在拥有初始化表达式的复杂类型变量声明时简化代码。</p>\n<p>decltype 以一个普通的表达式为参数，返回该表达式的类型。</p>\n<p>用 decltype (e) 来获取类型时，编译器将依序判断以下四规则：</p>\n<ul>\n<li>如果 e 是一个没有带括号的标记符表达式或者类成员访问表达式，那么 decltype (e) 就是 e 所命名的实体的类型。如果 e 是一个被重载的函数，则会导致编译时错误。</li>\n<li>否则，假设 e 的类型是 T，如果 e 是一个将亡值 (xvalue)，那么 decltype (e) 为 T&amp;&amp;。</li>\n<li>否则，假设 e 的类型是 T，如果 e 是一个左值，则 decltype (e) 为 T&amp;。</li>\n<li>否则，假设 e 的类型是 T，则 decltype (e) 为 T。</li>\n</ul>\n<h2 id=\"追踪返回类型\"><a class=\"anchor\" href=\"#追踪返回类型\">#</a> 追踪返回类型</h2>\n<p>对返回类型进行类型推导：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>`<span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span>\t\t\t<span class=\"token comment\">// 直观的方案</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">+</span> t2<span class=\"token punctuation\">)</span> <span class=\"token function\">Sum</span><span class=\"token punctuation\">(</span>T1 <span class=\"token operator\">&amp;</span> t1<span class=\"token punctuation\">,</span> T2 <span class=\"token operator\">&amp;</span> t2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> t1 <span class=\"token operator\">+</span> t2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span>\t\t\t<span class=\"token comment\">// 追踪返回类型的方案</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">auto</span> <span class=\"token function\">Sum</span><span class=\"token punctuation\">(</span>T1 <span class=\"token operator\">&amp;</span> t1<span class=\"token punctuation\">,</span> T2 <span class=\"token operator\">&amp;</span> t2<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">+</span> t2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">return</span> t1 <span class=\"token operator\">+</span> t2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">auto</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">int</span> <span class=\"token punctuation\">;</span>`</pre></td></tr></table></figure><p>把原本的函数返回值移到参数声明之后，而原本的返回值的位置由 auto 关键字占据。auto 占位符和 return_type 是构成追踪返回类型函数的两个基本元素。</p>\n<p>追踪返回类型另一个优势是简化函数的定义，提高代码可读性。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>`#include<span class=\"token operator\">&lt;</span>type_traits<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token function\">pf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">//auto (*)() -> int (*) () 一个返回函数指针的函数（假设为 a 函数）</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">//auto pf1 () -> auto (*)() -> int (*)() 一个返回 a 函数的指针的函数</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">auto</span> <span class=\"token function\">pf1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">auto</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\t<span class=\"token comment\">// 和上面等价</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> is_same<span class=\"token operator\">&lt;</span><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>pf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>pf1<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>value <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>追踪返回类</code> 型也常用于转发函数中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>`#include <span class=\"token operator\">&lt;</span>iostream<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">double</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span>a <span class=\"token operator\">+</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">auto</span> <span class=\"token function\">Forward</span><span class=\"token punctuation\">(</span>T t<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">Forward</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//2.1</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">Forward</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//0</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span>`</pre></td></tr></table></figure>",
            "tags": [
                "编程语言",
                "cpp"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/08/04/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%872/",
            "url": "https://hdqjl317.github.io/2022/08/04/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%872/",
            "title": "cpp11新特性篇2",
            "date_published": "2022-08-04T05:01:42.000Z",
            "content_html": "<h3 id=\"继承构造函数\"><a class=\"anchor\" href=\"#继承构造函数\">#</a> 继承构造函数</h3>\n<p>如果基类有多个构造函数，使用继承构造函数可以让派生类免于重写各个基类的构造函数。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> d<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> f<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">B</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token class-name\">A</span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">using</span> A <span class=\"token operator\">:</span> A<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 继承构造函数</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>c++11 标准继承构造函数和默认构造函数、析构函数、拷贝构造一样，都是隐式声明的。不过继承构造函数只会初始化基类中的成员变量，对于派生类的成员变量无法初始化，这时候要结合初始化表达式为派生类的成员变量设定默认值。但是，<strong>继承构造函数不会继承基类的成员变量的默认值</strong>。</p>\n<p>当派生类的继承基类时，派生类的继承构造函数可能不只有一个结果：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token function\">A</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> <span class=\"token number\">2.4</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">B</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token class-name\">A</span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token keyword\">using</span> A<span class=\"token double-colon punctuation\">::</span>A<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>可能生成的继承构造函数如下：</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span><span class=\"token operator\">=</span><span class=\"token number\">2.4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> A<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>对应的B的构造函数将有：</pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span><span class=\"token operator\">=</span><span class=\"token number\">2.4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> B<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>其他的规则：</p>\n<ul>\n<li>如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，则不能在派生类中声明继承构造函数。</li>\n<li>如果派生类一旦使用了继承构造函数，编译器则不会为派生类构造自己的默认构造函数。</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">&#123;</span><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">B</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token class-name\">A</span></span> <span class=\"token punctuation\">&#123;</span><span class=\"token keyword\">using</span> A<span class=\"token double-colon punctuation\">::</span>A<span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>B b<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//B 没有默认构造函数，不能通过编译</span></pre></td></tr></table></figure><h3 id=\"委派构造函数\"><a class=\"anchor\" href=\"#委派构造函数\">#</a> 委派构造函数</h3>\n<p>所谓委托构造就是让类中的某个构造函数去委托另一个构造函数执行构造操作的机制。一个委托构造函数使用<strong>它所属类的其他构造函数</strong>执行自己的初始化过程。调用者叫委派构造函数，被调用者叫目标构造函数。</p>\n<h3 id=\"右值引用移动语义和完美转发\"><a class=\"anchor\" href=\"#右值引用移动语义和完美转发\">#</a> 右值引用：移动语义和完美转发</h3>\n<p>(1) 移动构造函数：移交所有权，析构自身。</p>\n<ul>\n<li>\n<p>左值：可以取地址的，有名字的。</p>\n</li>\n<li>\n<p>右值：不能取地址，无名字的。又可细分为纯右值和将亡值。</p>\n<ul>\n<li>纯右值：辨识临时变量和一些不跟对象关联的值</li>\n<li>将亡值：C++11 新增的跟右值引用相关的表达式，如右值引用 T &amp;&amp; 的函数返回值、std::move 的返回值、或者转换为 T &amp;&amp; 的类型转换函数的返回值</li>\n</ul>\n</li>\n</ul>\n<p>为区别 C++98 的引用类型，之前的引用叫做左值引用，左值引用和右值引用都是引用类型，声明时都必须立即进行初始化。右值引用只能绑定右值，不能绑定任何左值。左值引用可以接受非常量左值、常量左值、右值对其进行初始化。</p>\n<p><code>T &amp;&amp; a = ReturnRvalue(); \t\t// √ 绑定右值</code></p>\n<p><code>int c;</code> <br />\n <code>int &amp;&amp; d = c;\t\t\t\t\t// X 绑定左值</code></p>\n<p>使用移动语义的前提下需要给类添加一个以右值引用为参数的移动构造函数。</p>\n<p>而通常情况下，在为类声明了一个移动构造函数后，可以声明一个常量左值为参数的拷贝构造函数，以保证在移动构造不成时，还可以进行拷贝构造（偶尔也有特殊用途的反例）。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">引用类型 \\ 可以引用的值类型</th>\n<th style=\"text-align:center\">非常量左值</th>\n<th style=\"text-align:center\">常量左值</th>\n<th style=\"text-align:center\">非常量右值</th>\n<th style=\"text-align:center\">常量右值</th>\n<th style=\"text-align:center\">注记</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">非常量左值引用</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">常量左值引用</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">全能类型、可用于拷贝语义</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">非常量右值引用</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">用于移动语义、完美转发</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">常量右值引用</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">暂无用途</td>\n</tr>\n</tbody>\n</table>\n<p>如果不知道一个类型是否属于引用类型，可以用标准库 &lt;type_traits&gt; 头文件中的 3 个模板类进行判断：is_rvalue_reference、is_lvalue_reference、is_reference。如判断 string &amp;&amp; 的类型：</p>\n<p><code>cout &lt;&lt; is_rvalue_reference&lt;string &amp;&amp;&gt;::value;</code></p>\n<p>(2) std::move: 强制转化为右值</p>\n<p>std::move 基本等同于一个类型转换：</p>\n<p><code>static_cast&lt;T&amp;&amp;&gt;(lvalue);</code></p>\n<p><strong>但注意：被 std::move 转化的左值，其生命期并没有随着左右值的转化而改变。</strong></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Moveable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token function\">Moveable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">i</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token operator\">~</span><span class=\"token function\">Moveable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">delete</span> i<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">Moveable</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Moveable <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">i</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>m<span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">Moveable</span><span class=\"token punctuation\">(</span>Moveable <span class=\"token operator\">&amp;&amp;</span> m<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">i</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        m<span class=\"token punctuation\">.</span>i <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    Moveable a<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    Moveable <span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 会调用移动构造函数</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">.</span>i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 运行时错误</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>move (a) 后，a.i 就被移动构造函数设置为指针空值，所以后来使用会报错</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>*/</span></pre></td></tr></table></figure><p>如上例，在大多数时候，我们需要将其转化为右值引用的还是一个确实生命期即将结束的对象。</p>\n<p>声明了移动构造函数、移动赋值函数、拷贝赋值函数和析构函数中的一个或多个，编译器不会再为程序员生成默认的拷贝构造函数。所以拷贝构造 / 赋值和移动构造 / 赋值函数必须同时提供，或者同时不提供，这才能保证类同时具备拷贝语义和移动语义。</p>\n<p>可以通过可以用标准库 &lt;type_traits&gt; 头文件中的 is_move_constructible、is_trivially_move_constructible、is_nothrow_move_constructible 判断一个类型是否可以移动：</p>\n<p><code>cout &lt;&lt; is_move_constructible&lt;UnknownType&gt;::value;</code></p>\n<p>(3) 完美转发（perfect forwarding）</p>\n<p>完美转发，是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。</p>\n<p><code>template &lt;typename T&gt;</code> <br />\n <code>void IamForwording(T t) &#123; IrunCodeActually(t); &#125;</code></p>\n<p>对于目标函数 IrunCodeActually 而言，它总是希望转发函数将参数按照传入 lamForwarding 时的类型传递 (即传入 lamForwording 的是左值对象，IrunCodeActually 就能获得左值对象，传入 lamForwording 的是右值对象，lrunCodeActually 就能获得右值对象)，而不产生额外的开销，就好像转发者不存在一样。</p>\n<p>C++11 通过使用 “引用折叠”（reference collapsing），结合新的模板推导规则实现完美转发。</p>\n<p>引用折叠：即将复杂的未知表达式折叠为已知的简单表达式。</p>\n<p><code>typedef const int T;</code> <br />\n <code>typedef T&amp; TR;</code> <br />\n <code>TR&amp; v = 1;\t\t//该声明在C++98中会导致编译报错,而在c++11中会导致引用折叠</code></p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<strong>表  c++11 中的引用折叠</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">TR 的类型定义</th>\n<th style=\"text-align:center\">声明 v 的类型</th>\n<th style=\"text-align:center\">v 的实际类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">T&amp;</td>\n<td style=\"text-align:center\">TR</td>\n<td style=\"text-align:center\">A&amp;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">T&amp;</td>\n<td style=\"text-align:center\">TR&amp;</td>\n<td style=\"text-align:center\">A&amp;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">T&amp;</td>\n<td style=\"text-align:center\">TR&amp;&amp;</td>\n<td style=\"text-align:center\">A&amp;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">T&amp;&amp;</td>\n<td style=\"text-align:center\">TR</td>\n<td style=\"text-align:center\">A&amp;&amp;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">T&amp;&amp;</td>\n<td style=\"text-align:center\">TR&amp;</td>\n<td style=\"text-align:center\">A&amp;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">T&amp;&amp;</td>\n<td style=\"text-align:center\">TR&amp;&amp;</td>\n<td style=\"text-align:center\">A&amp;&amp;</td>\n</tr>\n</tbody>\n</table>\n<p>将之前的例子改写：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 改写为完美转发</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">IamForwording</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;&amp;</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">IrunCodeActually</span><span class=\"token punctuation\">(</span><span class=\"token generic-function\"><span class=\"token function\">static_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>T <span class=\"token operator\">&amp;&amp;</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在 c++11 中用于完美转发的函数是 forward，它和 move 的实际实现上差别不大，move 也可以实现完美转发，但并不推荐。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">IamForwording</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;&amp;</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">IrunCodeActually</span><span class=\"token punctuation\">(</span><span class=\"token function\">forward</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"显示转换操作符\"><a class=\"anchor\" href=\"#显示转换操作符\">#</a> 显示转换操作符</h3>\n<p>explicit 作用：在 C++ 中，explicit 关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。</p>\n<p>explicit 使用注意事项:</p>\n<ul>\n<li>explicit 关键字只能用于类内部的构造函数声明上。</li>\n<li>explicit 关键字作用于单个参数的构造函数。</li>\n<li>explicit 关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换</li>\n</ul>\n<h3 id=\"列表初始化\"><a class=\"anchor\" href=\"#列表初始化\">#</a> 列表初始化</h3>\n<p>不仅能用于内置类型、标准库中的容器，只要 #include 了 &lt;initializer_list&gt; 头文件，并且声明一个以   initialize_list&lt; T &gt; 模板类为参数的构造函数，同样可以使得自定义的类使用列表初始化。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">enum</span> <span class=\"token class-name\">Gender</span> <span class=\"token punctuation\">&#123;</span>boy<span class=\"token punctuation\">,</span> girl<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">People</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">People</span><span class=\"token punctuation\">(</span>initializer_list<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> Gender<span class=\"token operator\">></span> <span class=\"token operator\">></span> l<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">auto</span> i <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">!=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            data<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    vector<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> Gender<span class=\"token operator\">></span> <span class=\"token operator\">></span> data<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>函数的参数列表也可以使用初始化列表。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;initializer_list></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Fun</span><span class=\"token punctuation\">(</span>initializer_list<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> iv<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">Func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">Func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 空列表</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span>`</pre></td></tr></table></figure><p>同理，类和结构体的成员函数也可以使用初始化参数列表，包括一些操作符的重载函数。</p>\n<p>此外，初始化列表还可以用于函数返回的情况，返回一个初始化列表，通常会导致构造一个临时变量，比如：</p>\n<p><code>vector&lt;int&gt; Func &#123; return &#123;1,3&#125;; &#125;</code></p>\n<p>使用列表初始化的优势是可以防止类型收窄（narrowing）。</p>\n<p>类型收窄一般是指一些可以使得数据变化或者精度丢失的隐式类型转换。</p>\n<p><code>const int x = 1024;</code> <br />\n <code>const int y = 10;</code></p>\n<p><code>char a = x;\t\t\t\t\t// 收窄，但可以通过编译</code> <br />\n <code>char *b = new char(1024);\t// 收窄，但可以通过编译</code></p>\n<p><code>char c = &#123;x&#125;;\t\t\t\t// 收窄，无法通过编译</code> <br />\n <code>char d = &#123;y&#125;;\t\t\t\t// 可以通过编译，char的取值范围在-128~127</code> <br />\n <code>unsigned char e &#123;-1&#125;;\t\t// 收窄，无法通过编译</code></p>\n<p><code>float f &#123;7&#125;;\t\t\t\t// 可以通过编译，这个可以转换会原类型，没有发生精度丢失，所以可以通过</code> <br />\n <code>int g &#123; 2.0 f&#125;;\t\t\t\t// 收窄，无法通过编译，2.0f是一个有精度的浮点数值，转换成整数会丢失精度</code> <br />\n <code>float *h = new float&#123;1e48&#125;; // 收窄，无法通过编译</code> <br />\n <code>float i = 1.21;\t\t\t\t// 可以通过编译</code></p>\n",
            "tags": [
                "编程语言",
                "cpp"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/08/01/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%871/",
            "url": "https://hdqjl317.github.io/2022/08/01/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%871/",
            "title": "cpp11新特性篇1",
            "date_published": "2022-08-01T05:01:42.000Z",
            "content_html": "<h3 id=\"查验机器环境\"><a class=\"anchor\" href=\"#查验机器环境\">#</a> 查验机器环境</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Standard Clib: \"</span> <span class=\"token operator\">&lt;&lt;</span> __STDC_HOSTED__ <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Standard C: \"</span> <span class=\"token operator\">&lt;&lt;</span> __STDC__ <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// cout &lt;&lt; \"C Standard version: \" &lt;&lt; __STDC_VERSION__ &lt;&lt; endl;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"ISO/IEC \"</span> <span class=\"token operator\">&lt;&lt;</span> __STDC_ISO_10646__ <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>Standard Clib<span class=\"token operator\">:</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>Standard C<span class=\"token operator\">:</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>ISO<span class=\"token operator\">/</span>IEC <span class=\"token number\">201706</span></pre></td></tr></table></figure><h3 id=\"返回函数的名字\"><a class=\"anchor\" href=\"#返回函数的名字\">#</a> 返回函数的名字</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 返回函数的名字，预定义标识符 __func__</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> <span class=\"token constant\">__func__</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">world</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> <span class=\"token constant\">__func__</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">TestStruct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">TestStruct</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token constant\">__func__</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>   <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\", \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">world</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    TestStruct ts<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    cout <span class=\"token operator\">&lt;&lt;</span> ts<span class=\"token punctuation\">.</span>name <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"20\"></td><td><pre>   <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>hello<span class=\"token punctuation\">,</span> world</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>TestStruct</pre></td></tr></table></figure><h3 id=\"变长参数宏定义\"><a class=\"anchor\" href=\"#变长参数宏定义\">#</a> 变长参数宏定义</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 变长参数宏定义 __VA_ARGS__</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">LOG</span><span class=\"token expression\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>  </span><span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token expression\"><span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> </span><span class=\"token string\">\"%s: Line %d:\\t\"</span><span class=\"token expression\"><span class=\"token punctuation\">,</span> <span class=\"token constant\">__FILE__</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">__LINE__</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </span><span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token expression\"><span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> __VA_ARGS__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </span><span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token expression\"><span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> </span><span class=\"token string\">\"\\n\"</span><span class=\"token expression\"><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </span><span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token expression\"><span class=\"token punctuation\">&#125;</span></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">LOG</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"x = %d\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>va_args<span class=\"token punctuation\">.</span>cpp<span class=\"token operator\">:</span> Line <span class=\"token number\">13</span><span class=\"token operator\">:</span>   x <span class=\"token operator\">=</span> <span class=\"token number\">3</span></pre></td></tr></table></figure><h3 id=\"静态断言与static_assert\"><a class=\"anchor\" href=\"#静态断言与static_assert\">#</a> 静态断言与 static_assert</h3>\n<ul>\n<li>断言宏 assert 只用于程序运行时</li>\n<li>#error 只在编译器预处理时有效</li>\n<li>static_assert 用于程序编译时进行断言</li>\n</ul>\n<p>static_assert 接收两个参数，一个 bool 值，一个字符串警告信息。</p>\n<p>static_assert 的断言表达式的结果必须时在编译时期就可以计算的表达式，及必须是常量表达式。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;cstring></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">U</span><span class=\"token operator\">></span> <span class=\"token keyword\">int</span> <span class=\"token function\">bit_copy</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> U <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">static_assert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"the parameters of bit_copy must have same width.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0x2468</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">double</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">bit_copy</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"noexcept修饰符与noexcept操作符\"><a class=\"anchor\" href=\"#noexcept修饰符与noexcept操作符\">#</a> noexcept 修饰符与 noexcept 操作符</h3>\n<ul>\n<li>noexcept 不会抛出异常，通过调用 std::terminate () 来终止程序的运行，则这样可以减少异常机制带来的开销（比如，不用进行栈帧的一级一级的展开），有效的阻止了异常的传播与扩散。</li>\n<li>但也可能存在一些问题，比如 noexcepet 后无法保证对象的析构函数的正常调用，无法保证栈的自动释放等等。</li>\n<li>C++11 默认将 delete 函数设置为 noexcept，即 nocept (true)，可以提高程序的安全性。</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>`<span class=\"token keyword\">void</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t<span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 可以抛出异常</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>size_t<span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 可以抛出异常</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">except_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 用于函数，默认 noexcept (true)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">except_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">(</span>常量表达式<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 用于函数</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token function\">T</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">//noexcept () 用于模板 `</span></pre></td></tr></table></figure><h3 id=\"快速初始化成员变量\"><a class=\"anchor\" href=\"#快速初始化成员变量\">#</a> 快速初始化成员变量</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">C</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">C</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">c</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Init</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\t\t\t\t<span class=\"token comment\">// 可以通过编译，以前的 C++98 不能通过编译</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    string <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// 无法通过编译</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    C <span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t\t\t\t<span class=\"token comment\">// 无法通过编译</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    Init temp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span>`</pre></td></tr></table></figure><h3 id=\"override和final\"><a class=\"anchor\" href=\"#override和final\">#</a> override 和 final</h3>\n<ul>\n<li>override：保证在派生类中声明的重载函数，与基类的虚函数有相同的签名（函数名，参数，const 属性）；</li>\n<li>final：阻止类的进一步派生 和 虚函数的进一步重写。</li>\n</ul>\n<p>加了 override，明确表示派生类的这个虚函数是要重写基类的，如果派生类与基类虚函数的签名不一致，编译器就会报错。一个虚函数被声明为 final，则派生类不能再重写它。</p>\n<h3 id=\"模板函数的默认模板参数\"><a class=\"anchor\" href=\"#模板函数的默认模板参数\">#</a> 模板函数的默认模板参数</h3>\n<p>c<ins>98 不支持函数模板的默认模板参数，c</ins>11 支持。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Deparm</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>   <span class=\"token comment\">//c++98 编译通过， c++11 编译通过</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">class</span> <span class=\"token class-name\">DefClass</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">//c++98 编译通过， c++11 编译通过</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">void</span> <span class=\"token function\">DefTempParm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>   <span class=\"token comment\">//c++98 编译不通过， c++11 编译通过 `</span></pre></td></tr></table></figure><p>对于类模板，如果定义模板类的默认模板参数，必须按照从左到右定义。而对于函数模板没有此要求。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DefClass1</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//c++11 可以通过编译</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DefClass2</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//c++11 不能通过编译</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token operator\">></span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DefClass1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//c++11 可以通过编译</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DefClass1</span><span class=\"token punctuation\">;</span>\t  <span class=\"token comment\">//c++11 不能通过编译</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">DefFunc1</span><span class=\"token punctuation\">(</span>T1 a<span class=\"token punctuation\">,</span> T2 b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//c++11 可以通过编译</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">DefFunc2</span><span class=\"token punctuation\">(</span>T a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t\t\t\t<span class=\"token comment\">//c++11 可以通过编译 `</span></pre></td></tr></table></figure>",
            "tags": [
                "编程语言",
                "cpp"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/07/01/other/hello-world/",
            "url": "https://hdqjl317.github.io/2022/07/01/other/hello-world/",
            "title": "Hello World",
            "date_published": "2022-07-01T03:01:42.000Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": [
                "杂谈",
                "杂谈"
            ]
        }
    ]
}