{
    "version": "https://jsonfeed.org/version/1",
    "title": null,
    "subtitle": "加楽的小站",
    "icon": "https://hdqjl317.github.io/images/favicon.ico",
    "description": "欢迎来到 Caleb 的个人博客!",
    "home_page_url": "https://HDqjl317.github.io",
    "items": [
        {
            "id": "https://hdqjl317.github.io/2023/06/30/computer-science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/",
            "url": "https://hdqjl317.github.io/2023/06/30/computer-science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/",
            "title": "编译原理",
            "date_published": "2023-06-30T08:50:54.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://hdqjl317.github.io/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/",
            "url": "https://hdqjl317.github.io/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/",
            "title": "vscode通过密钥连接远程服务器",
            "date_published": "2022-08-20T08:28:27.000Z",
            "content_html": "<p><strong>一，生成密钥，或者在购买服务器时选择ssh密匙登录</strong></p>\n<p>第一种：通过指令ssh-keygen生成，具体的我就不说了</p>\n<p>第二种：通过服务商生成，阿里云，腾讯云，华为云的网站有创建密钥的，比如腾讯云</p>\n<p><img data-src=\"/paperphone/image-20230204153756653.png\"></p>\n<p><strong>二，将密钥绑定到服务器，也可以在网站直接操作，修改密码为密钥就好了</strong></p>\n<p><strong>三，在vscode上安装Remote Development插件，然后将几个扩展包也安装一下</strong></p>\n<p><strong>四，点击远程资源管理器</strong></p>\n<p><img data-src=\"/paperphone/image-20230204153918156.png\"><br><strong>五，点击+号在输入框输入ssh 登录名@IP地址</strong></p>\n<p><img data-src=\"/paperphone/image-20230204153949670.png\"></p>\n<p><strong>六，输入完成后按回车会出现选择选择，选择C:User\\XXX.ssh\\config</strong></p>\n<p><img data-src=\"/paperphone/image-20230204154137681.png\"></p>\n<p>上面三条是自动生成的，Host那条是本地名称，可以修改用来区分服务器，最后一条写的是私钥的地址，地址加上“”。然后点击下图这个符号就可以连接远程服务器了。</p>\n<p><img data-src=\"/paperphone/image-20230204154455497.png\"></p>\n",
            "tags": [
                "工作技能",
                "vscode"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/08/10/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%873/",
            "url": "https://hdqjl317.github.io/2022/08/10/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%873/",
            "title": "cpp11新特性篇3",
            "date_published": "2022-08-10T08:24:51.000Z",
            "content_html": "<h2 id=\"auto-amp-amp-decltype\"><a href=\"#auto-amp-amp-decltype\" class=\"headerlink\" title=\"auto&amp;&amp;decltype\"></a>auto&amp;&amp;decltype</h2><p>静态类型：类型检查在编译阶段</p>\n<p>动态类型：类型检查在运行阶段</p>\n<p>auto声明变量的类型必须由编译器在编译时期推导而得，其优势是在拥有初始化表达式的复杂类型变量声明时简化代码。</p>\n<p>decltype以一个普通的表达式为参数，返回该表达式的类型。</p>\n<p>用decltype(e)来获取类型时，编译器将依序判断以下四规则：</p>\n<ul>\n<li>如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么decltype(e)就是e所命名的实体的类型。如果e是一个被重载的函数，则会导致编译时错误。</li>\n<li>否则，假设e的类型是T，如果e是一个将亡值(xvalue)，那么decltype(e)为T&amp;&amp;。</li>\n<li>否则，假设e的类型是T，如果e是一个左值，则decltype(e)为T&amp;。</li>\n<li>否则，假设e的类型是T，则decltype(e)为T。</li>\n</ul>\n<h2 id=\"追踪返回类型\"><a href=\"#追踪返回类型\" class=\"headerlink\" title=\"追踪返回类型\"></a>追踪返回类型</h2><p>对返回类型进行类型推导：</p>\n<pre><code class=\"cpp\">`template&lt;typename T1, typename T2&gt;\t\t\t//直观的方案\ndecltype(t1 + t2) Sum(T1 &amp; t1, T2 &amp; t2) &#123;\n    return t1 + t2;\n&#125;\n\ntemplate&lt;typename T1, typename T2&gt;\t\t\t//追踪返回类型的方案\nauto Sum(T1 &amp; t1, T2 &amp; t2) -&gt; decltype(t1 + t2) &#123;\n    return t1 + t2;\n&#125;\n\nint func(char *a, int b);\nauto func(char *a, int b) -&gt; int ;`\n</code></pre>\n<p>把原本的函数返回值移到参数声明之后，而原本的返回值的位置由auto关键字占据。auto占位符和return_type是构成追踪返回类型函数的两个基本元素。</p>\n<p>追踪返回类型另一个优势是简化函数的定义，提高代码可读性。</p>\n<pre><code class=\"cpp\">`#include&lt;type_traits&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nint (*(*pf()) ()) () &#123;\n    return nullptr;\n&#125;\n\n//auto (*)() -&gt; int(*) () 一个返回函数指针的函数（假设为a函数）\n//auto pf1() -&gt; auto(*)() -&gt; int(*)() 一个返回a函数的指针的函数\nauto pf1() -&gt; auto (*)() -&gt; int(*) &#123;\t//和上面等价\n    return nullptr;\n&#125;\n\nint main() &#123;\n    cout &lt;&lt; is_same&lt;decltype(pf), decltype(pf1)&gt;::value &lt;&lt; endl;\n&#125;\n</code></pre>\n<p><code>追踪返回类</code>型也常用于转发函数中：</p>\n<pre><code class=\"cpp\">`#include &lt;iostream&gt;\nusing namespace std;\n\ndouble foo(int a) &#123;\n    return (double)a + 0.1;\n&#125;\n\nint foo(double) &#123;\n    return (int)b;\n&#125;\n\ntemplate &lt;class T&gt;\nauto Forward(T t) -&gt; decltype(foo(t)) &#123;\n    return foo(t);\n&#125;\n\nint main() &#123;\n    cout &lt;&lt; Forward(2) &lt;&lt; endl;  //2.1\n    cout &lt;&lt; Forward(0.5) &lt;&lt; endl; //0\n&#125;`\n</code></pre>\n",
            "tags": [
                "编程语言",
                "cpp"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/08/04/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%872/",
            "url": "https://hdqjl317.github.io/2022/08/04/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%872/",
            "title": "cpp11新特性篇2",
            "date_published": "2022-08-04T05:01:42.000Z",
            "content_html": "<h3 id=\"继承构造函数\"><a href=\"#继承构造函数\" class=\"headerlink\" title=\"继承构造函数\"></a>继承构造函数</h3><p>如果基类有多个构造函数，使用继承构造函数可以让派生类免于重写各个基类的构造函数。</p>\n<pre><code class=\"cpp\">struct A &#123;\n    A(int i) &#123;&#125;\n    A(double d, int i) &#123;&#125;\n    A(float f, int i, const char *c) &#123;&#125;\n    // ...\n&#125;;\n\nstruct B : A &#123;\n    using A : A;\t// 继承构造函数\n    // ...\n&#125;\n</code></pre>\n<p>c++11标准继承构造函数和默认构造函数、析构函数、拷贝构造一样，都是隐式声明的。不过继承构造函数只会初始化基类中的成员变量，对于派生类的成员变量无法初始化，这时候要结合初始化表达式为派生类的成员变量设定默认值。但是，<strong>继承构造函数不会继承基类的成员变量的默认值</strong>。</p>\n<p>当派生类的继承基类时，派生类的继承构造函数可能不只有一个结果：</p>\n<pre><code class=\"cpp\">struct A &#123;\n    A (int a = 3, double 2.4) &#123;&#125;\n&#125;\n\nstruct B : A &#123;\n    using A::A;\n&#125;\n\n可能生成的继承构造函数如下：\nA(int=3, double=2.4)\nA(int=3)\nA(const A&amp;)\nA()\n对应的B的构造函数将有：\nB(int=3, double=2.4)\nB(int=3)\nB(const B&amp;)\nB()\n</code></pre>\n<p>其他的规则：</p>\n<ul>\n<li>如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，则不能在派生类中声明继承构造函数。</li>\n<li>如果派生类一旦使用了继承构造函数，编译器则不会为派生类构造自己的默认构造函数。</li>\n</ul>\n<pre><code class=\"cpp\">struct A &#123;A(int) &#123;&#125;&#125;;\nstruct B : A &#123;using A::A;&#125;;\n\nB b;  //B没有默认构造函数，不能通过编译\n</code></pre>\n<h3 id=\"委派构造函数\"><a href=\"#委派构造函数\" class=\"headerlink\" title=\"委派构造函数\"></a>委派构造函数</h3><p>所谓委托构造就是让类中的某个构造函数去委托另一个构造函数执行构造操作的机制。一个委托构造函数使用<strong>它所属类的其他构造函数</strong>执行自己的初始化过程。调用者叫委派构造函数，被调用者叫目标构造函数。</p>\n<h3 id=\"右值引用：移动语义和完美转发\"><a href=\"#右值引用：移动语义和完美转发\" class=\"headerlink\" title=\"右值引用：移动语义和完美转发\"></a>右值引用：移动语义和完美转发</h3><p>(1) 移动构造函数：移交所有权，析构自身。</p>\n<ul>\n<li><p>左值：可以取地址的，有名字的。</p>\n</li>\n<li><p>右值：不能取地址，无名字的。又可细分为纯右值和将亡值。</p>\n<ul>\n<li>纯右值：辨识临时变量和一些不跟对象关联的值</li>\n<li>将亡值：C++11新增的跟右值引用相关的表达式，如右值引用T &amp;&amp;的函数返回值、std::move的返回值、或者转换为T &amp;&amp;的类型转换函数的返回值</li>\n</ul>\n</li>\n</ul>\n<p>为区别C++98的引用类型，之前的引用叫做左值引用，左值引用和右值引用都是引用类型，声明时都必须立即进行初始化。右值引用只能绑定右值，不能绑定任何左值。左值引用可以接受非常量左值、常量左值、右值对其进行初始化。</p>\n<p><code>T &amp;&amp; a = ReturnRvalue(); \t\t// √ 绑定右值</code></p>\n<p><code>int c;</code><br><code>int &amp;&amp; d = c;\t\t\t\t\t// X 绑定左值</code></p>\n<p>使用移动语义的前提下需要给类添加一个以右值引用为参数的移动构造函数。</p>\n<p>而通常情况下，在为类声明了一个移动构造函数后，可以声明一个常量左值为参数的拷贝构造函数，以保证在移动构造不成时，还可以进行拷贝构造（偶尔也有特殊用途的反例）。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">引用类型\\可以引用的值类型</th>\n<th align=\"center\">非常量左值</th>\n<th align=\"center\">常量左值</th>\n<th align=\"center\">非常量右值</th>\n<th align=\"center\">常量右值</th>\n<th align=\"center\">注记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">非常量左值引用</td>\n<td align=\"center\">Y</td>\n<td align=\"center\">N</td>\n<td align=\"center\">N</td>\n<td align=\"center\">N</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">常量左值引用</td>\n<td align=\"center\">Y</td>\n<td align=\"center\">Y</td>\n<td align=\"center\">Y</td>\n<td align=\"center\">Y</td>\n<td align=\"center\">全能类型、可用于拷贝语义</td>\n</tr>\n<tr>\n<td align=\"center\">非常量右值引用</td>\n<td align=\"center\">N</td>\n<td align=\"center\">N</td>\n<td align=\"center\">Y</td>\n<td align=\"center\">N</td>\n<td align=\"center\">用于移动语义、完美转发</td>\n</tr>\n<tr>\n<td align=\"center\">常量右值引用</td>\n<td align=\"center\">N</td>\n<td align=\"center\">N</td>\n<td align=\"center\">Y</td>\n<td align=\"center\">Y</td>\n<td align=\"center\">暂无用途</td>\n</tr>\n</tbody></table>\n<p>如果不知道一个类型是否属于引用类型，可以用标准库<type_traits>头文件中的3个模板类进行判断：is_rvalue_reference、is_lvalue_reference、is_reference。如判断string &amp;&amp;的类型：</p>\n<p><code>cout &lt;&lt; is_rvalue_reference&lt;string &amp;&amp;&gt;::value;</code></p>\n<p>(2) std::move: 强制转化为右值</p>\n<p>std::move基本等同于一个类型转换：</p>\n<p><code>static_cast&lt;T&amp;&amp;&gt;(lvalue);</code></p>\n<p><strong>但注意：被std::move转化的左值，其生命期并没有随着左右值的转化而改变。</strong></p>\n<pre><code class=\"cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nclass Moveable &#123;\npublic:\n    Moveable() : i(new int(3)) &#123;&#125;\n    ~Moveable() &#123; delete i; &#125;\n    Moveable(const Moveable &amp;m) : i(new int(*m.i)) &#123;&#125;\n    Moveable(Moveable &amp;&amp; m) : i(m.i) &#123;\n        m.i = nullptr;\n    &#125;\n    int *i;\n&#125;;\n\nint main() &#123;\n    Moveable a;\n    Moveable c(move(a));   // 会调用移动构造函数\n    cout &lt;&lt; *a.i &lt;&lt; endl;  // 运行时错误\n    return 0;\n&#125;\n\n/*\nmove(a)后，a.i就被移动构造函数设置为指针空值，所以后来使用会报错\n*/\n</code></pre>\n<p>如上例，在大多数时候，我们需要将其转化为右值引用的还是一个确实生命期即将结束的对象。</p>\n<p>声明了移动构造函数、移动赋值函数、拷贝赋值函数和析构函数中的一个或多个，编译器不会再为程序员生成默认的拷贝构造函数。所以拷贝构造&#x2F;赋值和移动构造&#x2F;赋值函数必须同时提供，或者同时不提供，这才能保证类同时具备拷贝语义和移动语义。</p>\n<p>可以通过可以用标准库<type_traits>头文件中的is_move_constructible、is_trivially_move_constructible、is_nothrow_move_constructible判断一个类型是否可以移动：</p>\n<p><code>cout &lt;&lt; is_move_constructible&lt;UnknownType&gt;::value;</code></p>\n<p>(3) 完美转发（perfect forwarding）</p>\n<p>完美转发，是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。</p>\n<p><code>template &lt;typename T&gt;</code><br><code>void IamForwording(T t) &#123; IrunCodeActually(t); &#125;</code></p>\n<p>对于目标函数IrunCodeActually而言，它总是希望转发函数将参数按照传入lamForwarding时的类型传递(即传入lamForwording的是左值对象，IrunCodeActually就能获得左值对象，传入lamForwording的是右值对象，lrunCodeActually就能获得右值对象)，而不产生额外的开销，就好像转发者不存在一样。</p>\n<p>C++11通过使用“引用折叠”（reference collapsing），结合新的模板推导规则实现完美转发。</p>\n<p>引用折叠：即将复杂的未知表达式折叠为已知的简单表达式。</p>\n<p><code>typedef const int T;</code><br><code>typedef T&amp; TR;</code><br><code>TR&amp; v = 1;\t\t//该声明在C++98中会导致编译报错,而在c++11中会导致引用折叠</code></p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<strong>表  c++11中的引用折叠</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">TR的类型定义</th>\n<th align=\"center\">声明v的类型</th>\n<th align=\"center\">v的实际类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">T&amp;</td>\n<td align=\"center\">TR</td>\n<td align=\"center\">A&amp;</td>\n</tr>\n<tr>\n<td align=\"center\">T&amp;</td>\n<td align=\"center\">TR&amp;</td>\n<td align=\"center\">A&amp;</td>\n</tr>\n<tr>\n<td align=\"center\">T&amp;</td>\n<td align=\"center\">TR&amp;&amp;</td>\n<td align=\"center\">A&amp;</td>\n</tr>\n<tr>\n<td align=\"center\">T&amp;&amp;</td>\n<td align=\"center\">TR</td>\n<td align=\"center\">A&amp;&amp;</td>\n</tr>\n<tr>\n<td align=\"center\">T&amp;&amp;</td>\n<td align=\"center\">TR&amp;</td>\n<td align=\"center\">A&amp;</td>\n</tr>\n<tr>\n<td align=\"center\">T&amp;&amp;</td>\n<td align=\"center\">TR&amp;&amp;</td>\n<td align=\"center\">A&amp;&amp;</td>\n</tr>\n</tbody></table>\n<p>将之前的例子改写：</p>\n<pre><code class=\"cpp\">//改写为完美转发\ntemplate &lt;typename T&gt;\nvoid IamForwording(T &amp;&amp; t) &#123;\n    IrunCodeActually(static_cast&lt;T &amp;&amp;&gt;(t));\n&#125;\n</code></pre>\n<p>在c++11中用于完美转发的函数是forward，它和move的实际实现上差别不大，move也可以实现完美转发，但并不推荐。</p>\n<pre><code class=\"cpp\">template &lt;typename T&gt;\nvoid IamForwording(T &amp;&amp; t) &#123;\n    IrunCodeActually(forward(t));\n&#125;\n</code></pre>\n<h3 id=\"显示转换操作符\"><a href=\"#显示转换操作符\" class=\"headerlink\" title=\"显示转换操作符\"></a>显示转换操作符</h3><p>explicit作用:在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。</p>\n<p>explicit使用注意事项:</p>\n<ul>\n<li>explicit 关键字只能用于类内部的构造函数声明上。</li>\n<li>explicit 关键字作用于单个参数的构造函数。</li>\n<li>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换</li>\n</ul>\n<h3 id=\"列表初始化\"><a href=\"#列表初始化\" class=\"headerlink\" title=\"列表初始化\"></a>列表初始化</h3><p>不仅能用于内置类型、标准库中的容器，只要#include了<initializer_list>头文件，并且声明一个以   initialize_list&lt; T &gt;模板类为参数的构造函数，同样可以使得自定义的类使用列表初始化。</p>\n<pre><code class=\"cpp\">#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nenum Gender &#123;boy, girl&#125;;\nclass People &#123;\npublic:\n    People(initializer_list&lt;pair&lt;string, Gender&gt; &gt; l) &#123;\n        auto i = l.begin();\n        for ( ; != l.end(); ++i)\n            data.push_back(*i);\n    &#125;\nprivate:\n    vector&lt;pair&lt;string, Gender&gt; &gt; data;\n&#125;\n</code></pre>\n<p>函数的参数列表也可以使用初始化列表。</p>\n<pre><code class=\"cpp\">#include &lt;initializer_list&gt;\nusing namespace std;\n\nvoid Fun(initializer_list&lt;int&gt; iv) &#123;&#125;\n\nint main() &#123;\n    Func(&#123;1, 2&#125;);\n    Func(&#123;&#125;);   //空列表\n    return 0;\n&#125;`\n</code></pre>\n<p>同理，类和结构体的成员函数也可以使用初始化参数列表，包括一些操作符的重载函数。</p>\n<p>此外，初始化列表还可以用于函数返回的情况，返回一个初始化列表，通常会导致构造一个临时变量，比如：</p>\n<p><code>vector&lt;int&gt; Func &#123; return &#123;1,3&#125;; &#125;</code></p>\n<p>使用列表初始化的优势是可以防止类型收窄（narrowing）。</p>\n<p>类型收窄一般是指一些可以使得数据变化或者精度丢失的隐式类型转换。</p>\n<p><code>const int x = 1024;</code><br><code>const int y = 10;</code></p>\n<p><code>char a = x;\t\t\t\t\t// 收窄，但可以通过编译</code><br><code>char *b = new char(1024);\t// 收窄，但可以通过编译</code></p>\n<p><code>char c = &#123;x&#125;;\t\t\t\t// 收窄，无法通过编译</code><br><code>char d = &#123;y&#125;;\t\t\t\t// 可以通过编译，char的取值范围在-128~127</code><br><code>unsigned char e &#123;-1&#125;;\t\t// 收窄，无法通过编译</code></p>\n<p><code>float f &#123;7&#125;;\t\t\t\t// 可以通过编译，这个可以转换会原类型，没有发生精度丢失，所以可以通过</code><br><code>int g &#123; 2.0 f&#125;;\t\t\t\t// 收窄，无法通过编译，2.0f是一个有精度的浮点数值，转换成整数会丢失精度</code><br><code>float *h = new float&#123;1e48&#125;; // 收窄，无法通过编译</code><br><code>float i = 1.21;\t\t\t\t// 可以通过编译</code></p>\n",
            "tags": [
                "编程语言",
                "cpp"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/08/01/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%871/",
            "url": "https://hdqjl317.github.io/2022/08/01/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%871/",
            "title": "cpp11新特性篇1",
            "date_published": "2022-08-01T05:01:42.000Z",
            "content_html": "<h3 id=\"查验机器环境\"><a href=\"#查验机器环境\" class=\"headerlink\" title=\"查验机器环境\"></a>查验机器环境</h3><pre><code class=\"cpp\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() &#123;\n    cout &lt;&lt; &quot;Standard Clib: &quot; &lt;&lt; __STDC_HOSTED__ &lt;&lt; endl;\n    cout &lt;&lt; &quot;Standard C: &quot; &lt;&lt; __STDC__ &lt;&lt; endl;\n    // cout &lt;&lt; &quot;C Standard version: &quot; &lt;&lt; __STDC_VERSION__ &lt;&lt; endl;\n    cout &lt;&lt; &quot;ISO/IEC &quot; &lt;&lt; __STDC_ISO_10646__ &lt;&lt; endl;\n    return 0;\n&#125;\n\nStandard Clib: 1\nStandard C: 1\nISO/IEC 201706 \n</code></pre>\n<h3 id=\"返回函数的名字\"><a href=\"#返回函数的名字\" class=\"headerlink\" title=\"返回函数的名字\"></a>返回函数的名字</h3><pre><code class=\"cpp\">// 返回函数的名字，预定义标识符 __func__\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nconst char *hello() &#123; return __func__; &#125;\nconst char *world() &#123; return __func__; &#125;\n\nstruct TestStruct &#123;\n    TestStruct() : name(__func__) &#123;&#125;\n   const char *name;\n&#125;;\n\nint main() &#123;\n    cout &lt;&lt; hello() &lt;&lt; &quot;, &quot; &lt;&lt; world() &lt;&lt; endl;\n    TestStruct ts;\n    cout &lt;&lt; ts.name &lt;&lt; endl; \n   return 0;\n&#125;\n\nhello, world\nTestStruct\n</code></pre>\n<h3 id=\"变长参数宏定义\"><a href=\"#变长参数宏定义\" class=\"headerlink\" title=\"变长参数宏定义\"></a>变长参数宏定义</h3><pre><code class=\"cpp\">// 变长参数宏定义 __VA_ARGS__\n\n#include &lt;stdio.h&gt;\n\n#define LOG(...) &#123;  \\\n    fprintf(stderr, &quot;%s: Line %d:\\t&quot;, __FILE__, __LINE__); \\\n    fprintf(stderr, __VA_ARGS__); \\\n    fprintf(stderr, &quot;\\n&quot;); \\\n&#125;\n\nint main() &#123;\n    int x = 3;\n    LOG(&quot;x = %d&quot;, x);\n    return 0;\n&#125;\n\n\nva_args.cpp: Line 13:   x = 3\n</code></pre>\n<h3 id=\"静态断言与static-assert\"><a href=\"#静态断言与static-assert\" class=\"headerlink\" title=\"静态断言与static_assert\"></a>静态断言与static_assert</h3><ul>\n<li>断言宏assert只用于程序运行时</li>\n<li>#error 只在编译器预处理时有效</li>\n<li>static_assert用于程序编译时进行断言</li>\n</ul>\n<p>static_assert接收两个参数，一个bool值，一个字符串警告信息。</p>\n<p>static_assert的断言表达式的结果必须时在编译时期就可以计算的表达式，及必须是常量表达式。</p>\n<pre><code class=\"cpp\">#include &lt;cstring&gt;\n\nusing namespace std;\n\ntemplate &lt;typename T, typename U&gt; int bit_copy(T &amp;a, U &amp;b) &#123;\n    static_assert(sizeof(b) == sizeof(a), &quot;the parameters of bit_copy must have same width.&quot;);\n    memcpy(&amp;a, &amp;b, sizeof(b));\n&#125;\n\nint main() &#123;\n    int a = 0x2468;\n    double b;\n    bit_copy(a, b);\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"noexcept修饰符与noexcept操作符\"><a href=\"#noexcept修饰符与noexcept操作符\" class=\"headerlink\" title=\"noexcept修饰符与noexcept操作符\"></a>noexcept修饰符与noexcept操作符</h3><ul>\n<li>noexcept不会抛出异常，通过调用std::terminate()来终止程序的运行，则这样可以减少异常机制带来的开销（比如，不用进行栈帧的一级一级的展开），有效的阻止了异常的传播与扩散。</li>\n<li>但也可能存在一些问题，比如noexcepet后无法保证对象的析构函数的正常调用，无法保证栈的自动释放等等。</li>\n<li>C++11默认将delete函数设置为noexcept，即nocept(true)，可以提高程序的安全性。</li>\n</ul>\n<pre><code class=\"cpp\">`void operator delete(void *) noexcept;\nvoid operator delete[](void *) noexcept;\nvoid *operator new(std::size_t) noexcept(false);  //可以抛出异常\nvoid *operator new[](std::size_t) noexcept(false); //可以抛出异常\n\nvoid except_func() noexcept;   //用于函数，默认noexcept(true)\nvoid except_func() noexcept(常量表达式)  //用于函数\n\ntemplate &lt;class T&gt;\nvoid fun() noexcept(noexcept(T(()))) &#123;&#125; //noexcept()用于模板`\n</code></pre>\n<h3 id=\"快速初始化成员变量\"><a href=\"#快速初始化成员变量\" class=\"headerlink\" title=\"快速初始化成员变量\"></a>快速初始化成员变量</h3><pre><code class=\"cpp\">#include &lt;string&gt;\n\nusing namespace std;\n\nstruct C &#123;\n    C(int i) : c(i) &#123;&#125;;\n    int c;\n&#125;;\n\nstruct Init &#123;\n    int a = 1;\t\t\t\t//可以通过编译，以前的C++98不能通过编译\n    string b(&quot;hello&quot;);\t\t//无法通过编译\n    C c(1);\t\t\t\t\t//无法通过编译\n&#125;;\n\nint main() &#123;\n    Init temp;\n    return 0;\n&#125;`\n</code></pre>\n<h3 id=\"override和final\"><a href=\"#override和final\" class=\"headerlink\" title=\"override和final\"></a>override和final</h3><ul>\n<li>override：保证在派生类中声明的重载函数，与基类的虚函数有相同的签名（函数名，参数，const属性）；</li>\n<li>final：阻止类的进一步派生 和 虚函数的进一步重写。</li>\n</ul>\n<p>加了override，明确表示派生类的这个虚函数是要重写基类的，如果派生类与基类虚函数的签名不一致，编译器就会报错。一个虚函数被声明为final，则派生类不能再重写它。</p>\n<h3 id=\"模板函数的默认模板参数\"><a href=\"#模板函数的默认模板参数\" class=\"headerlink\" title=\"模板函数的默认模板参数\"></a>模板函数的默认模板参数</h3><p>c++98不支持函数模板的默认模板参数，c++11支持。</p>\n<pre><code class=\"cpp\">void Deparm(int m = 3) &#123;&#125;   //c++98编译通过， c++11编译通过\ntemplate &lt;typename T = int &gt;\n    class DefClass &#123;&#125;;\t\t//c++98编译通过， c++11编译通过\ntemplate &lt;typename T = int &gt;\n    void DefTempParm() &#123;&#125;   //c++98编译不通过， c++11编译通过`\n</code></pre>\n<p>对于类模板，如果定义模板类的默认模板参数，必须按照从左到右定义。而对于函数模板没有此要求。</p>\n<pre><code class=\"cpp\">template&lt;typename T1, typename T2 = int&gt; class DefClass1;\t//c++11可以通过编译\ntemplate&lt;typename T1 = int, typename T2&gt; class DefClass2;\t//c++11不能通过编译\n\ntemplate&lt;typename T, int i = 0&gt; class DefClass1;  //c++11可以通过编译\ntemplate&lt;int i= 0, typename T&gt; class DefClass1;\t  //c++11不能通过编译\n\ntemplate&lt;typename T1 = int, typename T2&gt; void DefFunc1(T1 a, T2 b);\t//c++11可以通过编译\ntemplate&lt;int i= 0, typename T&gt; void DefFunc2(T a);\t\t\t\t\t//c++11可以通过编译`\n</code></pre>\n",
            "tags": [
                "编程语言",
                "cpp"
            ]
        },
        {
            "id": "https://hdqjl317.github.io/2022/07/01/other/hello-world/",
            "url": "https://hdqjl317.github.io/2022/07/01/other/hello-world/",
            "title": "Hello World",
            "date_published": "2022-07-01T03:01:42.000Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": [
                "杂谈",
                "其他"
            ]
        }
    ]
}