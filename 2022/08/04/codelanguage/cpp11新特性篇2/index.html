<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://hdqjl317.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://hdqjl317.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://hdqjl317.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="cpp"><link rel="canonical" href="https://hdqjl317.github.io/2022/08/04/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%872/"><title>cpp11新特性篇2 - 编程语言 | Caleb = = 加楽的小站</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">cpp11新特性篇2</h1><div class="meta"><span class="item" title="创建时间：2022-08-04 13:01:42"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-08-04T13:01:42+08:00">2022-08-04</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>4.8k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>4 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Caleb</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/assets/cpp11.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/codelanguage/" itemprop="item" rel="index" title="分类于 编程语言"><span itemprop="name">编程语言</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hdqjl317.github.io/2022/08/04/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%872/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Caleb"><meta itemprop="description" content="加楽的小站, 欢迎来到 Caleb 的个人博客!"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h3 id="继承构造函数"><a class="anchor" href="#继承构造函数">#</a> 继承构造函数</h3><p>如果基类有多个构造函数，使用继承构造函数可以让派生类免于重写各个基类的构造函数。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">float</span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">using</span> A <span class="token operator">:</span> A<span class="token punctuation">;</span>	<span class="token comment">// 继承构造函数</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>c++11 标准继承构造函数和默认构造函数、析构函数、拷贝构造一样，都是隐式声明的。不过继承构造函数只会初始化基类中的成员变量，对于派生类的成员变量无法初始化，这时候要结合初始化表达式为派生类的成员变量设定默认值。但是，<strong>继承构造函数不会继承基类的成员变量的默认值</strong>。</p><p>当派生类的继承基类时，派生类的继承构造函数可能不只有一个结果：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token function">A</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token number">2.4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">using</span> A<span class="token double-colon punctuation">::</span>A<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>可能生成的继承构造函数如下：</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">=</span><span class="token number">2.4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>对应的B的构造函数将有：</pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">=</span><span class="token number">2.4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>其他的规则：</p><ul><li>如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，则不能在派生类中声明继承构造函数。</li><li>如果派生类一旦使用了继承构造函数，编译器则不会为派生类构造自己的默认构造函数。</li></ul><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span><span class="token keyword">using</span> A<span class="token double-colon punctuation">::</span>A<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>B b<span class="token punctuation">;</span>  <span class="token comment">//B 没有默认构造函数，不能通过编译</span></pre></td></tr></table></figure><h3 id="委派构造函数"><a class="anchor" href="#委派构造函数">#</a> 委派构造函数</h3><p>所谓委托构造就是让类中的某个构造函数去委托另一个构造函数执行构造操作的机制。一个委托构造函数使用<strong>它所属类的其他构造函数</strong>执行自己的初始化过程。调用者叫委派构造函数，被调用者叫目标构造函数。</p><h3 id="右值引用移动语义和完美转发"><a class="anchor" href="#右值引用移动语义和完美转发">#</a> 右值引用：移动语义和完美转发</h3><p>(1) 移动构造函数：移交所有权，析构自身。</p><ul><li><p>左值：可以取地址的，有名字的。</p></li><li><p>右值：不能取地址，无名字的。又可细分为纯右值和将亡值。</p><ul><li>纯右值：辨识临时变量和一些不跟对象关联的值</li><li>将亡值：C++11 新增的跟右值引用相关的表达式，如右值引用 T &amp;&amp; 的函数返回值、std::move 的返回值、或者转换为 T &amp;&amp; 的类型转换函数的返回值</li></ul></li></ul><p>为区别 C++98 的引用类型，之前的引用叫做左值引用，左值引用和右值引用都是引用类型，声明时都必须立即进行初始化。右值引用只能绑定右值，不能绑定任何左值。左值引用可以接受非常量左值、常量左值、右值对其进行初始化。</p><p><code>T &amp;&amp; a = ReturnRvalue(); // √ 绑定右值</code></p><p><code>int c;</code><br><code>int &amp;&amp; d = c; // X 绑定左值</code></p><p>使用移动语义的前提下需要给类添加一个以右值引用为参数的移动构造函数。</p><p>而通常情况下，在为类声明了一个移动构造函数后，可以声明一个常量左值为参数的拷贝构造函数，以保证在移动构造不成时，还可以进行拷贝构造（偶尔也有特殊用途的反例）。</p><table><thead><tr><th style="text-align:center">引用类型 \ 可以引用的值类型</th><th style="text-align:center">非常量左值</th><th style="text-align:center">常量左值</th><th style="text-align:center">非常量右值</th><th style="text-align:center">常量右值</th><th style="text-align:center">注记</th></tr></thead><tbody><tr><td style="text-align:center">非常量左值引用</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">常量左值引用</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">全能类型、可用于拷贝语义</td></tr><tr><td style="text-align:center">非常量右值引用</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">用于移动语义、完美转发</td></tr><tr><td style="text-align:center">常量右值引用</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">暂无用途</td></tr></tbody></table><p>如果不知道一个类型是否属于引用类型，可以用标准库 &lt;type_traits&gt; 头文件中的 3 个模板类进行判断：is_rvalue_reference、is_lvalue_reference、is_reference。如判断 string &amp;&amp; 的类型：</p><p><code>cout &lt;&lt; is_rvalue_reference&lt;string &amp;&amp;&gt;::value;</code></p><p>(2) std::move: 强制转化为右值</p><p>std::move 基本等同于一个类型转换：</p><p><code>static_cast&lt;T&amp;&amp;&gt;(lvalue);</code></p><p><strong>但注意：被 std::move 转化的左值，其生命期并没有随着左右值的转化而改变。</strong></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Moveable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token function">Moveable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token operator">~</span><span class="token function">Moveable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">delete</span> i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">Moveable</span><span class="token punctuation">(</span><span class="token keyword">const</span> Moveable <span class="token operator">&amp;</span>m<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>m<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">Moveable</span><span class="token punctuation">(</span>Moveable <span class="token operator">&amp;&amp;</span> m<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">i</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        m<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">int</span> <span class="token operator">*</span>i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    Moveable a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    Moveable <span class="token function">c</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 会调用移动构造函数</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>a<span class="token punctuation">.</span>i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 运行时错误</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="23"></td><td><pre>move (a) 后，a.i 就被移动构造函数设置为指针空值，所以后来使用会报错</pre></td></tr><tr><td data-num="24"></td><td><pre>*/</pre></td></tr></table></figure><p>如上例，在大多数时候，我们需要将其转化为右值引用的还是一个确实生命期即将结束的对象。</p><p>声明了移动构造函数、移动赋值函数、拷贝赋值函数和析构函数中的一个或多个，编译器不会再为程序员生成默认的拷贝构造函数。所以拷贝构造 / 赋值和移动构造 / 赋值函数必须同时提供，或者同时不提供，这才能保证类同时具备拷贝语义和移动语义。</p><p>可以通过可以用标准库 &lt;type_traits&gt; 头文件中的 is_move_constructible、is_trivially_move_constructible、is_nothrow_move_constructible 判断一个类型是否可以移动：</p><p><code>cout &lt;&lt; is_move_constructible&lt;UnknownType&gt;::value;</code></p><p>(3) 完美转发（perfect forwarding）</p><p>完美转发，是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。</p><p><code>template &lt;typename T&gt;</code><br><code>void IamForwording(T t) &#123; IrunCodeActually(t); &#125;</code></p><p>对于目标函数 IrunCodeActually 而言，它总是希望转发函数将参数按照传入 lamForwarding 时的类型传递 (即传入 lamForwording 的是左值对象，IrunCodeActually 就能获得左值对象，传入 lamForwording 的是右值对象，lrunCodeActually 就能获得右值对象)，而不产生额外的开销，就好像转发者不存在一样。</p><p>C++11 通过使用 “引用折叠”（reference collapsing），结合新的模板推导规则实现完美转发。</p><p>引用折叠：即将复杂的未知表达式折叠为已知的简单表达式。</p><p><code>typedef const int T;</code><br><code>typedef T&amp; TR;</code><br><code>TR&amp; v = 1; //该声明在C++98中会导致编译报错,而在c++11中会导致引用折叠</code></p><p>​ <strong>表 c++11 中的引用折叠</strong></p><table><thead><tr><th style="text-align:center">TR 的类型定义</th><th style="text-align:center">声明 v 的类型</th><th style="text-align:center">v 的实际类型</th></tr></thead><tbody><tr><td style="text-align:center">T&amp;</td><td style="text-align:center">TR</td><td style="text-align:center">A&amp;</td></tr><tr><td style="text-align:center">T&amp;</td><td style="text-align:center">TR&amp;</td><td style="text-align:center">A&amp;</td></tr><tr><td style="text-align:center">T&amp;</td><td style="text-align:center">TR&amp;&amp;</td><td style="text-align:center">A&amp;</td></tr><tr><td style="text-align:center">T&amp;&amp;</td><td style="text-align:center">TR</td><td style="text-align:center">A&amp;&amp;</td></tr><tr><td style="text-align:center">T&amp;&amp;</td><td style="text-align:center">TR&amp;</td><td style="text-align:center">A&amp;</td></tr><tr><td style="text-align:center">T&amp;&amp;</td><td style="text-align:center">TR&amp;&amp;</td><td style="text-align:center">A&amp;&amp;</td></tr></tbody></table><p>将之前的例子改写：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 改写为完美转发</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">IamForwording</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">IrunCodeActually</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T <span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在 c++11 中用于完美转发的函数是 forward，它和 move 的实际实现上差别不大，move 也可以实现完美转发，但并不推荐。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">IamForwording</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">IrunCodeActually</span><span class="token punctuation">(</span><span class="token function">forward</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="显示转换操作符"><a class="anchor" href="#显示转换操作符">#</a> 显示转换操作符</h3><p>explicit 作用：在 C++ 中，explicit 关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。</p><p>explicit 使用注意事项:</p><ul><li>explicit 关键字只能用于类内部的构造函数声明上。</li><li>explicit 关键字作用于单个参数的构造函数。</li><li>explicit 关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换</li></ul><h3 id="列表初始化"><a class="anchor" href="#列表初始化">#</a> 列表初始化</h3><p>不仅能用于内置类型、标准库中的容器，只要 #include 了 &lt;initializer_list&gt; 头文件，并且声明一个以 initialize_list&lt; T &gt; 模板类为参数的构造函数，同样可以使得自定义的类使用列表初始化。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">Gender</span> <span class="token punctuation">&#123;</span>boy<span class="token punctuation">,</span> girl<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">People</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> Gender<span class="token operator">></span> <span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">auto</span> i <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token operator">!=</span> l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            data<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> Gender<span class="token operator">></span> <span class="token operator">></span> data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>函数的参数列表也可以使用初始化列表。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;initializer_list></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> iv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 空列表</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span>`</pre></td></tr></table></figure><p>同理，类和结构体的成员函数也可以使用初始化参数列表，包括一些操作符的重载函数。</p><p>此外，初始化列表还可以用于函数返回的情况，返回一个初始化列表，通常会导致构造一个临时变量，比如：</p><p><code>vector&lt;int&gt; Func &#123; return &#123;1,3&#125;; &#125;</code></p><p>使用列表初始化的优势是可以防止类型收窄（narrowing）。</p><p>类型收窄一般是指一些可以使得数据变化或者精度丢失的隐式类型转换。</p><p><code>const int x = 1024;</code><br><code>const int y = 10;</code></p><p><code>char a = x; // 收窄，但可以通过编译</code><br><code>char *b = new char(1024);	// 收窄，但可以通过编译</code></p><p><code>char c = &#123;x&#125;; // 收窄，无法通过编译</code><br><code>char d = &#123;y&#125;; // 可以通过编译，char的取值范围在-128~127</code><br><code>unsigned char e &#123;-1&#125;; // 收窄，无法通过编译</code></p><p><code>float f &#123;7&#125;; // 可以通过编译，这个可以转换会原类型，没有发生精度丢失，所以可以通过</code><br><code>int g &#123; 2.0 f&#125;; // 收窄，无法通过编译，2.0f是一个有精度的浮点数值，转换成整数会丢失精度</code><br><code>float *h = new float&#123;1e48&#125;; // 收窄，无法通过编译</code><br><code>float i = 1.21; // 可以通过编译</code></p><div class="tags"><a href="/tags/cpp/" rel="tag"><i class="ic i-tag"></i> cpp</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-06-30 16:22:27" itemprop="dateModified" datetime="2023-06-30T16:22:27+08:00">2023-06-30</time> </span><span id="2022/08/04/codelanguage/cpp11新特性篇2/" class="item leancloud_visitors" data-flag-title="cpp11新特性篇2" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Caleb <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://hdqjl317.github.io/2022/08/04/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%872/" title="cpp11新特性篇2">https://hdqjl317.github.io/2022/08/04/codelanguage/cpp11新特性篇2/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/08/01/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%871/" itemprop="url" rel="prev" data-background-image="&#x2F;assets&#x2F;cpp11.png" title="cpp11新特性篇1"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 编程语言</span><h3>cpp11新特性篇1</h3></a></div><div class="item right"><a href="/2022/08/10/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%873/" itemprop="url" rel="next" data-background-image="&#x2F;assets&#x2F;cpp11.png" title="cpp11新特性篇3"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 编程语言</span><h3>cpp11新特性篇3</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">继承构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%B4%BE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">委派构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">右值引用：移动语义和完美转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">显示转换操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">列表初始化</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/08/01/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%871/" rel="bookmark" title="cpp11新特性篇1">cpp11新特性篇1</a></li><li class="active"><a href="/2022/08/04/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%872/" rel="bookmark" title="cpp11新特性篇2">cpp11新特性篇2</a></li><li><a href="/2022/08/10/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%873/" rel="bookmark" title="cpp11新特性篇3">cpp11新特性篇3</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Caleb" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Caleb</p><div class="description" itemprop="description">欢迎来到 Caleb 的个人博客!</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">6</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">3</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">3</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hEcWpsMzE3" title="https:&#x2F;&#x2F;github.com&#x2F;HDqjl317"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmppYWxlX3F1YW5AdXN0Yy5lZHU=" title="mailto:jiale_quan@ustc.edu"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/08/01/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%871/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/08/10/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%873/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2023/06/30/computer-science/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理">编译原理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/codelanguage/" title="分类于 编程语言">编程语言</a></div><span><a href="/2022/08/04/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%872/" title="cpp11新特性篇2">cpp11新特性篇2</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/other/" title="分类于 杂谈">杂谈</a></div><span><a href="/2022/07/01/other/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/codelanguage/" title="分类于 编程语言">编程语言</a></div><span><a href="/2022/08/10/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%873/" title="cpp11新特性篇3">cpp11新特性篇3</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/worktech/" title="分类于 工作技能">工作技能</a></div><span><a href="/2022/08/20/worktech/vscode%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="vscode通过密钥连接远程服务器">vscode通过密钥连接远程服务器</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/codelanguage/" title="分类于 编程语言">编程语言</a></div><span><a href="/2022/08/01/codelanguage/cpp11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AF%871/" title="cpp11新特性篇1">cpp11新特性篇1</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Caleb @ Caleb</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">10k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">9 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/08/04/codelanguage/cpp11新特性篇2/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>